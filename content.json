{"meta":{"title":"劳振煜的博客","subtitle":"Lao Zhenyu's blog","description":"Warm welcome","author":"劳振煜","url":"https://OXygenPanda.github.io/OXygenPanda.github.io","root":"/OXygenPanda.github.io/"},"pages":[{"title":"links","date":"2020-11-10T11:38:00.000Z","updated":"2020-11-10T11:38:09.976Z","comments":true,"path":"links/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2020-11-10T11:38:00.000Z","updated":"2020-11-10T11:38:50.129Z","comments":true,"path":"repository/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-10T12:34:07.187Z","updated":"2020-11-10T12:34:07.179Z","comments":false,"path":"about/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/about/index.html","excerpt":"","text":"个人详细介绍 姓名：劳振煜 年龄：24岁 籍贯：浙江嘉兴 本科：宁波大学 通信工程 硕士：哈尔滨工程大学 计算机技术 联系方式 手机：18888641109 邮箱：&#x4c;&#97;&#x6f;&#122;&#x68;&#101;&#110;&#121;&#117;&#x5f;&#57;&#54;&#49;&#x31;&#x31;&#50;&#x40;&#49;&#x36;&#51;&#x2e;&#99;&#x6f;&#x6d; 自我介绍 热爱编程，喜欢C++，但接受转golang和Java，希望能够实现自我价值。 base : 上海，杭州，深圳，北京"},{"title":"分类","date":"2020-11-10T12:28:59.111Z","updated":"2020-11-10T11:22:57.808Z","comments":false,"path":"categories/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-11-10T12:26:54.548Z","updated":"2020-11-10T11:22:57.808Z","comments":false,"path":"books/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-10T12:26:32.160Z","updated":"2020-11-10T11:22:57.809Z","comments":false,"path":"tags/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-11-08T11:53:34.000Z","updated":"2020-11-08T11:54:11.563Z","comments":true,"path":"friends/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"深入理解操作系统学习笔记","slug":"OperatingSystem/QingHua/Deep_into_OperatingSystem_all","date":"2020-11-08T12:07:00.000Z","updated":"2020-11-11T12:39:34.778Z","comments":true,"path":"2020/11/08/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/08/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/","excerpt":"","text":"第一章 第一章的主要内容是 : 操作系统的一些知识 操作系统是什么？用户角度：操作系统是一个控制软件 管理应用程序 为应用程序提供服务 杀死应用程序 程序角度：操作系统是资源管理器 管理外设、分配资源 抽象 将CPU抽象成进程 将磁盘抽象成文件 将内存抽象成地址空间 操作系统层次位于硬件之上，应用程序之下。 操作系统的界面和内核Linux Windows Android 的界面属于外壳(Shell) ，而不是内核(kernel)。操作系统研究的是内核，处于Shell之下。 操作系统内部组件 CPU调度器 物理内存管理 虚拟内存管理 文件系统管理 中断处理与设备驱动 操作系统特征 并发 一段时间内运行多个进程（并行 : 一个时间点运行多个进程，一般要求有多个CPU) 需要OS管理和调度 共享 “同时”共享 互斥共享 虚拟 让每一个用户觉得的有一个计算机专门为他服务 异步 程序是走走停停，而不是一直运行 第二章 第二章的主要内容是 : 操作系统的异常/中断/系统调用 探究计算机启动过程作用解析 Disk : 存放OS和Bootloader BOIS : 基于I/O处理系统 Bootloader : 加载OS，将OS放入内存 结构 Disk |___ OS |___ Bootloader 开机流程 BIOS 开机后，寻找显卡和执行BIOS (此时, CS : IP = 0xF000 : 0xFFF0, CS/IP 两个寄存器) 将Bootloader从磁盘的引导扇区加载到0x7C00 (Bootloader一共占用512M字节的内存) 跳转到 CS : IP = 0x0000 : 0x7C00 Bootloader 将操作系统的代码和数据从硬盘加载到内存中 跳转到操作系统的起始地址 中断、异常、系统调用中断中断来源于外设，来自不同的硬件设备的计时器和网络的中断。 中断流程 硬件：设置中断标记（CPU初始化） 将内部、外部事件设置中断标记 中断事件的ID 软件 保存当前处理状态（寄存器之类的一些数据） 根据中断事件的ID跳转到中断服务程序，中断服务程序处理 清楚中断标记 异常异常来源于不良的应用程序，非法指令或者其他坏的处理状态（如：内存出错）。 异常处理流程 保存现场 异常处理 杀死了产生异常的程序 重新执行异常指令 恢复现场 系统调用系统调用来源于应用程序，应用程序主动向操作系统发出服务请求。程序访问主要是通过高层次的API，而不是直接调用系统调用函数。 APIs Win32 API 用于Windows POSIX API 用于 POSIX-based systems（包括UNIX，LINUX，Mac OS X） Java API 用于JAVA虚拟机 特点 通常情况下，每个系统调用有对应的序号 系统调用接口根据这些序号来维护表的索引 系统调用接口调用内核态中预期的系统调用 并返回系统调用的状态和其他任何返回值 用户不需要知道系统调用是如何实现的 只需要获取API和了解操作系统将什么作为返回结果 操作系统接口的细节大部分都隐藏在API中 用户态：操作系统运行中，CPU处于的特权级别，不能直接执行特权指令 内核态：操作系统运行中，CPU处于的特权级别，可以执行任何一条指令 系统调用：触发CPU从用户态到内核态的转换，切换程序和内核的堆栈，需要一定的开销 跨越操作系统边界的开销（值得的且必须的，保证了操作系统的安全性） 在执行时间上的开销超过程序调用 开销： 建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销 建立内核堆栈 验证参数 内核态映射到用户态的地址空间（更新页面映射权限） 内核态独立地址空间（TLB） 区别 类型 源头 处理时间 响应 中断 外设 异步 持续，对应用程序透明 异常 应用程序意向不到的行为 同步 杀死或重新执行指令 系统调用 应用程序请求系统提供服务 同步或异步 等待和持续 异步：应用程序不知道什么时候会发生中断 同步：执行到某一条指令一定会发生该事件 为什么应用程序不能直接访问硬件？ 在计算机运行时，内核是被信任的第三方 只有内核可以执行特权指令 为了方便应用程序 第三章 第三章的主要内容是 : 操作系统的物理内存管理 计算机体系结构 CPU 内存 I/O 内存分层体系内存分层体系运行内存(主存) / 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间. CPU可以访问的内存包括两大类 : 寄存器 / cache(L1缓存 / L2缓存) 层次 微处理器(CPU访问) |___CPU寄存器 / L1缓存 |___L2缓存 主存(程序访问) 磁盘(程序访问) 从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。 内存管理目标 抽象：逻辑地址空间 保护：独立地址空间 共享：访问相同内存 虚拟：更多的地址空间 内存管理方法 程序重定位 分段 分页 虚拟内存 按需分页虚拟内存 实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求 地址空间地址空间的定义 物理地址空间 —— 硬件支持的地址空间( address : [0, Max_sys] ) 逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] ) 连续内存分配内存碎片问题内存碎片问题指的是空闲的内存无法被利用 外部碎片 : 分配单元间的未使用内存 内部碎片 : 分配单元内的未使用内存 分区的动态分配分区的动态分配方式有以下三种 : 第一匹配分配 : 在内存中找到第一个比需求大的空闲块, 分配给应用程序 最优适配分配 : 在内存中找到最小的空闲块, 分配给应用程序 最差适配分配 : 在内存中找到最大的空闲块, 分配给应用程序 分配方式的区别 分配方式 第一匹配分配 最优适配分配 最差适配分配 分配方式实现需求 1. 按地址排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区 1. 按尺寸排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区 1. 按尺寸排序的空闲块列表2. 分配最大的分区3. 重分配需要检查是否可以合并相邻空闲分区 优势 简单 / 易于产生更大空闲块 比较简单 / 大部分分配是小尺寸时高效 分配很快 / 大部分分配是中尺寸时高效 劣势 产生外部碎片 / 不确定性 产生外部碎片 / 重分配慢 / 产生很多没用的微小碎片 产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配 三种分配方式并无优劣之分，因为我们无法判断内存请求的大小 碎片整理方法可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。 压缩式碎片整理 重置程序以合并碎片 要求所有程序是动态可重置的 问题 : 何时重置 ? (在程序处于等待状态时才可以重置) 需要考虑内存拷贝的开销 交换式碎片整理 运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存 问题 : 哪些程序应该被回收 ? 情况 : 运行中 : P3 等待中 : P1 P2 P4 内存分布 -&gt; 主存 : OS / P1 / P3 / P2 / P4 磁盘 : 空 当P3程序需要更大的内存时 -&gt; 内存分布 -&gt; 主存 : OS / P1 / P3 / P2 磁盘 : P4 第四章 第四章的主要内容是：操作系统的非连续内存分配 第三章介绍的是连续内存管理, 即 : 操作系统加载到内存以及程序加载到内存中时, 分配一块连续的空闲(内存)块. 但是容易出现碎片问题, 这一章介绍的非连续内存分配可以有效的减少碎片的出现. 非连续内存分配的必要性连续内存分配的缺点 分配给一个程序的物理内存是连续的 内存利用率低 有外碎片 / 内碎片的问题 非连续内存分配的优点 一个程序的物理地址空间是非连续的 更好的内存利用和管理 允许共享代码与数据(共享库等…) 支持动态加载和动态链接 非连续内存分配的缺点 建立虚拟地址和物理地址的转换难度大 软件方案 硬件方案(采用硬件方案) : 分段 / 分页 非连续内存分配分段(Segmentation)段 : 在程序中会有来自不同文件的函数 ; 在程序执行时, 不同的数据也有不同的字段, 比如 : 堆 / 栈 / .bss / .data 等 **分段 : **更好的分离和共享 程序的分段地址空间如下图所示 : 分段寻址方案 逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联. 一个段 : 一个内存”块” 程序访问内存地址需要 : 一个二维的二元组(s, addr) → (段号, 地址) 操作系统维护一张段表, 存储(段号, 物理地址中的起始地址, 长度限制) 物理地址 : 段表中的起始地址 + 二元组中的偏移地址 分页(Paging)分页地址空间划分物理内存至固定大小的帧(Frame) 大小是2的幂, 512 / 4096 / 8192 划分逻辑地址空间至相同大小的页(Page) 大小是2的幂, 512 / 4096 / 8192 建立方案 → 转换逻辑地址为物理地址(pages to frames) 页表 MMU / TLB 帧(Frame) 物理内存被分割为大小相等的帧. 一个内存物理地址是一个二元组(f, o) → (帧号, 帧内偏移) 帧号 : F位, 共有2^F个帧 帧内偏移 : S位, 每帧有2^S个字节 物理地址 = 2^S * f + o (例子 : 16-bit地址空间, 9-bit(512 byte) 大小的页帧 物理地址 = (3,6) 物理地址 = 2^9 * 3 + 6 = 1542) 分页和分段的最大区别 : 这里的 S 是一个固定的数, 而分段中的长度限制不定 页(Page) 一个程序的逻辑地址空间被划分为大小相等的页. 页内偏移的大小 = 帧内偏移的大小 页号大小 &lt;&gt; 帧号大小 一个逻辑地址是一个二元组(p, o) → (页号, 页内偏移) 页号 : P位, 共有2^P个页 页内偏移 : S位, 每页有2^S个字节 虚拟地址 = 2^S * p + o 页寻址方案操作系统维护一张页表, 页表保存了逻辑地址——物理地址之间的映射关系 存储 : (页号, 帧号) 逻辑地址空间应当大于物理内存空间 页映射到帧 页是连续的虚拟内存 帧是非连续的物理内存(有助于减少碎片的产生) 不是所有的页都有对应的帧 页表(Page Table)页表概述每一个运行的程序都有一个页表 属于程序运行状态, 会动态变化 PTBR : 页表基址寄存器 转换流程 CPU根据程序的page的页号的若干位, 计算出索引值index, 在页表中搜索这个index, 得到的是帧号, 帧号和原本的offset组成物理地址. 页表中还有一些特殊标志位 dirty bit, resident bit, (0 : 对应的物理页帧在内存中不存在 ; 1 : 存在) clock / reference bit 转换实例 16位地址的系统 32KB的物理内存 每页的 1024 byte 逻辑地址空间 : (4, 0) … (3, 1023) 页表 : Flags | Frame nums 1 0 1 0 0 0 0 0 → 内存访问异常(可能要杀死程序) 0 1 1 0 0 1 0 0 → 页帧是4 偏移是 1023 → 物理地址 (4, 1023) 分页机制的性能问题访问一个内存单元需要2次内存访问 一次用于获取页表项 一次用于访问数据 页表可能非常大 64位机器如果每页1024字节, 那么一个页表的大小会是多少？(2^64 / 2^10 = 2^54 存放不下) 每一个运行的程序都需要有一个页表 如何处理？ 缓存(Caching) 间接(Indirection)访问 转换后备缓冲区(TLB)缓解时间问题 Translation Look-aside Buffer(TLB) 是一个缓冲区. CPU中有快表TLB(可以将经常访问的页表存放在这边) 缓存近期访问的页帧转换表项 TLB使用关联内存实现, 具备快速访问性能 如果TLB命中, 物理页号可以很快被获取 如果TLB未命中, 对应的表项被更新到TLB中(x86的CPU由硬件实现, 其他的可能是由操作系统实现) 二级/多级页表时间换空间 二级页表 将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表. 一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号 节约了一定的空间, 在一级页表中如果resident bit = 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留 多级页表 通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树” 反向页表解决大地址空间问题 目的 : 根据帧号获得页号 反向页表只需要存在一张即可 有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表 不是让页表与逻辑地址空间的大小相对应, 而是当页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间 基于页寄存器(Page Registers)的方案存储 (帧号, 页号) 使得表大小与物理内存大小相关, 而与逻辑内存关联减小. 每一个帧和一个寄存器关联, 寄存器内容包括 : resident bit : 此帧是否被占用 occupier : 对应的页号 p protection bits : 保护位 实例 : 物理内存大小是 : 4096 * 4096 = 4K * 4KB = 16 MB 页面大小是 : 4096 bytes = 4 KB 页帧数 : 4096 = 4 K 页寄存器使用的空间(假设8 bytes / register) : 8 * 4096 = 32 Kbytes 页寄存器带来的额外开销 : 32K / 16M = 0.2% 虚拟内存大小 : 任意 优势 : 转换表的大小相对于物理内存来说很小 转换表的大小跟逻辑地址空间的大小无关 劣势 : 需要的信息对调了, 即根据帧号可以找到页号 如何转换回来? (如何根据页号找到帧号) 在需要在反向页表中搜索想要的页号 基于关联内存(associative memory)的方案硬件设计复杂, 容量不大, 需要放置在CPU中 如果帧数较少, 页寄存器可以被放置在关联内存中 在关联内存中查找逻辑页号 成功 : 帧号被提取 失败 : 页错误异常 (page fault) 限制因素: 大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电) 基于哈希(hash)的方案哈希函数 : h(PID, p) 从 PID 标号获得页号 在反向页表中通过哈希算法来搜索一个页对应的帧号 对页号做哈希计算, 为了在帧表中获取对应的帧号 页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数 为了查找页 i , 执行下列操作 : 计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器 检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"深入理解操作系统学习笔记","slug":"深入理解操作系统学习笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C++11新语法新特性使用剖析","slug":"C++11/C++11","date":"2020-11-03T15:27:00.000Z","updated":"2020-11-11T10:01:29.078Z","comments":true,"path":"2020/11/03/C++11/C++11/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/03/C++11/C++11/","excerpt":"","text":"C++ 11 还记得自己在本科阶段学习的C++98的语法，那个时候觉得很有趣了。但是慢慢地接触到了C++11之后的新增语法，打开了新世界的大门，许多实现有了更有禅意/哲学的方法。 本文参考了侯捷老师 C++2.0 的课程以及CSDN上众多的博客，总结了C++11以来，新增的一些语法，比如：variadic templates、alias templates、uniform initialization等，新增的一些关键词，比如：explicit、override、final、decltype等。我认为，C++11以来新增的语法是C++发展中的新鲜血液，在STL的源码学习过程中，也看到了许多C++11以来的新语法，新关键词。所以说，学习C++11是十分有必要且有趣的。 C++版本发展 名称 版本 备注 C++ 98 1.0 C++ 03 TR1 technicasl report 1 C++ 11… 2.0 新语法新语法包括但不限于以下介绍的：variadic templates(可变参数模板)、move(搬移)、range-base for loop(简写循环)、initializer list(新容器)、lambda(表达式)、type_traits(类型萃取器)、unordered_set/map(hashtable)、forward_list(单向链表)、tuple(元组)、con-currency、RegEx… variadic templatesnullptrnullptr 是C++11后安全的指针空值常量，是一个类型为 std::nullptr_t 的对象。 在C语言中，我们常用NULL来表示指针为空。那我们可以先看一下在C语言和在C++中 NULL 的定义。 1234567891011//C#define NULL ((void*)0)//C++#ifndef NULL#ifdef _cplusplus#define NULL 0 //可以看到,在C++中NULL就是0#else#define NULL ((void*)0)#endif#endif 如果沿用C语言中 NULL 的定义，在C++中有函数重载的机制，会出现二义性的问题，如下。 1234567891011//二义性实例#undef NULL#define NULL ((void*)0)void func(int n)&#123;&#125;void func(char* cp)&#123;&#125;int main()&#123; func(NULL); return 0;&#125; 可以得到二义性的报错，因为 NULL 的 ((void*)0) 既可以被 5: 接收，也可以被 6: 接收。 为避免二义性的错误，C++不支持void*转换为其他指针类型。因此有了 nullptr，定义在 &lt;cstddef&gt; 中的一个新类型 std::nullptr_t，可以隐式转换为任意指针类型，是一个”指针空值常量”。 nullptr的安全性 12345//安全性示例int n1 = nullptr;int n2 = (int)nullptr;int n3 = reinterpret_cast&lt;int&gt;(nullptr);//以上三行均报错 可以看到此时，nullptr 无法隐式显式强制类型转换为其他非指针类型。 POD type / =default &amp; =delete首先来了解一下 POD 类型。 POD( plain old data)：能够使用C标准库中的memcpy()函数操作的数据类型和结构体就是POD类型。可以通过中的 is_pod&lt;T&gt;::value 来判定。 C++相比C语言多了虚函数，继承，访问权限等机制，往往定义的类不是POD类型，无法使用memcpy()。那么成为 POD 类型有以下两个要求： 该类型必须是平凡的普通的 (平凡 : trival : &lt;type_traits&gt; 中常见的一个词了) 不自己定义构造函数，析构函数，拷贝构造函数，拷贝赋值函数，搬移构造函数和搬移赋值函数，而是由编译器默认生成，那么就是平凡的。 或者，在自己定义了构造函数(以上只有构造函数可以重载)后，再增加一行ClassName() = default;也可以算得上是平凡的。 不能够有虚函数或者继承虚基类。（不能携带虚表指针） 123456class base&#123;public: base(int a)&#123;&#125;; base() = default;&#125;;//is_pod(base)::value == true_type() 像C标准布局一样，布局有序 非静态成员变量的访问权限必须相同。 如果继承了父类，那么第一个成员变量必须是自己类的。 如果继承了父类，那么成员得集中在一个类中。 如果满足了以上两点，可以使用 memcpy() 函数。 1234567891011121314151617//POD类型进行memcpy()示例class A&#123;public: int a; int b;&#125;;int main()&#123; A a1; a1.a = 10; a1.b = 20; char* p = new char[sizeof(a1)]; memcpy(p,&amp;a1,sizeof(a1)); A* a2 = reinterpret_cast&lt;A*&gt;(p); cout &lt;&lt; a2-&gt;a &lt;&lt; &quot; &quot; &lt;&lt; a2-&gt;b &lt;&lt; endl; return 0;&#125; =default : 可以指定需要编译器自动生成 big five 的函数。可以在重载其他构造函数的情况下，仍然使得类可能成为 POD 类型。 =delete : 对于不希望使用的构造函数，析构函数，拷贝构造函数，拷贝赋值函数，搬移构造函数和搬移赋值函数，曾经的做法是定义在 private 域中并不给予实现使得无法调用。而现在可以写在 public 域中并在最后写上 =delete 意为不能使用。用户函数可以 =delete 而不可以使用 =default。 Rvalue references &amp; Move Semantics / Perfect Forwardingmove是一个C++11后的重要话题，它极大地节约了原本copy时，析构以及拷贝构造的时间成本。 要聊move首先得了解一下左值和右值的概念，以及左值引用和右值引用的区别。 左值 : 在堆区栈区常量区(.bss / .data)中有内存分配的变量/对象。特点 : 可以放在 operator= 左侧。 右值 : 不能够取地址或者是消亡值。如：运算式，除字符串以外的字面值，临时变量/对象，返回 void 的函数调用。 ​ 消亡值 : 即将销毁的变量/对象。 左值引用 : 引用本质上是取别名，使用引用语法，编译器会为引用动作进行一定的翻译以及在使用时会自动解引用。引用对象如果是一个左值，那么T &amp;ref = val;引用等效于T * const ref = val; ，如果引用对象是一个右值，那么需要在引用前加一个const修饰,如:const T &amp;ref = 16。 右值引用 : 通过”盗取”右值资源而不需要分配额外的资源，获得控制权。在确保之后不再使用该右值，可以避免内存空间的释放和分配，延迟变量名的生命周期，常用来完成移动构造 (move constructor) 和移动赋值 (move assignment) 的特殊任务。 std::move() : 可以把左值转换为右值，但是前提是程序员要确保后续不再使用传递的左值。 123//std::move() 示例vector&lt;int&gt; vec&#123;1,3,2,5,4,1,2,3,4,6,7,9&#125;;vector&lt;int&gt; target = std::move(vec); //省去了元素的拷贝,虽然int类型是微不足道的,但是如果是特别大的对象的话,很值得 搬移机制 如果把右值传递给需要move_ctor 或 move_assign 的时候，会触发搬移机制，首先指针浅拷贝，再断开右值的指针控制。 如果把左值传递给需要move_ctor 或 move_assign 的时候，可以使用 std::move() 可以把左值转换成右值。 万能引用 在模板编程的时候，有时候并不知道传进来的是左值还是右值，因此引入了万能引用和引用折叠的概念。万能引用：在类型推导中 &amp;&amp; 符号可以接收左值也可以接收右值。 引用折叠 12345//引用折叠示例template&lt;typename T&gt;void func(T&amp;)&#123;&#125;template&lt;typename T&gt;void func(T&amp;&amp;)&#123;&#125; 当传入的 T 类型本身就是一个左值引用或者右值引用类型时，形式参数类型会出现T&amp; &amp; T&amp; &amp;&amp; T&amp;&amp; &amp; T&amp;&amp; &amp;&amp; 其中，T&amp;&amp; &amp;&amp; 会被解析成为 T &amp;&amp; 其余，被解析成为 T &amp; 不完美转发 使用函数传递右值时，最终调用端接收到的是左值。 123456789//不完美转发 示例//重载的分别接收左值和右值的函数void process(int &amp; i) &#123; cout &lt;&lt; &quot;&amp;&quot; &lt;&lt; endl; &#125;void process(int&amp;&amp; i) &#123; cout &lt;&lt; &quot;&amp;&amp;&quot;&lt;&lt; endl; &#125;//转发函数void forward(int&amp;&amp; i)&#123; cout &lt;&lt; &quot;forward &amp;&amp;&quot; &lt;&lt; endl; process(i); //此处期望调用的是process(int&amp;&amp;),但是实际上调用的是process(int&amp;)&#125; 完美转发 123456//完美转发设计形式template&lt;typename T1, typename T2&gt;void functionA(T1&amp;&amp; t1, T2&amp;&amp; t2)&#123; functionB(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));&#125; 1234567891011121314151617181920212223//完美转发 forward&lt;T&gt;() 的源码// GCC/4.9.2/.../move.htemplate&lt;typename _Tp&gt;constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept&#123; return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#125;template&lt;typename _Tp&gt;constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept&#123; //编译期断言 static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value,&quot;template argument&quot; &quot; substituting _Tp is an lvalue reference type&quot;); return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#125;//std::move()template&lt;typename _Tp&gt;constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;move(_Tp&amp;&amp; __t) noexcept&#123; return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); &#125; range-based for statement语法用法如下。 123456789101112131415161718//语法for(decl : coll)&#123; statement&#125;编译器翻译-&gt;for(auto _pos = coll.begin(), _end = coll.end(); _pos != _end; ++_pos)&#123; decl = *_pos; statement&#125;//用法for(int i : &#123;1,2,3,4,5,6,7&#125;) std::cout &lt;&lt; i &lt;&lt; std::endl;vector&lt;double&gt; vecfor(auto &amp; elem : vec) //使用引用传递可以修改元素 elem *= 3; thread 线程库智能指针pragma once1#pragma once 确保头文件只会被包含一次。 extern “C”在C++的代码中运行C语言的代码 123456789#ifdef __cplusplusextern &quot;C&quot; &#123; //抑制C++对函数名、变量名等符号进行名称重整，因此编译出的C目标文件和C++目标文件中的变量名和函数名都一样的。#endif...#ifdef __cplusplus&#125;#endif 类初始化列表常量表达式enum classtupleuniform initialization / initializer_listsC++11前的初始化方式众多，容易记混且不美观不一致。C++11后有统一的推荐的初始化方式。 12345678910// C++11 前的初始化语法Rect r1 = &#123;3,5,8,20,&amp;area,&amp;print);Rect r1(3,7,20,25);int ia[6] = &#123;27,210,12,47,10,83&#125;;// C++11 后的初始化语法int values[]&#123;1,2,3&#125;;vector&lt;int&gt; v&#123;1,2,3,4,5,6&#125;; // vector 包含了一个 initializer_list&lt;value_type&gt; 的构造函数vector&lt;string&gt; cities&#123;&quot;berlin&quot;,&quot;london&quot;,&quot;new york&quot;&#125;;//编译器把&#123;t1,t2,...,tn&#125;制作成一个 initializer_list&lt;T&gt; 关联一个 array&lt;T,n&gt; 会调用构造函数 &#123;&#125; 创建了一个initializer_lists的容器。 接下来介绍 initializer_lists容器的用法和源码。 12345678910111213141516171819202122232425//用法//用于赋初值int i; //未知int j&#123;&#125;; //j == 0int *p; //未知int *q&#123;&#125;; //q == nullptr//initializer_lists 不能类型转换,更加安全int x1(5.3), x2 = 5.3; //传统的方式会把double隐式类型转换为intint x3&#123;5.0&#125;,x4&#123;5.3&#125;; //取决于编译器char c1&#123;7&#125;; //正确char c2&#123;999999&#125;; //错误vector&lt;int&gt; v1&#123;1,2,3,4&#125;; //正确vector&lt;int&gt; v2&#123;1,2.0,3.0,4&#125;; //错误//函数显式接收 initializer_lists 类型void print(std::initializer_list&lt;int&gt; vals)&#123; for(auto p = vals.begin();p!=vals.end();++p) cout&lt;&lt; *p &lt;&lt; endl;&#125;print(&#123;1,2,3,4,5&#125;);//利用临时对象筛选max(&#123;1,2,3,4,5,6&#125;);min(&#123;string(&quot;Ace&quot;),string(&quot;Bob&quot;),string(&quot;Coc&quot;)&#125;); 1234567891011121314151617//源码template&lt;class _E&gt;class initializer_list&#123;public: typedef _E value_type; ...private: iterator _M_array; //只管理指针,拷贝时是浅拷贝 size_type _M_len; //The compiler can call this constructfunction constexpr initializer_list(const iterator _a, size_type _l): _M_array(_a),_M_len(_l) &#123;&#125;public: //其他构造函数 lambda lambda 是希腊符号之一，第一次是在python中听到这个词，后在java中也接触到。现在来讲讲C++11/13中的lambda语法。 lambda 在C++中是一种匿名函数。我们通常来说，使用一个函数是为了提高代码的可复用性以及可读性，我们会在主函数外或者源文件外定义函数，最终通过链接生成可执行文件。那么对于一些我们只需要用到个别次数的代码，我们不需要为它命名并且写成函数的形式，我们只需要写一个 lambda 表达式即可。 lambda 属于函数式编程范式的范畴。 语法1[capture list](parameters) mutable -&gt; return type &#123; statement &#125; [capture list] : 捕获列表 [var] : 值传递的方式捕获 var [=] : 值传递的方式捕获所有变量 [&amp;var] : 引用传递的方式捕获var [&amp;] : 引用传递的方式捕获所有变量 [this] : 值传递的方式捕获this (parameters) : 参数传递列表，可以省略 mutable : 修饰符，取现 lambda 的常量性，但是必须携带参数传递列表，可以省略 (mutable 允许可以变化, 不加的话, 语句块中无法修改变量) [id] () mutable {} : 允许修改 id [&amp;id] () {} : 允许修改 id [id] () {} : 不允许修改 id -&gt;return type : 返回值类型，不需要返回或者返回值类型明确时可以省略 { statement } : lambda 语句块 示例1234567891011121314//示例1int a = 1, b =2, c = 3;auto func = [=,&amp;b](int d) -&gt; decltype(a+b+c+d)&#123; return a+b+c+d;&#125;std::cout &lt;&lt; func(4) &lt;&lt; std::endl;/* 说明** 以引用方式捕获变量 b, 使得 b 可以在语句块中被修改, 以值方式捕获变量 a,c 不可以在语句块中修改** 参数列表需要传入一个int类型变量** decltype() 做类型推导** func 是 lambda 表达式的名称 可以以 6: 方式调用** auto lambda 表达式的返回类型相当复杂,使用auto自动推导较为合适*/ 1234567//示例2[]&#123; std::cout &lt;&lt; &quot;success&quot; &lt;&lt; std::endl;&#125;(); //创建了一个lambda的临时对象auto L = []&#123;std::cout &lt;&lt; &quot;success&quot; &lt;&lt; std::endl;&#125;;L(); //lambda 表达式调用形式 12345678//示例3vector&lt;int&gt; vec&#123;1,2,3,3,4,5,8,5,4,3&#125;;sort(vec.begin(),vec.end(),[](int a,int b)-&gt;bool&#123; return a&gt;b;&#125;); //第三个参数需要一个bool的函数对象,可以是自定义函数也可以是仿函数也可以是lambda表达式for (const auto &amp;elem : vec) &#123; cout &lt;&lt; elem &lt;&lt; endl;&#125; //倒序输出vec的值 12345//注意事项int id = 0;auto f = [id]()&#123;&#125;; //此处捕获到的是0,即使后续变化也不会受影响auto g = [&amp;id]()&#123;&#125;;//此处捕获到的是0,但是后续id的变化会引起此处的变化id = 42; 123456789101112131415161718//lambda表达式需要编译器进行&quot;翻译&quot;//类似翻译情况如下auto f = [id]() mutable &#123; std::cout &lt;&lt; &quot;id:&quot; &lt;&lt; id &lt;&lt; std::endl; ++id; &#125;;-&gt; class Functor&#123;private: int id;public: Functor(int id):id(id)&#123;&#125; void operator()&#123; std::cout &lt;&lt; &quot;id:&quot; &lt;&lt; id &lt;&lt; std::endl; ++id; &#125;&#125;Functor f; 新关键词新关键词包括但不限于以下介绍的：using、auto、explicit、noexcept、override、final、decltype… using / Alias Template / Type Aliasusing 关键字并不是C++11以后才出现的，但是在C++11以后赋予了新的语法。 namespace using-指示 : using namespace std; 引入整个命名空间 会引发命名污染，使得较小作用域中定义的同名函数、变量会覆盖命名空间中的函数和变量。在较大的作用域中应当使用 using-声明 using-声明 : using std::cout, std::endl; 引入命名空间中的指定变量、对象、函数 class membersusing-声明 在类中声明基类的对象或方法后，可以省略基类作用域。 12345678910//使用using关键字对类成员变量成员函数的声明class base&#123;public: void based()&#123;&#125;&#125;;class derived : public base&#123; using base::based; void func()&#123; based(); &#125;// 不需要写成 base::based()&#125;; Alias TemplateAlias 熟悉配置 linux / Mac OS 系统环境的小伙伴都知道，是化名的意思。这是C++11新增的语法，能够提前绑定模板参数。用法如下： 12345//使用using关键字对类模板进行运行时绑定参数template&lt;typename T&gt;using MapString = map&lt;T,char*&gt;;MapString&lt;int&gt; numberString; //解析成 map&lt;int,char*&gt; numberString： 从以上代码可以看到，2:提前绑定了map容器的第二参数，此后模板参数只剩下一个了，在定义对象时只需要指定第一模板参数即可。有一种&lt;运行时&gt;偏特化的感觉。侯捷老师提供了一个案例，是对使用 alias template 的较好诠释。 1234567891011121314//侯捷老师的例子template&lt;typename T, template&lt;class&gt; class Container&gt;class XCLs&#123;private: Container&lt;T&gt; c;public: XCLs()&#123;&#125;&#125;;XCLs&lt;int,vector&gt; xcls; //报错,因为vector容器实际上需要两个参数,这样传入只能确认一个参数template&lt;T&gt;using vec = vector&lt;T,allocator&lt;T&gt;&gt;;XCLs&lt;int,vec&gt; xcls; //正确,提前绑定第二参数 因为 vector 模板类本身有两个模板参数 : _Tp 和 alloc，而 alloc 是有默认参数的。所以，平时使用时，我们往往缺省第二参数只指定第一个模板参数类型。而 5:Container&lt;T&gt; c 只指定了第一参数，因此在 2: 传入 Container 时就提前确定第二参数，因此有了 13: Alias Template 的操作。 Type Alias类似于 typedef 的语法。（结果看来和 typedef 一样） 123456789101112131415161718//using关键字定义新类型名typedef void(*func1)(int,int); //func1 绑定为 void x(int,int) 型函数指针using func2 = void(*)(int,int); //结果同 1://演示1void example(int a, int b);func1 fn1 = example;func2 fn2 = example;//演示2template&lt;typename T&gt;class vector&#123;public: using ValueType = T; using reference = T&amp;; using iterator = T*; using pointer = T*; //vector中的实现还是typedef&#125; autoexplicit常用于修饰构造函数，使得构造函数不支持其他变量隐式类型转换成该类型对象（禁止隐式类型转换） 123456789101112131415161718192021222324class base&#123;private: int a; int b;public: base(int a,int b = 0)&#123;&#125; // non-explicit one-argument ctor base&amp; operator=(const base&amp; ref)&#123; this-&gt;a = ref.a; this-&gt;b = ref.b; &#125; base operator+(const base&amp; ref)&#123; this-&gt;a += ref.a; this-&gt;b += ref.b; return *this; &#125;&#125;;int main()&#123; base obj1(1,0),obj2(2,0); obj2 = obj1 + 5; //如果6:不使用 explicit 修饰,首先看到了重载了operator+接收本类型. 此处 5 转换成为 base 类的临时对象 (5,0) 和 obj1 相加 //如果6:使用 explicit 修饰,不允许隐式类型转换,找不到operator+接收数值类型类别的重载,因此报错 &#125; C++11前，只支持 one-argument C++11后，支持 multi-argument noexcept异常是一门大学问。在程序中必须处理异常，如果不处理，异常会传递给调用端，直到 std::terminate() 然后调用 std::abort() 结束程序。 1234567//c++17void foo() noexcept; //等价于 void foo() noexcept(true);void swap(Type&amp; x, Type&amp; y) noexcept(noexcept(x.swap(y)))&#123; //如果 x.swap(y) 不产生异常,那么保证函数不产生异常 x.swap(y); ...&#125; 12345678910111213141516171819202122//在搬移构造和搬移赋值时的应用// you need to inform C++(specially std::vector) that your move constructor and destructor does not throw.// that the move constructor will be called when the vector grows.// if the constructor is not noexcept, std::vector can&#x27;t use it.// since then it can&#x27;t ensure the exception guarantees demanded by the standard.// 自定义的类型,必须告知vector,你这个类型的搬移构造和搬移赋值是不会抛出异常的,vector在成长过程中才敢使用class MyString&#123;private: char * _data; size_t _len;...public: // move constructor MyString(MyString&amp;&amp; str) noexcept : _data(str),_len(str._len) &#123;&#125; // move assignment MyString&amp; operator=(MyString&amp;&amp; str) noexcept &#123; ... return *this; &#125;&#125;;//只有对拷贝构造和拷贝赋值函数用 noexcept 修饰,vector&lt;MyString&gt; 的时候才会考虑 std::move overrideoverride 编译器会检查你是否是在重写父类的虚函数 12345678910111213141516struct Base&#123; virtual void vfunc(float)&#123;&#125;&#125;;struct Drived : Base&#123; virtual void vfunc(int)&#123;&#125; //C++11前的语法如此,一旦虚函数写错就会出现问题&#125;;/**************/struct Drived : Base&#123; //写错,报错 virtual void func(int) override &#123;&#125; //C++11后增加的 override 修饰词, 可以检查当前函数是否是基类的虚函数(检查:返回类型,函数名,参数列表) //写对 virtual void func(float) override &#123;&#125;&#125;; final后置修饰类名：说明该类在继承体系中无法被继承 : struct base final &#123;&#125;; 后置修饰虚函数：不允许该虚函数在子类中重写 123class CPoint2D final&#123; virtual void Draw() final;&#125; decltypedecltype(表达式) : 返回 表达式的类型 在编译期完成 : decltype(a*b) 相关内容 : typeid() 可以返回一个类型的id，可以用于判断两个类别是否相同，但是无法用于声明该类型的变量 : if(typeid(T::iterator) == typeid(forward_iterator) 12345map&lt;string, float&gt; coll;...//在你定义很久以后,忘记某个类型或者自己不知道它的类型的时候,使用类型推导十分方便decltype(coll)::value_type elem; // 编译器编译期内翻译成为 map&lt;string, float&gt;::value_type elem; 主要用法 函数返回类型时使用 decltype() 1234567template&lt;typename T1, typename T2&gt;decltype(x+y) add(T1&amp; x, T2&amp; y); //使用 decltype() 可以在写函数的时候不知道处理完之后到底要返回什么类型,要取决于 x+y 的返回类型’但是以上写法编译不会通过,因为 decltype 处不知道 x 和 y 是什么符号template&lt;typename T1, typename T2&gt;auto add(T1&amp; x, T2&amp; y) -&gt; decltype(x+y); lambda函数返回类型时使用 decltype() 12345678[...](...) mutable -&gt; decltype(...) &#123;...&#125;auto cmp = [](const Person&amp; p1, const Person&amp; p2) &#123; return p1.lastname() &lt; p2.lastname() || (p1.lastname() == p2.lastname() &amp;&amp; p1.firstname() &lt; p2.firstname());&#125;;//通过decltype(cmp) 传入比较的匿名函数std::set&lt;Person,decltype(cmp)&gt; coll(cmp); 用于确认一个对象的类型时使用 decltype() 1typedef typename decltype(obj)::iterator itype; //使用类作用域运算符 :: 时, 必修需要加 typename","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"C++11","slug":"C/C-11","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/C-11/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"C++11","slug":"C-11","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C-11/"}]},{"title":"理解 type_traits","slug":"STL源码剖析/STL-type traits","date":"2020-10-31T09:42:00.000Z","updated":"2020-10-31T09:56:09.693Z","comments":true,"path":"2020/10/31/STL源码剖析/STL-type traits/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/31/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/STL-type%20traits/","excerpt":"","text":"__type_traits &lt;__type_traits.h&gt; 是 SGI 版本的 STL 的实现，其他版本的 STL 没有去调研过是否存在类型萃取。但是侯捷老师的源码剖析已经过去了那么多年，我相信比较好的一些实现，还是会被其他版本进行借鉴的。 前一篇文章是 iterator_traits 迭代器萃取器，可以感受到，迭代器的萃取器会萃取出迭代器的元数据 : value_type difference_type pointer reference iterator_category。其中最重要的 iterator_category 元数据对一些算法进行选择有很大的帮助。 相同的，__type_traits 负责萃取类型的元数据，比如 : 某类型是否拥有不重要的默认构造函数 has_trivial_default_constructor 。在迭代器萃取器中的 iterator_category 会回答五种类型，在类型萃取器中只会回答两种类型：__true_type __false_type。 1234struct __true_type&#123;&#125;;struct __false_type&#123;&#125;;// 不需要实现,进行函数调用时,需要不同的类型才能够进行类型推导// 而不能是只回答同样bool类型的 : true / false _type_traits 源码1234567891011121314151617181920212223242526272829303132333435363738394041// __type_traits 的写法// 泛化__type_traitstemplate&lt;class type&gt;struct __type_traits&#123; typedef __true_type this_dummy_member_must_be_first; typedef __false_type has_trivial_default_constructor; typedef __false_type has_trivial_copy_constructor; typedef __false_type has_trivial_assignment_constructor; typedef __false_type has_trivial_destructor; typedef __false_type is_POD_type;&#125;;/* 原则:** trivial 是不重要的,回答 false. 即有重要的四种基本函数** 保守起见,为所有的类型都设定为重要的构造和拷贝和析构*///特别多的特化__type_traitstypedef template&lt;&gt; __STL_TEMPLATE_NULL;__STL_TEMPLATE_NULL struct __type_traits&lt;char&gt;&#123; //具体萃取 char 类型的元数据 //C语言内置类型 都是以下的回答 typedef __true_type has_trivial_default_constructor; typedef __true_type has_trivial_copy_constructor; typedef __true_type has_trivial_assignment_constructor; typedef __true_type has_trivial_destructor; typedef __true_type is_POD_type;&#125;;//... 许多其他类型的类型萃取特化版本//特别的,指针类型也可以进行萃取template&lt;typename T&gt;struct __type_traits&lt;T*&gt;&#123; typedef __true_type has_trivial_default_constructor; typedef __true_type has_trivial_copy_constructor; typedef __true_type has_trivial_assignment_constructor; typedef __true_type has_trivial_destructor; typedef __true_type is_POD_type;&#125;; __type_traits 实例来源于 侯捷老师 的例子 1234567891011121314151617181920212223242526272829303132333435363738//入口函数template&lt;class ForwardIterator, class Size, class T&gt;inline ForwardIteratoruninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x)&#123; return __uninitialized_fill_n(first, n, x, iterator_traits&lt;ForwardIterator&gt;::value_type);&#125;//萃取“工具人”template&lt;class ForwardIterator, class Size, class T, class T1&gt;inline ForwardIterator__uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x, T1*)&#123; typedef typename type_traits&lt;T1&gt;::is_POD_type is_POD; return __uninitialized_fill_n_aux(first, n, x, is_POD());&#125;//实际上根据 is_POD 属性进行类型推导选择执行以下两个函数中的一个//可以看到,这边如果是用true false来回答的话,这边就无法根据类型推导来选择不同函数了template&lt;class ForwardIterator, class Size, class T&gt;ForwardIterator__uninitialized_fill_n_aux(ForwardIterator first, Size n, const T&amp; x,__false_type)&#123; ForwardIterator cur = first; for( ; n &gt; 0; --n, ++cur) construct(&amp;*cur, x); return cur;&#125;template&lt;class ForwardIterator, class Size, class T&gt;inline ForwardIterator__uninitialized_fill_n_aux(ForwardIterator first, Size n, const T&amp; x,__true_type)&#123; return fill_n(first, n, x);&#125; 融入 STL如果不自己写一个特化版本的话，萃取该自定类型时，萃取结果会认为你的四种函数(构造、拷贝构造、拷贝赋值、析构)都是重要的，但是事实上如果不重要可以提高某一些算法的效率，因此如果真的不重要，就应该在特化版本中告诉编译器。 123456789//比如有一个自定义的 class shapetemplate&lt;&gt;__type_traits&lt;shape&gt;&#123; typedef __true_type has_trivial_default_constructor; typedef __false_type has_trivial_copy_constructor; typedef __false_type has_trivial_assignment_constructor; typedef __false_type has_trivial_destructor; typedef __false_type is_POD_type;&#125;; 学习自侯捷老师：《STL源码剖析》","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"迭代器","slug":"C/STL/迭代器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"iterator","slug":"iterator","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/iterator/"}]},{"title":"理解 iterator_traits","slug":"STL源码剖析/STL-iterator traits","date":"2020-10-30T06:46:00.000Z","updated":"2020-11-03T08:30:49.254Z","comments":true,"path":"2020/10/30/STL源码剖析/STL-iterator traits/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/30/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/STL-iterator%20traits/","excerpt":"","text":"iteratoriterator 意为迭代器，是常见的23种设计模式中的一种。 iterator模式 使该对象能够依序遍历整个容器所含的各个元素，不需要暴露容器的底层实现。 在 STL 的框架里，有六个部分：容器、迭代器、算法、分配器、适配器、仿函数。 其中迭代器是一个有名有姓的重要的组成部分。可以说，迭代器是容器与算法的桥梁或者说是胶水。有了迭代器，使得算法可以不直接作用与特定的容器，使得算法更加地泛化。( OXygen : 算法只需要依据迭代器支持的操作不同而做不同的策略, 而不是针对数量众多的容器, 一一做出不同的操作) 可以看一个示例： 12345678template &lt;class InputIterator, class T&gt; InputIterator find(InputIterator first, InputIterator last, const T&amp; value)&#123; while(first != last &amp;&amp; *first != value) ++first; return first;&#125; 我们只需要提供一组迭代器以及一个代查找的数据就可以实现查找，而不需要让函数知道容器是什么样子。 iterator_traits介绍迭代器用五种类型分别是： Input Iterator (重载 ++) Output Iterator Forward Iterator (重载 ++) Bidirectional Iterator (重载 ++ --) Random Access Iterator (重载 ++ -- +n -n [] - &lt;) 其中有继承关系 : iterator_traits 的代码迭代器的萃取器要为所有迭代器都能够萃取出想要的属性，但是也得为指针和常量指针萃取出想要的属性。因为指针也是一种迭代器，并且是支持随机访问的迭代器(指针可以靠地址偏移随机访问)。 123456789101112131415161718192021222324252627template&lt;class Iterator&gt;struct iterator_traits&#123; typedef typename Iterator::iterator_category iterator_category; typedef typename Iterator::value_type value_type; typedef typename Iterator::difference_type difference_type; typedef typename Iterator::pointer pointer; typedef typename Iterator::reference reference;&#125;;//偏特化template&lt;class T&gt;struct iterator_traits&lt;T*&gt;&#123; typedef typename random_access_iterator_tag iterator_category; typedef typename T value_type; typedef typename ptrdiff_t difference_type; typedef typename T* pointer; typedef typename T&amp; reference; &#125;;template&lt;class T&gt;struct iterator_traits&lt;const T*&gt;&#123; typedef typename random_access_iterator_tag iterator_category; typedef typename T value_type; typedef typename ptrdiff_t difference_type; typedef typename T* pointer; typedef typename T&amp; reference; &#125;; 以上为 iterator_traits 的代码，主要包含一个泛化的版本和两个针对指针和常量指针的版本。 iterator_traits的利用与设计我们有一个针对于元素唯一且有序的容器，实现搜索，提供的是首尾迭代器，那么我们对于不同类型的迭代器就得有不同的实现 ： 针对于 vector queue 容器，迭代器类型为 Random Access Iterator，我们可以使用二分搜索； 针对于 list forward-list 容器，迭代器类型为 Forward Iterator 或 Bidirectional Iterator，我们只能使用迭代来搜索。 因此，我们可以设计两种函数，一种针对于 Random Access Iterator 实现，一种针对于 Input Iterator 实现。(因为继承关系，无法完美匹配 Random Access Iterator 的话，都会去调用 Input Iterator 的版本) 以下代码是自己完成，欢迎讨论，关于页面有我的微信，添加请备注。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//以上方案#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;list&gt;#include &lt;type_traits&gt;using namespace std;/******************************/// 用于判定迭代器的类型属性(iterator_category)template &lt;typename InputIterator&gt;bool is_random_access_iterator(InputIterator iterator)&#123; typedef typename iterator_traits&lt;InputIterator&gt;::iterator_category category; return (typeid(category()) == typeid(random_access_iterator_tag()));&#125;template &lt;typename InputIterator&gt;bool is_input_iterator(InputIterator iterator)&#123; typedef typename iterator_traits&lt;InputIterator&gt;::iterator_category category; return (typeid(category()) == typeid(input_iterator_tag()));&#125;/******************************//******************************/// 内部函数:实现了针对 Random_Access_Iterator 的版本 和 Input_Iterator 的版本template&lt;typename RandomAccessIterator, typename Value&gt;inline RandomAccessIterator mySearch_RI(RandomAccessIterator first, RandomAccessIterator last, Value n)&#123; // 返回找到的迭代器,否则返回 last if(first &gt; last) return last; while(first &lt; last)&#123; RandomAccessIterator mid = first + ((last - first) &gt;&gt; 1); if(*mid &lt; n)&#123; first = mid + 1; &#125;else if(*mid &gt; n)&#123; last = mid; //因为 [first,last) &#125;else&#123; return mid; &#125; &#125; return last;&#125;template&lt;typename InputIterator, typename Value&gt;inline InputIterator mySearch_II(InputIterator first, InputIterator last, Value n)&#123; // 返回找到的迭代器,否则返回 last while(first != last)&#123; if(*first == n) return first; first++; &#125; return last;&#125;/******************************/// 调用函数template&lt;typename InputIterator, typename Value&gt;inline InputIterator mySearch(InputIterator first, InputIterator last, Value n)&#123; if(is_input_iterator(first)) &#123; return mySearch_II(first, last, n); &#125; else if(is_random_access_iterator(first))&#123; return mySearch_RI(first,last,n); &#125;&#125;int main() &#123; //经过测试,链表的调用会出现错误,还不知道具体是什么原因,如果你知道的话,可以联系一下我 vector&lt;int&gt; vec(&#123;1,2,3,4,5,6,7&#125;); vector&lt;int&gt;::iterator it; if((it = mySearch(vec.begin(),vec.end(),5)) != vec.end()) cout &lt;&lt; &quot;找到了元素&quot; &lt;&lt; *it &lt;&lt; &quot;索引值为&quot; &lt;&lt; it - vec.begin() &lt;&lt; endl;// list&lt;int&gt; lst;// lst.push_back(20);// lst.push_back(30);// lst.push_back(15);// list&lt;int&gt;::iterator it2;// if((it2 = mySearch(lst.begin(),lst.end(),15)) != lst.end())// cout &lt;&lt; &quot;找到了元素&quot; &lt;&lt; *it &lt;&lt; endl; return 0;&#125; 但是，这样的代码通过调用函数来判断传入的迭代器是什么类型，无法在编译期内确认，效率不够。因此，采用 iterator_traits 就能提高效率。 123456//&lt;iterator&gt;头文件中包含了标签的继承关系struct input_iterator_tag&#123;&#125;;struct output_iterator_tag&#123;&#125;;struct forward_iterator_tag : public input_iterator_tag&#123;&#125;;struct bidirectional_iterator_tag : public forward_iterator_tag&#123;&#125;;struct random_access_iterator_tag : public bidirectional_iterator_tag&#123;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;list&gt;#include &lt;type_traits&gt;using namespace std;template&lt;typename InputIterator, typename Value&gt;inline InputIterator _mySearch( InputIterator first, InputIterator last, Value n, random_access_iterator_tag ) &#123; // 返回找到的迭代器,否则返回 last if(first &gt; last) return last; while(first &lt; last)&#123; InputIterator mid = first + ((last - first) &gt;&gt; 1); if(*mid &lt; n)&#123; first = mid + 1; &#125;else if(*mid &gt; n)&#123; last = mid; //因为 [first,last) &#125;else&#123; return mid; &#125; &#125; return last;&#125;template&lt;typename InputIterator, typename Value&gt;inline InputIterator _mySearch( InputIterator first, InputIterator last, Value n, input_iterator_tag ) &#123; // 返回找到的迭代器,否则返回 last while(first != last)&#123; if(*first == n) return first; first++; &#125; return last;&#125;// 调用函数template&lt;typename InputIterator, typename Value&gt;inline InputIterator mySearch(InputIterator first, InputIterator last, Value n)&#123; //在这里通过萃取器萃取得到 iterator_category 来选择调用的是哪一个重载函数 return _mySearch(first,last,n,typename iterator_traits&lt;InputIterator&gt;::iterator_category());&#125;int main() &#123; //改成这个版本后,链表的测试也能够通过了,看来还是有一定的机制没有摸透 vector&lt;int&gt; vec(&#123;1,2,3,4,5,6,7&#125;); vector&lt;int&gt;::iterator it; if((it = mySearch(vec.begin(),vec.end(),5)) != vec.end()) cout &lt;&lt; &quot;找到了元素&quot; &lt;&lt; *it &lt;&lt; &quot;索引值为&quot; &lt;&lt; it - vec.begin() &lt;&lt; endl; list&lt;int&gt; lst; lst.push_back(20); lst.push_back(30); lst.push_back(15); list&lt;int&gt;::iterator it2; if((it2 = mySearch(lst.begin(),lst.end(),15)) != lst.end()) cout &lt;&lt; &quot;找到了元素&quot; &lt;&lt; *it2 &lt;&lt; endl; return 0;&#125; 代码调用流程如下： 融入 STL如果想要设计一个迭代器融入到STL中，一定要指明五种类型。方便萃取器能够获得它们。STL提供了一个 iterator 的 class ，当自己设计时只需要继承该类即可： 123456789101112template&lt;class Category, class T, class Distance = ptrdiff_t, class Pointer = T*, class Reference = T&amp;&gt;struct iterator&#123; typedef Category iterator_category; typedef T value_type; typedef Distance difference_type; typedef Pointer pointer; typedef Reference reference;&#125;; 例如： 123template&lt;typename Item&gt;struct ListIter : public std::iterator&lt;std::forward_iterator_tag, Item&gt;&#123; //缺省三个参数,只需要提供前两者&#125; 除设计部分学习自侯捷老师：《STL源码剖析》 设计部分属于自行设计(仍有bug)","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"迭代器","slug":"C/STL/迭代器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"iterator","slug":"iterator","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/iterator/"}]},{"title":"装饰器模式","slug":"设计模式/4.单一职责模式_装饰器","date":"2020-10-29T06:50:00.000Z","updated":"2020-10-28T06:57:26.176Z","comments":true,"path":"2020/10/29/设计模式/4.单一职责模式_装饰器/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F_%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"","text":"装饰器模式 Decorator 动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式 比生成子类（继承）更为灵活（消除重复代码&amp;减少子类个数）—— GoF 本次项目里，原本的代码的一个类的继承关系如下： 其中 Stream 是流的基类，在此之上创建了几个派生类，分别是：FileStream NetworkStream MemoryStream。到这里并没有问题，但是如果要对每一种派生的类做加密或者增加缓存或者其他以后可能会出现的需求时，继续继承派生会使得类的数量特别庞大。 12345678910111213classDiagram Stream &lt;|-- FileStream Stream &lt;|-- NetworkStream Stream &lt;|-- MemoryStream FileStream &lt;|-- CryptoFileStream FileStream &lt;|-- BufferedFileStream FileStream &lt;|-- CryptoBufferedFileStream NetworkStream &lt;|-- CryptoNetworkStream NetworkStream &lt;|-- BufferedNetworkStream NetworkStream &lt;|-- CryptoBufferedNetworkStream MemoryStream &lt;|-- CryptoMemoryStream MemoryStream &lt;|-- BufferedMemoryStream MemoryStream &lt;|-- CryptoBufferedMemoryStream 通过装饰器模式的改进，使得关系图如下： 使得功能扩展继承自一个DecoratorStream的类，该类中组合了一个Stream的类，通过多态性对不同类型的流进行特定的操作，在操作外层套上对应的功能（需求）。 1234567classDiagram Stream &lt;|-- FileStream Stream &lt;|-- NetworkStream Stream &lt;|-- MemoryStream Stream &lt;|-- DecoratorStream DecoratorStream &lt;|-- CyptroStream DecoratorStream &lt;|-- BufferedStream 不好的设计不好的设计原因主要是，在进行功能扩展时，生成了特别多的类和冗余的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//抽象类class Stream &#123;public: virtual char Read(int number) = 0; virtual void Seek(int position) = 0; virtual void Write(char data) = 0; virtual ~Stream() &#123;&#125;;&#125;;//主体类class FileStream : public Stream &#123;public: char Read(int number) override &#123; return 0; &#125; void Seek(int position) override &#123;&#125; void Write(char data) override &#123;&#125;&#125;;class NetworkStream : public Stream &#123;public: char Read(int number) override &#123; return 0; &#125; void Seek(int position) override &#123;&#125; void Write(char data) override &#123;&#125;&#125;;//...还有许多其他继承流抽象的子类//...但是如果涉及到要对子类进行加密增加缓存操作时,十分繁琐//扩展操作_加密class CryptoFileStream : public FileStream &#123;public: virtual char Read(int number) &#123; //额外的加密操作 FileStream::Read(number); //包裹函数 //额外的加密操作 &#125; virtual void Seek(int position) &#123; //额外的加密操作 FileStream::Seek(position); //额外的加密操作 &#125; virtual void Write(char data) &#123; //额外的加密操作 FileStream::Write(data); //额外的加密操作 &#125;&#125;;class CryptoNetworkStream : public NetworkStream &#123;&#125;;//...这里还要对其他流也要做加密操作//拓展操作_缓存class BufferedFileStream : public FileStream &#123;&#125;;class BufferedNetworkStream : public NetworkStream &#123;&#125;;//扩展操作_加密_缓存class CryptoBufferedFileStream : public FileStream &#123;&#125;;class CryptoBufferedNetworkStream : public FileStream &#123;&#125;;//其实,所有流的Read()的加密操作都是相同的,不需要写多份,缓存也是如此void Process()&#123; //编译时装配 CryptoFileStream *fs1 = new CryptoFileStream(); BufferedFileStream *fs2 = new BufferedFileStream(); CryptoBufferedFileStream *fs3 = new CryptoBufferedFileStream();&#125; 装饰器模式只需要为功能扩展组合一个基类，就可以利用多态性来减少大量冗余的代码和子类的数量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//抽象类class Stream &#123;public: virtual char Read(int number) = 0; virtual void Seek(int position) = 0; virtual void Write(char data) = 0; virtual ~Stream() &#123;&#125;;&#125;;//主体类class FileStream : public Stream &#123;public: char Read(int number) override &#123; return 0; &#125; void Seek(int position) override &#123;&#125; void Write(char data) override &#123;&#125;&#125;;class NetworkStream : public Stream &#123;public: char Read(int number) override &#123; return 0; &#125; void Seek(int position) override &#123;&#125; void Write(char data) override &#123;&#125;&#125;;//扩展class DecoratorStream : public Stream&#123; //继承为了完善接口规范protected: Stream *stream; // = new FileStream(); // = new NetworkStream(); // = new MemoryStream(); DecoratorStream(Stream * stream):stream(stream)&#123;&#125;&#125;;class CryptoStream : public DecoratorStream &#123; //加密操作抽象出来,通过多态来给不同的类型流加密 // public Stream 为了接口规范public: CryptoStream(Stream *stream) : DecoratorStream(stream) &#123;&#125; virtual char Read(int number) &#123; //额外的加密操作 stream-&gt;Read(number); //包裹函数 //额外的加密操作 &#125; virtual void Seek(int position) &#123; //额外的加密操作 stream-&gt;Seek(position); //额外的加密操作 &#125; virtual void Write(char data) &#123; //额外的加密操作 stream-&gt;Write(data); //额外的加密操作 &#125;&#125;;class BufferedStream : public DecoratorStream &#123;public: BufferedStream(Stream *stream) : DecoratorStream(stream) &#123;&#125; virtual char Read(int number) &#123; //缓存 stream-&gt;Read(number); &#125; virtual void Seek(int position) &#123; //缓存 stream-&gt;Seek(position); &#125; virtual void Write(char data) &#123; //缓存 stream-&gt;Write(data); &#125;&#125;;void Process() &#123; //运行时装配 FileStream *s1 = new FileStream(); CryptoStream *s2 = new CryptoStream(s1); //加密 BufferedStream *s3 = new BufferedStream(s1); //缓存 BufferedStream *s4 = new BufferedStream(s2); //加密 &amp; 缓存&#125; 要点总结 通过采用组合而非继承的手法，Decorator模式实现了在运行时多态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了所有继承带来的灵活性差和多子类衍生问题。 Decorator类在接口上表现为 is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在是线上又表现为 has-a Component的组合关系，即Decorator类又使用了另外一个Component类。 Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”含义。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《设计模式》","slug":"读书笔记/《设计模式》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"},{"name":"单一职责模式","slug":"读书笔记/《设计模式》/单一职责模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"策略模式","slug":"设计模式/2.组件协作模式_策略模式","date":"2020-10-28T06:38:00.000Z","updated":"2020-10-29T04:53:05.551Z","comments":true,"path":"2020/10/28/设计模式/2.组件协作模式_策略模式/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F_%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模板模式 Strategy 在许多 if-else 写完以后，如果以后还需要在源码上进行扩写条件分支，那么最好可以使用策略模式，以实现运行时多态。 12345678910111213141516171819202122232425classDiagram Context o--|&gt; Strategy Strategy &lt;|-- ConcreteStrategyA Strategy &lt;|-- ConcreteStrategyB Strategy &lt;|-- ConcreteStrategyC class Context&#123; ContextInterface() &#125; class Strategy&#123; AlgorithmInterface() &#125; class ConcreteStrategyA&#123; AlgorithmInterface() &#125; class ConcreteStrategyB&#123; AlgorithmInterface() &#125; class ConcreteStrategyC&#123; AlgorithmInterface() &#125; 定义定义一系列算法，把他们一个个封装起来，并且使他们可互相替换（变化）。该模式使得算法可以独立于使用他们的客户程序（稳定）而变化（扩展，子类化）。 动机在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。 如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？ 不好的设计一旦增加业务，会修改源代码，违反了开闭原则（扩展开放，修改关闭） 12345678910111213141516enum TaxBase&#123; CN_Tax, US_Tax, DE_Tax, FR_Tax //新增&#125;;class SalesOrder&#123; TaxBase tax;public: double CalculateTax()&#123; if( tax == CN_Tax )&#123;...&#125; else if( tax == US_Tax ) &#123;...&#125; else if( tax == DE_Tax ) &#123;...&#125; else if( tax == FR_Tax ) &#123;...&#125; //新增&#125;; 模板模式只需要新增一个子类来继承基类，实现多态调用 1234567891011121314151617181920212223242526272829303132333435363738394041//class TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context) = 0; virtual ~TaxStrategy()&#123;&#125;&#125;;class CNTax : public Taxstrategy &#123;public: virtual double Calculate(const Context&amp; context) &#123;&#125;&#125;;class USTax : public Taxstrategy &#123;public: virtual double Calculate(const Context&amp; context) &#123;&#125;&#125;;class DETax : public Taxstrategy &#123;public: virtual double Calculate(const Context&amp; context) &#123;&#125;&#125;;class FRTax : public Taxstrategy &#123; //新增public: virtual double Calculate(const Context&amp; context) &#123;&#125;&#125;;class SalesOrder&#123;private: TaxStrategy * strategy;public: SalesOrder(StrategyFactory* strategyfactory)&#123; this-&gt;strategy = strategyfactory-&gt;NewStrategy(); //工厂模式 &#125; ~SalesOrder()&#123; delete this-&gt;strategy; &#125; double CalculateTex()&#123; Context context(); double val = strategy-&gt;Calculate(context); //多态调用&#125;;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《设计模式》","slug":"读书笔记/《设计模式》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"},{"name":"组件协作模式","slug":"读书笔记/《设计模式》/组件协作模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"模板模式","slug":"设计模式/1.组件协作模式_模板模式","date":"2020-10-27T14:30:00.000Z","updated":"2020-10-28T06:53:45.450Z","comments":true,"path":"2020/10/27/设计模式/1.组件协作模式_模板模式/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F_%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"组件协作模式介绍现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。 动机在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但是各个子步骤却又很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？ 模板模式 Template Method不好的设计12345678910111213141516171819202122232425262728293031//程序库开发class Library&#123;public: void step1()&#123;...&#125; void step3()&#123;...&#125; void step5()&#123;...&#125;&#125;;//应用开发class Application&#123;public: bool step2()&#123;...&#125; bool step5()&#123;...&#125;&#125;;int main()&#123; Library lib; Application app; //逻辑部分 lib.step1(); if(app.step2())&#123; lib.step3(); &#125; for(int i=0;i&lt;4;++i)&#123; app.step4(); &#125; lib.step5(); return 0;&#125; 如此编码的话，做应用开发的程序员压力会很大，还需要完成逻辑部分。 模板模式12345678910111213141516171819202122232425262728293031323334//程序库开发class Library&#123;public: void run()&#123; //稳定 step1(); if(step2())&#123; step3(); &#125; for(int i=0;i&lt;4;++i)&#123; step4(); &#125; step5(); &#125; virtual ~Library()&#123;&#125;protected: void step1()&#123;...&#125; //稳定 void step3()&#123;...&#125; //稳定 void step5()&#123;...&#125; //稳定 virtual bool step2() = 0; //变化 virtual bool step4() = 0; //变化&#125;;//应用开发class Application : public Library&#123;protected: virtual bool step2()&#123;&#125; //重写 virtual bool step4()&#123;&#125; //重写 &#125;;int main()&#123; Library * plib = new Application(); plib-&gt;run(); delete plib;&#125; 如此编码，通过继承实现运行时多态，把逻辑部分封装在父类中。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《设计模式》","slug":"读书笔记/《设计模式》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"},{"name":"组件协作模式","slug":"读书笔记/《设计模式》/组件协作模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式初探","slug":"设计模式/0.设计模式","date":"2020-10-27T13:00:00.000Z","updated":"2020-10-27T13:06:50.610Z","comments":true,"path":"2020/10/27/设计模式/0.设计模式/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式课程 base 李建忠 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。—- Christopher Alexand 课程目标 理解松耦合设计思想 掌握面向对象设计原则 掌握重构技巧法改善设计 掌握GOF核心设计模式 书籍推荐《设计模式：可复用面向对象软件的基础》 程序编码属于底层思维 设计属于抽象思维 如何解决复杂性 分解 抽象 哲学层面 面向对象设计原则对象是什么？语言层面：对象封装了代码和数据 规格层面：对象是一系列可被使用的公共接口 概念层面：对象是某种拥有责任的抽象 八大设计原则 依赖倒置原则(DIP) 高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。 例如： 1234567mainForm -&gt; Line / Rect绘画类是高层的模块，但是线条或者矩形类是低层的模块，可能会有修改或者增加。因此不够稳定---&gt;mainForm -&gt; Shape(Abstruct) &lt;- [ Line / Rect ] // [] 隔离变化Shape是抽象类, mainForm 和 Shape 都不需要变化, 只需要修改增加对Shape的依赖类 开放封闭原则(OCP) 对扩展开放，对更改关闭。 类模块应该是可扩展的，但是不可修改。 1增加新的功能时，考虑增加而不是修改 单一职责原则(SRP) 一个类应该仅有一个引起它变化的原因。 变化的方向隐含着类的责任。 Liskov 替换原则(LSP) 子类必须能够替换他们的基类(IS-A)。 继承表达类型抽象。 接口隔离原则(ISP) 不应该强迫客户程序依赖它们不用的方法。 接口应该小而完备。 优先使用对象组合，而不是类继承 类继承通常为”白箱复用”，对象组合通常为“黑箱复用”。 继承在某种程度上破坏了封装线，子类父类耦合度高。 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。 封装变化点 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。 针对接口编程，而不是针对实现编程 不将变量类型声明为某个特定的具体类，而是声明为某个接口。 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。 减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案。 将设计原则提升为设计经验 设计习语 Design Idioms 描述与特定编程语言相关的低层模式，技巧惯用法。 设计模式 Design Patterns 描述的是“类与相互通信的对象之间的组织关系”，包括他们的角色，职责，协作方式等方面。 架构模式 Architectural Patterns 描述系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们之间的关系规则。 GOF-23模式 按照范围分类 类模式处理类与子类的静态关系 对象模式处理对象间的动态关系 按照目的分类 创建型 结构型 行为型 老师提出的分类方式 组件协作 Template Method Strategy Observer / Event 单一职责 Decorator Bridge 对象创建 Factory Method Abstract Factory Prototype Builder 对象性能 Singleton Flyweight 接口隔离 Facade Proxy Mediator Adapter 状态变化 Memento State 数据结构 Composite Iterator Chain of Resposibility 行为变化 Command Visitor 领域问题 Interpreter 重构静态 → 动态 早绑定 → 晚绑定 继承 → 组合 编译时依赖 → 运行时依赖 紧耦合 → 松耦合","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《设计模式》","slug":"读书笔记/《设计模式》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"chapter 8 异常控制流","slug":"OperatingSystem/深入理解计算机系统/第八章 异常控制流","date":"2020-10-27T12:40:00.000Z","updated":"2020-10-29T12:35:32.360Z","comments":true,"path":"2020/10/27/OperatingSystem/深入理解计算机系统/第八章 异常控制流/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/27/OperatingSystem/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/","excerpt":"","text":"异常控制流异常控制流(ECF : Exceptional Control Flow) ，是操作系统实现 I/O、进程、并发和虚拟内存的基本机制。 异常异常的知识异常 是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。 在处理器中，状态被编码为不同的位和信号，状态变化称为 事件(event) 。 在任何情况下，当处理器检测到事件的发生，它会通过一张叫做 异常表(exception table) 的跳转表，进行一个间接过程的调用(异常)，到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序)。 发生异常后，会发生以下三种情况中的一种： 处理程序将控制返回给当前指令 I_curr 处理程序将控制返回给下个指令 I_next 处理程序终止被中断的程序 系统为每一种异常都分配了唯一的非负整数的异常号。 一部分由处理器的设计者分配(x86-64 : 0-31)：被零除、缺页、内存访问违例、断点、算术运算溢出 一部分由操作系统内核的设计者分配(x86-64 : 32-255)：系统调用和来自外部的 IO 设备的信号 异常的分类 中断 收到中断信号→先执行完当前指令→执行中断处理程序→执行下一条指令 陷阱 系统调用，有一些指令只有内核模式才能调用。需要程序从用户模式陷入内核，才能进行调用。陷入内核的唯一方式：通过中断、故障或者陷入系统调用这样的异常 故障 经典示例：缺页异常。当指令引用了一个虚拟地址，与该地址相对应的物理页面不在内存中时，因此必须从磁盘中取出，所以发生了故障。因此，解决故障之后，返回到原来的指令重新执行。 终止 通常是硬件错误。 异常类型 原因 异步/同步 返回行为 中断 来自IO设备的信号 异步 总是返回下一条指令 陷阱 有意的异常 同步 总是返回下一条指令 故障 潜在可恢复的错误 同步 总是返回当前指令 终止 不可恢复的错误 同步 不会返回 进程 异常是允许操作系统内核提供进程概念的基本构造块。 进程 是一个执行中的程序的实例。系统中的每个程序都运行在某一个进程的上下文中。 上下文 由程序正确运行所需的状态组成。包括：内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 一个逻辑流的执行在时间上与另一个流重叠，称为并行流。多个流并发地执行，称为 并发 。 两个流并发地运行在 不同的处理器核或计算机上 ，称为 并行 流。并行是并发的真子集。 一个进程和其他进程轮流运行，称为 多任务 。一个进程执行它的控制流的一部分的每一时间段叫做 时间片 。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，称为 调度 。由内核的调度器的代码处理。 上下文切换 保存当前进程的上下文； 恢复某个先前被抢占的进程被保存的上下文； 将控制权传递给这个新恢复的进程。 函数fork()waitpid()execve()execve() 函数的目的是在一个程序中打开另一个程序，如果成功就不再返回，如果失败返回 -1。 以下为一个示例： 1234567891011121314151617181920212223//file : main.cppint main()&#123;char filename[] = &quot;test&quot;; char *argv[] = &#123;&quot;./&quot;,NULL&#125;; if(execve(filename, argv,NULL) == -1)&#123; cout &lt;&lt; &quot;execve error&quot; &lt;&lt;endl; exit(EXIT_FAILURE); &#125; puts(&quot;shouldn&#x27;t get here&quot;); exit(EXIT_SUCCESS); return 0;&#125;//file : test.cpp#include &lt;iostream&gt;using namespace std;int main()&#123; std::cout &lt;&lt; &quot;调用成功&quot; &lt;&lt; std::endl; return 0;&#125; 1234&gt; g++ -o test.cpp test&gt; g++ -o amin.cpp main&gt; ./main&gt; 调用成功 信号函数signal()singal() 函数可以修改进程接收信号的行为，但是无法修改接收到 SIGSTOP 和 SIGKILL 的行为。 以下是具体用法： 123456789101112#include&lt;signal&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler);/*** 如果 handler 是 SIG_IGN, 忽略 signum 信号** 如果 handler 是 SIG_DFL, 恢复 signum 信号为默认行为** 否则,handler 指向用户自定程序: 改变了默认行为 设置信号处理程序 调用信号处理程序 捕获信号 执行信号处理程序 处理信号*/","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《深入理解计算机系统》","slug":"读书笔记/《深入理解计算机系统》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"},{"name":"第八章 异常控制流","slug":"读书笔记/《深入理解计算机系统》/第八章-异常控制流","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"类似于vector的数据结构实现","slug":"STL源码剖析/STL-vector 的实现","date":"2020-10-26T11:30:00.000Z","updated":"2020-10-26T11:35:55.869Z","comments":true,"path":"2020/10/26/STL源码剖析/STL-vector 的实现/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/26/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/STL-vector%20%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"类似于vector的数据结构实现预期实现的功能 可以对内置类型以及自定义数据类型进行存储 将数组中的数据存储到堆区 构造函数 空构造 传入容量 传入容量和初始化值 提供对应的拷贝构造函数和拷贝赋值函数防止浅拷贝 提供尾插法核尾删法 可以通过下标访问数组元素 可以获取当前的容量和大小 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110template &lt;typename _Tp&gt;class MyArray&#123; typedef _Tp ValueType; private: int _size; //大小 int _capacity; //容量 ValueType *address; //管理地址 //实际上vector是管理的三个迭代器public: // 构造函数 MyArray()&#123; //全部初始化为0 _size = 0; _capacity = 0; address = nullptr; &#125; MyArray(int capacity)&#123; //容量设置好以及分配好对应的堆内存 _size = 0; _capacity = capacity; address = new ValueType[capacity]; &#125; MyArray(int capacity,ValueType val)&#123; //容量和大小都设置好,以及分配对应的堆内存并进行初始化 _size = capacity; _capacity = capacity; address = new ValueType[capacity]; for (int i = 0; i &lt; capacity; ++i) &#123; *(address + i) = val; &#125; &#125; //拷贝构造 MyArray(const MyArray &amp;arr) &#123; this-&gt;_size = arr._size; this-&gt;_capacity = arr._capacity; this-&gt;address = new ValueType[this-&gt;_capacity]; //深拷贝 &#125; //拷贝赋值 MyArray &amp; operator=(const MyArray &amp; arr)&#123; //检查原本是否存在管理的内存 if(this-&gt;address != nullptr)&#123; this-&gt;_capacity = 0; this-&gt;_size = 0; delete [] this-&gt;address; this-&gt;address = nullptr; &#125; this-&gt;_size = arr._size; this-&gt;_capacity = arr._capacity; this-&gt;address = new ValueType[this-&gt;_capacity]; //深拷贝 for (int i = 0; i &lt; this-&gt;_size; ++i) &#123; this-&gt;address[i] = arr.address[i]; &#125; &#125; //析构函数 ~MyArray() &#123; if(address != nullptr) &#123; delete[] address; this-&gt;address = nullptr; &#125; &#125; //取值 int size()&#123; return _size; &#125; int capacity()&#123; return _capacity; &#125; //[]重载 ValueType &amp; operator[](int n)&#123; //可以作为左值 return this-&gt;address[n]; &#125; void adjust_capacity(const ValueType &amp; obj)&#123; //内存扩容 if(_capacity == _size)&#123; //申请2倍内存释放原本内存进行拷贝 std::cout &lt;&lt; &quot;调整&quot; &lt;&lt; std::endl; _capacity = _capacity == 0 ? 1 : 2 * _capacity; ValueType * new_address = new ValueType[_capacity]; // 放入当前尾部插入的元素 还没有考虑 vector.insert() new_address[_size] = obj; _size ++; delete [] address; address = new_address; &#125; return; &#125; //尾插尾删 void push_back(const ValueType &amp; obj)&#123; if(_capacity == _size)&#123; adjust_capacity(obj); return; &#125; this-&gt;address[_size] = obj; this-&gt;_size++; &#125; void pop_back()&#123; if(_size == 0)&#123; return; &#125; this-&gt;_size --; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"容器","slug":"C/STL/容器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"vector","slug":"vector","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/vector/"}]},{"title":"TCP通信[未完成]","slug":"网络/计算机网络-TCP","date":"2020-10-26T05:25:00.000Z","updated":"2020-10-30T03:08:01.551Z","comments":true,"path":"2020/10/26/网络/计算机网络-TCP/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/26/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/","excerpt":"","text":"简介传输控制协议( TCP : Transmission Control Protocol )，是一种面向连接的，可靠的传输层控制协议。 面向连接一般，客户端发送给服务端的一个数据包携带的数据最大为1460字节。是因为，以太网帧结构数据长度是1500字节，其中包含20字节的IP头部以及20字节的TCP头部，所以数据能够携带1460字节。 三次握手三次握手，由内核完成。反应在程序中，是由客户端程序的 connect() 开始，由 服务端程序的 accept() 返回结束。 示例 123456789客户端发送：SYN 1000(0) win 4096 &lt;mss 1460&gt;服务端发送：SYN 8000(0) win 6144 ACK 1001 &lt;mss 1024&gt; //ACK 1001 是接收到的序号+数据字节(SYN标志位也得占1字节)客户端发送：ACK 8001 win 4096 /*** (0) : 表示携带数据为0字节** win 4096 : 发送端滑动窗口缓存4096字节** &lt;mss 1460&gt; : 表示携带数据最大字节数为1460字节*/ 总结 123主动发起连接请求端：发送SYN标志位，请求建立连接。携带数据包包号，数据字节数(0)，滑动窗口大小被动接受连接请求端：发送ACK标志位，同时携带SYN请求标志位。携带序号，确认序号，数据字节数(0)，滑动窗口大小主动发起连接请求段：发送ACK标志位，应答服务器连接请求。携带确认序号。 要点 为什么不是二次握手？ 彼此确定收发能力 第一次客户端发送请求，服务端接收请求：服务端知道了客户端有发送的能力。 第二次服务端发送请求，客户端接收请求：客户端知道了服务端有收发的能力。 此时，服务端不知道客户端是不是有接收的能力。因此需要客户端再次告知服务端。 避免两次连接 客户端发送的连接请求如果滞留在网络中，等到超时重传，会再次发起连接请求，而服务器接收到两个连接请求会打开两个连接。因此，需要三次握手。 第三次客户端发送ACK时，可以携带数据 因为此时，客户端服务端都知道双方都有收发数据的能力，所以可以开始通信。 四次挥手四次挥手，目的是断开客户端到服务端的全双工链路。断开一端称为半关闭，会关闭一端的套接字的一个缓存区。 示例 1234客户端发送：FIN 501(0) ACK 701 服务端发送：ACK 502 ---- 半关闭服务端发送：FIN 701(0) ACK 502客户端发送：ACK 702 ---- 完全断开 总结 1234主动关闭连接请求端：发送FIN标志位。被动关闭连接请求端：应答ACK标志位。 ———— 半关闭完成被动关闭连接请求端：发送FIN标志位。主动关闭连接请求端：应答ACK标志位。 —————连接全部关闭 客户端接收到服务器的应答之后，进入半关闭状态，不能发送数据给服务器，而服务器会在发送完剩余数据后，发起关闭请求，客户端应答服务器后需要等待 2MSL(最大报文存活时间)后释放连接。原因如下： 如果客户端的应答数据包丢失，那么服务器会再次发送断开请求。 等待一段时间，使本次连接过程中产生的数据包在网络中消失。 可靠传输超时重传TCP使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送到接收到确定所经历的时间称为往返时间RTT(加权平均RTTs)。超时时间 RTO 应该略大于 RTTs 。TCP使用的超时时间计算是 : RTO = RTTs + 4 * RTTd 。RTTd : 偏差的加权平均值。 滑动窗口滑动窗口是一个缓存区，用于暂时存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其他信息来设置自己的窗口大小。 对于发送方来说，当窗口靠左侧的数据包已经成功发送并被确认后，窗口向右滑动直到某一个未发送或者未确认的字节位置。 对于接收方来说，当窗口靠左侧的数据包已经收到，窗口向右滑动直到某一个未接收到的字节。 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 拥塞控制如果网络出现拥塞，发送方发送的数据包丢失，发送方重传导致网络难以恢复。因此要进行一定的拥塞控制使得发送方降低发送速率。发送方需要维护一个拥塞窗口（cwnd）状态变量：决定发送方能发送多少数据。 慢开始与拥塞避免 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 快速重传与快速恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。","categories":[{"name":"网络通信","slug":"网络通信","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"传输层","slug":"网络通信/传输层","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"name":"TCP","slug":"网络通信/传输层/TCP","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP/"}],"tags":[{"name":"tcp","slug":"tcp","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/tcp/"}]},{"title":"剑指 Offer 09. 用两个栈实现队列","slug":"leetcode/剑指offer/剑指Offer 09","date":"2020-10-19T10:09:00.000Z","updated":"2020-10-19T10:16:58.300Z","comments":true,"path":"2020/10/19/leetcode/剑指offer/剑指Offer 09/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/19/leetcode/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87Offer%2009/","excerpt":"","text":"剑指 Offer 09. 用两个栈实现队列题目描述剑指 Offer 09. 用两个栈实现队列 难度:中等 描述 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1234567891011121314输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1]输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 限制：1 &lt;= values &lt;= 10000最多会对 appendTail、deleteHead 进行 10000 次调用 1234567API设计 :class CQueue &#123;public: CQueue() &#123;&#125; void appendTail(int value) &#123;&#125; int deleteHead() &#123;&#125;&#125;; 解法因为栈这一种线性结构的特性是后进先出，而队列这一种线性结构的特性是先进先出，它使用两个栈就可以通过两次后进先出实现我们想要的先进先出的特性。 123456789101112131415161718192021222324252627class CQueue &#123;private: stack&lt;int&gt; s_in; // 数据先经过 s_in 栈 stack&lt;int&gt; s_out; // 再经过 s_out 出栈public: CQueue() &#123;&#125; void appendTail(int value) &#123; s_in.push(value); &#125; int deleteHead() &#123; if(s_in.empty() &amp;&amp; s_out.empty()) //都空说明没有元素 return -1; else if(s_out.empty())&#123; // s_out 空 s_in 不空 while(!s_in.empty())&#123; //全部转移 s_out.push(s_in.top()); s_in.pop(); &#125; &#125; // 经过 s_out 出栈 int ans = s_out.top(); s_out.pop(); return ans; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"}]},{"title":"前缀/中缀/后缀表达式的转换/计算/构建二叉树[未完成]","slug":"编程技巧/前缀中缀后缀表达式转换求值","date":"2020-10-18T14:51:00.000Z","updated":"2020-11-11T05:02:11.185Z","comments":true,"path":"2020/10/18/编程技巧/前缀中缀后缀表达式转换求值/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/18/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/%E5%89%8D%E7%BC%80%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%B1%82%E5%80%BC/","excerpt":"","text":"简介 我们从小学至今，接触到最多的表达式就是中缀表达式，形如 : (5+(3*2)-6/2) 作用的运算符落在数字两边。但是这一个表达式作为字符串输入到计算机中，计算机可不太喜欢这样的表达式，它顺序遍历的时候，由于运算符优先级不同，难以计算。因此，出现了前缀表达式和后缀表达式，他们两者的特点是不携带括号，顺序遍历时，明确了运算的优先级。前缀和后缀表达式都可以由中缀表达式转换而来。 本篇文章会带你学习如何把中缀表达式转换成前缀 / 后缀表达式，如果根据前缀 / 后缀表达式计算表达式的值，最后由表达式来构建出一棵表达式二叉树。 概念前缀表达式前缀表达式是一种没有括号的算术表达式，与中缀表达式不同的是，其将运算符写在前面，操作数写在后面。 为纪念其发明者波兰数学家Jan Lukasiewicz，前缀表达式也称为“波兰式”。 例如，- 1 + 2 3，它等价于1 - (2 + 3)。 中缀表达式中缀表达式是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间。 例如：3 + 4。 后缀表达式后缀表达式与前缀表达式类似的是一种没有括号的算术表达式，不同的是运算符写在后面，操作数写在前面。 后缀表达式也称为“逆波兰式”。 例如+ 2 3，它等价于 2 + 3。 表达式二叉树算数表达式是分层的递归结构，一个运算符作用于相应的运算对象，其运算对象又可以是任意复杂的表达式。树的递归结构正好用来表示这种表达式。下面只讨论二元表达式。二元表达式可以很自然的联系到二叉树：以基本运算对象作为叶节点中的数据；以运算符作为非叶节点中的数据，其两棵子树是它的运算对象，子树可以是基本运算对象，也可以是复杂表达式。如图是一个表达式树。 留意一下颜色和遍历顺序和表达式类型的对应关系。 表达式树的先序遍历：前缀表达式 表达式树的中序遍历：中缀表达式 表达式树的后序遍历：后缀表达式 运算数 ：是二叉树的叶子节点 运算符：是二叉树的非叶子节点 转换中缀表达式转前缀表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vector&lt;string&gt; prefix(const vector&lt;string&gt; &amp; mid_str)&#123; /* * 中缀表达式转换成前缀表达式 * 采用 vector &lt; string &gt; 的存储方式存储 * 运算符占用一字符串, 多位整数占用一字符串 */ vector&lt;string&gt; pre; stack&lt;string&gt; op; stack&lt;string&gt; tmp; // 用于最后转置所有字符串顺序 map&lt;string,int&gt; priority; priority[&quot;+&quot;] = 0; priority[&quot;-&quot;] = 0; priority[&quot;*&quot;] = 1; priority[&quot;/&quot;] = 1; for(int i = mid_str.size() - 1 ; i &gt;= 0 ; i -- )&#123; if(isdigit(mid_str[i][0]) || isalpha(mid_str[i][0]))&#123; tmp.push(mid_str[i]); &#125; else if (mid_str[i] == &quot;)&quot;)&#123; op.push(&quot;)&quot;); &#125; else if(mid_str[i] == &quot;(&quot;)&#123; while(op.top() != &quot;)&quot;)&#123; tmp.push(op.top()); op.pop(); &#125; op.pop(); //弹出 &quot;)&quot; &#125; else if (mid_str[i] == &quot;+&quot; || mid_str[i] == &quot;-&quot; || mid_str[i] == &quot;*&quot; || mid_str[i] == &quot;/&quot;) &#123; while(!op.empty() &amp;&amp; op.top() != &quot;)&quot; &amp;&amp; priority[mid_str[i]] &lt;= priority[op.top()])&#123; tmp.push(op.top()); op.pop(); &#125; op.push(mid_str[i]); &#125; &#125; while(!op.empty())&#123; tmp.push(op.top()); op.pop(); &#125; while(!tmp.empty())&#123; pre.push_back(tmp.top()); tmp.pop(); &#125; return pre;&#125; 中缀表达式转后缀表达式1234567891011121314151617181920212223242526272829303132333435363738394041vector&lt;string&gt; postfix(const vector&lt;string&gt; &amp;mid_str) &#123; /* * 中缀表达式转换成后缀表达式 * 采用 vector &lt; string &gt; 的存储方式存储 * 运算符占用一字符串, 多位整数占用一字符串 */ vector&lt;string&gt;post; stack&lt;string&gt; op; map&lt;string,int&gt; priority; priority[&quot;+&quot;] = 0; priority[&quot;-&quot;] = 0; priority[&quot;*&quot;] = 1; priority[&quot;/&quot;] = 1; for (int i = 0; i &lt; mid_str.size(); ++i) &#123; if(isdigit(mid_str[i][0]) || isalpha(mid_str[i][0]))&#123; post.push_back(mid_str[i]); &#125; else if (mid_str[i] == &quot;(&quot;)&#123; op.push(&quot;(&quot;); &#125; else if(mid_str[i] == &quot;)&quot;)&#123; while(op.top() != &quot;(&quot;)&#123; post.push_back(op.top()); op.pop(); &#125; op.pop(); //弹出 &quot;(&quot; &#125; else if (mid_str[i] == &quot;+&quot; || mid_str[i] == &quot;-&quot; || mid_str[i] == &quot;*&quot; || mid_str[i] == &quot;/&quot;) &#123; while(!op.empty() &amp;&amp; op.top() != &quot;(&quot; &amp;&amp; priority[mid_str[i]] &lt;= priority[op.top()])&#123; post.push_back(op.top()); op.pop(); &#125; op.push(mid_str[i]); &#125; &#125; while(!op.empty())&#123; post.push_back(op.top()); op.pop(); &#125; return post;&#125; 测试部分1234567// vector&lt;string&gt; mid(&#123;&quot;2&quot;,&quot;+&quot;,&quot;9&quot;,&quot;/&quot;,&quot;3&quot;,&quot;-&quot;,&quot;5&quot;&#125;); // 2 + 9 / 3 - 5// vector&lt;string&gt; mid(&#123;&quot;a&quot;,&quot;*&quot;,&quot;(&quot;,&quot;b&quot;,&quot;+&quot;,&quot;c&quot;,&quot;)&quot;,&quot;/&quot;,&quot;d&quot;&#125;); // a * (b + c) / d// vector&lt;string&gt; mid(&#123;&quot;2&quot;,&quot;*&quot;,&quot;(&quot;,&quot;9&quot;,&quot;+&quot;,&quot;6&quot;,&quot;/&quot;,&quot;3&quot;,&quot;-&quot;,&quot;5&quot;,&quot;)&quot;,&quot;+&quot;,&quot;4&quot;&#125;); // 2 * (9 + 6 / 3 - 5) + 4// vector&lt;string&gt; mid(&#123;&quot;a&quot;,&quot;+&quot;,&quot;b&quot;,&quot;*&quot;,&quot;c&quot;,&quot;-&quot;,&quot;(&quot;,&quot;d&quot;,&quot;+&quot;,&quot;e&quot;,&quot;)&quot;&#125;); // a + b * c - (d + e) vector&lt;string&gt; mid(&#123;&quot;(&quot;,&quot;3&quot;,&quot;+&quot;,&quot;4&quot;,&quot;)&quot;,&quot;*&quot;,&quot;5&quot;,&quot;-&quot;,&quot;6&quot;&#125;); //(3 + 4) * 5 - 6 vector&lt;string&gt; post = postfix(mid); vector&lt;string&gt; pre = prefix(mid); 计算前缀表达式计算后缀表达式计算后缀表达式求值 构建二叉树前缀和中缀表达式构建二叉树后缀和中缀表达式构建二叉树","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"数据结构/栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%A0%88/"}]},{"title":"剑指 Offer 07. 重建二叉树","slug":"leetcode/剑指offer/剑指Offer 07","date":"2020-10-16T08:24:31.000Z","updated":"2020-10-18T07:54:45.362Z","comments":true,"path":"2020/10/16/leetcode/剑指offer/剑指Offer 07/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/16/leetcode/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87Offer%2007/","excerpt":"","text":"剑指 Offer 07. 重建二叉树题目描述剑指 Offer 07. 重建二叉树 难度:中等 描述 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 示例 123456例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 限制：0 &lt;= 节点个数 &lt;= 5000 返回如下的二叉树： 12函数签名:TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder); 思路事实上，我们通过遍历顺序还原二叉树，必须知道中序遍历以及前序后序中的一种，就可以还原出唯一的一棵二叉树。这一道题目是前序和中序还原二叉树，leetcode中也有中序和后序还原二叉树，解法其实是类似的。 106. 从中序与后序遍历序列构造二叉树 还原思路主要是依据前序和中序顺序的特点。 前序的第一个节点一定是树的根节点； 中序中根节点的左侧为左子树节点，右侧为右子树节点； 前序中除去根节点以外，左子树的节点集中在左边，右子树的节点集中在右边； 对于每一颗子树来说，也满足以上两个特点。 解法1234567891011121314151617181920TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; //函数签名不支持我们方便的书写递归,因此再构建一个函数 return build(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);&#125;TreeNode* build(vector&lt;int&gt;&amp; preorder, int pbegin, int pend, vector&lt;int&gt;&amp; inorder, int ibegin, int iend)&#123; if(pbegin &gt; pend) //剪枝条件 return nullptr; int midnum = preorder[pbegin]; //特点1:前序第一个节点是根节点 int index = 0; for(int i=ibegin;i&lt;=iend;++i) if(inorder[i] == midnum) //利用特点2之前需要找到中序中的根节点 index = i; int leftsize = index - ibegin; // 找到左子树的节点数 TreeNode * node = new TreeNode(midnum); node-&gt;left = build(preorder,pbegin+1,pbegin+leftsize,inorder,ibegin,index-1); //构建左子树 node-&gt;right = build(preorder,pbegin+leftsize+1,pend,inorder,index+1,iend); //构建右子树 return node;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"中等","slug":"中等","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%B8%AD%E7%AD%89/"}]},{"title":"剑指 Offer 06. 从尾到头打印链表","slug":"leetcode/剑指offer/剑指Offer 06","date":"2020-10-14T07:47:31.000Z","updated":"2020-10-14T08:05:45.220Z","comments":true,"path":"2020/10/14/leetcode/剑指offer/剑指Offer 06/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/14/leetcode/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87Offer%2006/","excerpt":"","text":"剑指 Offer 06. 从尾到头打印链表题目描述剑指 Offer 06. 从尾到头打印链表 难度:简单 描述 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 12345678输入： head = [1,3,2]输出： [2,3,1]限制:0 &lt;= 链表长度 &lt;= 10000函数签名:vector&lt;int&gt; reversePrint(ListNode* head); 解法一第一种思路栈。 我们看到了 反过来 这几个字眼，心里应该要知道这个地方可以借助一个辅助栈来完成。栈这一种数据结构的特性是先进后出，那么原本是1-2-3-4-5 的序列，经过 入栈 和 出栈 的操作之后，就变成了 5-4-3-2-1 的序列。 那么来看这一个题目，一个链表遍历的方法是迭代遍历而不是地址偏移的随机访问遍历，因此我们在遍历过程中把节点的值放入一个辅助栈中，当链表遍历完成后，再将辅助栈的数值给赋值到一个数组中返回。 1234567891011121314151617vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; res; //结果 stack&lt;int&gt; s; //辅助栈 if(!head) return res; ListNode* cur = head; //尽量不破坏传入的指针 while(cur)&#123; //正序遍历链表,将值入栈 s.push(cur-&gt;val); cur = cur-&gt;next; &#125; while(!s.empty())&#123; //将值出栈 res.push_back(s.top()); s.pop(); &#125; return res;&#125; 因为我们只需要遍历一次链表和访问N次栈，而空间需要一个返回的vector&lt;int&gt;的结果和一个辅助栈。 因此，时间复杂度 : O(N) 空间复杂度 : O(N) 。 解法一·改进仍然是解法一的思路。 我们可以不需要一个栈，而是反转数组。 123456789101112vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; res; //结果 if(!head) return res; ListNode* cur = head; while(cur)&#123; //正序遍历链表,直接加入到数组中 res.push_back(cur-&gt;val); cur = cur-&gt;next; &#125; //用反向迭代器创建一个vector&lt;int&gt;对象 return vector&lt;int&gt;(res.rbegin(),res.rend());&#125; 12345678910//这里偷懒使用了反向迭代器//也可以使用双指针原地反转数组int left = 0, right = res.size() - 1;while(left &lt; right)&#123; int tmp = res[left]; res[left] = res[right]; res[right] = tmp; left ++; right --;&#125; 时间复杂度 : O(N) 空间复杂度 : O(N) 。 解法二第二种思路是利用链表和数组的迭代次数与索引的关系。 我们可以想到，链表的迭代次数和数组的索引值是有一定关系的：迭代次数 + 索引值 = 链表长度 - 1 1234567891011121314151617181920vector&lt;int&gt; reversePrint(ListNode* head) &#123; if(!head) return &#123;&#125;; int count = 0; ListNode* cur = head; while(cur)&#123; //遍历计数链表长度 count ++; cur = cur-&gt;next; &#125; vector&lt;int&gt; res(count); //创建链表长度的数组 int index = count - 1; cur = head; while(cur)&#123; //利用关系 res[index--] = cur-&gt;val; cur = cur-&gt;next; &#125; return res;&#125; 这里第11行，vector&lt;int&gt; res(count); 是必须的。如果没有使用传入一个整型值来确定res的构造函数来构造对象的话，res.size() 和 res.capacity() 都会是0，因此无法使用例如res[8]这样的方式去存取数值。如果没有了解过这一方面的知识，可以看我之前的一篇文章：浅析STL中vector容器的用法/特性/实现。 时间复杂度 : O(N) , 空间复杂度 : O(N)。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"简单","slug":"简单","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"链表","slug":"链表","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指 Offer 05. 替换空格","slug":"leetcode/剑指offer/剑指 Offer 05. 替换空格","date":"2020-10-12T12:56:00.000Z","updated":"2020-10-14T07:18:23.239Z","comments":true,"path":"2020/10/12/leetcode/剑指offer/剑指 Offer 05. 替换空格/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/12/leetcode/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","excerpt":"","text":"剑指 Offer 05. 替换空格题目描述剑指 Offer 05. 替换空格 难度:简单 描述 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 现有矩阵 matrix 如下： 12345678输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 限制：0 &lt;= s 的长度 &lt;= 10000函数签名:string replaceSpace(string s) 解法一第一种思路是创建一个新的空字符串，遍历原字符串，判断当前字符是否是空格，如果是空格，新串 += &quot;%20&quot; 如果不是空格，新串加 += 当前字符 代码过于简单，就不展示啦。 时间复杂度 : O(N) 空间复杂度 : O(N) 。 解法二第二种思路是原地调整字符串大小，直接将&quot;%20&quot;加入到原字符串中。 我们需要遍历一次数组，统计空格字符出现的次数，那么调整后的字符串大小应该等于old_size + 2*space_num 。 123456789101112131415161718192021222324252627string replaceSpace(string s) &#123; int space_num = 0; int size_old = s.size(); //旧串大小 for(char c:s) if(isspace(c)) space_num++; int size_new = size_old + 2 * space_num; //新串大小 s.resize(size_new); int i = size_new-1; int j = size_old-1; while(i != j)&#123; //如果 i==j,说明再前面的字符串子串里不存在空格字符,剪枝操作 if(isspace(s[j]))&#123; s[i] = &#x27;0&#x27;; s[i-1] = &#x27;2&#x27;; s[i-2] = &#x27;%&#x27;; i -= 3; j -= 1; &#125; else&#123; s[i] = s[j]; j--; i--; &#125; &#125; return s; &#125; 时间复杂度 : O(N) , 空间复杂度 : O(N)。 这里的空间复杂度明显要比前一种小很多，尤其是字符串很长而空格字符很少的情况。如果形式参数是传引用的形式传递，应该采用解法一，尽量不改变传入的字符串。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"字符串","slug":"字符串","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"简单","slug":"简单","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/"}]},{"title":"剑指 Offer 04. 二维数组中的查找","slug":"leetcode/剑指offer/剑指Offer 04. 二维数组中的查找","date":"2020-10-12T12:56:00.000Z","updated":"2020-10-14T07:16:38.932Z","comments":true,"path":"2020/10/12/leetcode/剑指offer/剑指Offer 04. 二维数组中的查找/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/12/leetcode/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87Offer%2004.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"","text":"剑指 Offer 04. 二维数组中的查找题目描述剑指 Offer 04. 二维数组中的查找 难度:简单 描述 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例 现有矩阵 matrix 如下： 1234567891011121314[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。函数签名:bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) 解法一第一种思路是类似暴力法，因为二维数组每一个维度都是从 index = 0 到 index = size()-1 升序，因此我们可以找到两个边界，缩小遍历的空间大小。 我们只需要两次循环找到边界，再用找到的边界二层循环去寻找 target。 1234567891011121314151617181920212223bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size() == 0 || matrix[0].size() == 0) return false; //边界 int s_m,s_n; //每一个维度的边界 int size_0 = matrix.size(); int size_1 = matrix[0].size(); for(int i =0;i&lt;size_0;++i) //找到纵向的边界 if(matrix[i][0] &gt; target)&#123; s_m = i; break;&#125; for(int j = 0; j &lt; size_1; ++ j) //找到横向的边界 if(matrix[0][j] &gt; target)&#123; s_n = j; break;&#125; for(int i=0;i&lt;s_m;++i) //缩小遍历空间大小 for(int j=0;j&lt;s_n;++j) if(matrix[i][j] == target) return true; return false;&#125; 时间复杂度 : O(N*M) 空间复杂度 : O(1) 。但是，如果二维数组特别大，这么做应该还是能够有效减少遍历次数的。 解法二第二种思路是类似于二叉搜索树。 我们只需要遍历一次数组，每一次先判定当前元素是否出现过(在集合中)，如果没有出现过加入到集合中，如果出现过就直接返回这个元素值即可。 1234567891011121314151617bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size() == 0 || matrix[0].size() == 0) return false; int i = 0; int j = matrix[0].size() - 1; while( i &lt; matrix.size() &amp;&amp; j &gt;= 0 )&#123; // 站在右上角,把数组看成二叉搜索树 if(matrix[i][j] == target) return true; else if(matrix[i][j] &gt; target) j--;// 1 else i++; &#125; return false; &#125; 12// 1 : 这里不需要给i置零// 比如我们要找14,我们11的时候要i++,12的时候i++,16的时候j--,但是target已经大于12了，必不需要从7开始重新判断 可以发现这一种解法一步到位，但是也类似于第一种方法，只是我们的起点设计的比较巧妙，能够通过索引 i j 的一定规律的移动就能找到 target 是否存在。 时间复杂度 : O(N+M) , 空间复杂度 : O(1)。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"简单","slug":"简单","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"数组","slug":"数组","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer 03. 数组中重复的数字","slug":"leetcode/剑指offer/剑指Offer 03. 数组中重复的数字","date":"2020-10-11T14:20:31.000Z","updated":"2020-10-14T07:14:44.734Z","comments":true,"path":"2020/10/11/leetcode/剑指offer/剑指Offer 03. 数组中重复的数字/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/11/leetcode/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"剑指Offer 03. 数组中重复的数字题目描述剑指 Offer 03. 数组中重复的数字 难度:简单 描述 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 12345678输入:[2, 3, 1, 0, 2, 5, 3]输出:2 或 3限制:2 &lt;= n &lt;= 100000函数签名:int findRepeatNumber(vector&lt;int&gt;&amp; nums) 解法一第一种思路是采用暴力法。 我们只需要两层循环遍历数组，当内外层索引对应的元素值相等时，返回这个元素值即可。 时间复杂度 : O(N^2) 空间复杂度 : O(1) 。 解法二第二种思路是采用哈希集合。 我们只需要遍历一次数组，每一次先判定当前元素是否出现过(在集合中)，如果没有出现过加入到集合中，如果出现过就直接返回这个元素值即可。 123456789int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; record; //存出现过的数 for(int num : nums)&#123; if(record.find(num) != record.end()) // 找到了 return num; record.insert(num); &#125; return -1;&#125; 因为我们在 hashset 中查找的时间复杂度是 O(1) 。 因此，时间复杂度 : O(N) , 空间复杂度 : O(N)。 解法三第三种思路是一个萝卜一个坑。剑指Offer书中解答。 因为数组中的编号是 [0, n-1]，因此每一个索引应该对应的是它的值，即i == nums[i] ，所以我们如果现在 i != nums[i] 就把当前的 nums[i] 放到合适的位置，进行两数交换。 12345678910111213int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; for(int i=0;i&lt;nums.size();++i)&#123; while(nums[i] != i)&#123; if(nums[i] == nums[nums[i]]) //如果交换位置的元素相等就直接找到了 return nums[i]; //两数交换 int tmp = nums[i]; nums[i] = nums[tmp]; nums[tmp] = tmp; &#125; &#125; return -1;&#125; 因为有题目的限制： 一定有重复； 最大元素值是 size()-1。 所以题目中的 while 循环一定能够退出。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"简单","slug":"简单","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"哈希集合","slug":"哈希集合","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/"}]},{"title":"浅析list用法/特性/实现","slug":"STL源码剖析/STL-list 分析","date":"2020-10-11T10:52:16.000Z","updated":"2020-10-18T05:05:24.441Z","comments":true,"path":"2020/10/11/STL源码剖析/STL-list 分析/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/11/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/STL-list%20%E5%88%86%E6%9E%90/","excerpt":"","text":"list 容器list 在 C++ 中是一种用起来像链表的模板类。侯捷老师主要介绍的是G2.9和G4.9两个版本。我将阅读一下 clang 中的源码。 list . 结构G2.9 下，list 只有一个成员变量，list_node * node ，是list_node类的指针，在32位机中占用4个字节，在64位机中占用8个字节。 而 list_node 类中，又有三个成员变量 : void * prev : 指向当前节点的前驱 void * next : 指向当前节点的后继 void * data : 指向当前节点 数据结构课程里的双向链表就是这样的一个结构，每一个节点拥有前驱后继节点且有一个数据。因此，list 容器是一个双向链表，与之对应的还有一个单向链表容器 forward_list。 侯捷老师提到此处设计有一个不合理的点 : list_node 已经接收到了模板参数，但是其内部的指针和数据的类型都是 void 。 双向链表底层逻辑是一个环状链表结构，也就是说最后一个节点 next 的 next 是头结点。尾结点后还有一个节点，是为了考虑所有迭代器的区间是前闭后开。 G4.9 下，list 中有两个成员变量。 list . iterator除了 array 和 vector 之外的所有容器的 iterator 必须得是一个类。因为需要重载许多运算符。 list 相较于 vector 的迭代器中的 ++ 操作，就不能是简单的在内存中做偏移了，而是得去寻找 list 的下一个节点，也就是迭代器 iterator 所指节点的 next。 运算符重载中的 i++ 和 ++i 的声明方式 Self&amp; operator++() 重载的是 ++i 操作 Self&amp; operator++(int) 重载的是 i++ 操作，其中 int 是占位符 list . 继承关系待补充","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"容器","slug":"C/STL/容器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"list","slug":"list","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/list/"}]},{"title":"浅析vector用法/特性/实现","slug":"STL源码剖析/STL-vector分析","date":"2020-10-10T13:00:16.000Z","updated":"2020-10-18T15:06:06.423Z","comments":true,"path":"2020/10/10/STL源码剖析/STL-vector分析/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/10/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/STL-vector%E5%88%86%E6%9E%90/","excerpt":"","text":"vector 容器vector 原意是向量。在C++中，是一种用起来像动态数组的模板类。在不同的编译器中，vector 的实现都不尽相同，侯捷老师主要介绍的是G2.9和G4.9两个版本。 123456789//G2.9中 vector类的声明template&lt;class _Tp, class _alloc&gt;class vector&#123;...protected: iterator start; iterator finish; iterator end_of_storage;&#125;; vector . sizeof()曾经有同学试图使用 sizeof() 来计算 vector 对象有多少个元素，可是得到的结果都是意料之外的 ( 因为他数组可能有十多个整形变量，但是sizeof()得到的结果居然是 12 或者 24)。 从源码中可以看到vector的成员变量只有三个类型为 iterator 的迭代器对象，分别名为start , finish , end_of_storage : start : 指向所有内存空间开始的地址 finish : 指向所有内存空间使用的尾地址 end_of_storage : 指向所有内存空间结束的尾地址 vector 对象通过三个指针管理使用的内存空间，而实际的数据并不存储在 vector 对象中。这也就是 sizeof() 得不到想要的数组内存大小的原因。 vector . 内存成长vector 我们在使用的时候都知道它是一个动态数组，那么这个动态就体现在了可以动态地插入，动态地删除。那么 vector 对象控制的内存空间应该分配多少大小才能满足动态地插入呢？ 答案是未知。因为我们并不知道会动态插入多少数组，因此最好的方法是 : 内存空间动态增长。 规则 : 1vector&lt;int&gt; res; //默认构造 start == finish == end_of_storage 不分配内存空间 12345// 成长方式else&#123; const size_type old_size = size(); const size_type len = old_size != 0 ? 2 * old_size : 1; //下方第三点规则&#125; 在 res.size() == 0 时，插入一个元素会使得 res.size() == 1 以及 res.capacity() == 1 如果初始化的时候，赋予了它一定的内存空间，那么res.size() == res.capacity() == 赋值的长度 在 res.size() != 0 时，如果res.size() == res.capacity() ，那么 res.capacity() 呈2倍增长 需要注意的是，我们在最初为 vector 的某一个对象分配了一块内存之后，内存中紧接着之后的内存可能会被其他变量使用，因此 vector 的内存成长并不会发生在原地。它的实做是 : 在另一个位置申请好 capicity() 两倍大小的内存之后，进行逐一拷贝(copy或move)。那么如果 vector&lt;_Tp&gt; 这里的模板参数 typename _Tp 如果是一个类的话，会涉及到 _Tp 的析构函数和拷贝构造函数或移动构造函数。 vector . iterator迭代器 iterator 实际上是一种用起来像指针的类，本质上还是类，每一个迭代器都是类实例化的对象。并且，由于 vector queue list map/set 不同容器底层实现不完全相同或者有几种完全不同，因此并不能设计一种迭代器类同时满足所有容器的操作。 由于 vector 底层是内存连续的空间，因此迭代器也是最简单的。 123456//G2.9template &lt;class T, class Alloc = alloc&gt;class vector&#123; typedef T value_type; typedef value_type* iterator; //T*&#125;; 可以从源码中看到，**vector ** 的迭代器就是元素类型的指针，类型为 T* 。 12345678910111213141516171819//xcode : clangtemplate &lt;class _Tp, class _Allocator&gt;class __vector_base : protected __vector_base_common&lt;true&gt;&#123; public: typedef _Allocator allocator_type; typedef allocator_traits&lt;allocator_type&gt; __alloc_traits; typedef typename __alloc_traits::size_type size_type; protected: typedef _Tp value_type; typedef value_type&amp; reference; typedef const value_type&amp; const_reference; typedef typename __alloc_traits::difference_type difference_type; typedef typename __alloc_traits::pointer pointer; typedef typename __alloc_traits::const_pointer const_pointer; typedef pointer iterator; typedef const_pointer const_iterator; ...&#125; 123456789// 从上面提取template &lt;class _Tp, class _Allocator&gt;typedef _Allocator allocator_type;typedef allocator_traits&lt;allocator_type&gt; __alloc_traits;typedef typename __alloc_traits::pointer pointer;typedef pointer iterator;//因此,vector中的iterator 实际上是 allocator_traits&lt;_Allocator&gt;::pointer 类型//而默认的 allocator 中 pointer 的定义就是 T* (T通过模板参数传递) 从现在的 clang 中，都难以看出 iterator 实际的类型了，侯捷老师在STL源码剖析课程中多次吐槽版本迭代之后，标准库设计的越来越复杂了，也可能是我的功底仍然不够深厚，只能解析到这一步了。之后，在看完侯老师的《源码剖析》书之后，再来详细填补各种留下的坑。 迭代器的使用，迭代器类的继承，以及迭代器的操作符重载，在后续迭代器专题中整理。 vector . 继承关系12345678/*class __vector_base_common*/template &lt;bool&gt;class __vector_base_common&#123;protected: _LIBCPP_NORETURN void __throw_length_error() const; //模板传递在函数中使用 _LIBCPP_NORETURN void __throw_out_of_range() const; //模板传递在函数中使用&#125;; 12345678910111213141516171819/*class __vector_base*/template &lt;class _Tp, class _Allocator&gt;class __vector_base : public __vector_base_common&lt;true&gt;&#123;public: typedef _Allocator allocator_type; typedef allocator_traits&lt;allocator_type&gt; __alloc_traits; typedef ...protected: typedef typename __alloc_traits::pointer pointer; typedef ... //成员变量定义处,注意这里的类名不是vector,是vector私有继承了这个类 //sizeof() = 24 （= 8 * 3） pointer __begin_; pointer __end_; __compressed_pair&lt;pointer,allocator_type &gt; __end_cap_; //命名和G++不同,但是可以看得出说的是end_capacity&#125;; 12345/*struct __compressed_pair_elem*/template &lt;class _Tp, int _Idx&gt;struct __compressed_pair_elem&lt;_Tp, _Idx, true&gt; : private _Tp&#123;&#125; 123456/*class __compressed_pair*/template &lt;class _T1, class _T2&gt;class __compressed_pair : private __compressed_pair_elem&lt;_T1, 0&gt;, private __compressed_pair_elem&lt;_T2, 1&gt; &#123;&#125; 12345/*class vector*/template &lt;class _Tp, class _Allocator /* = allocator&lt;_Tp&gt; */&gt;class _LIBCPP_TEMPLATE_VIS vector : private __vector_base&lt;_Tp, _Allocator&gt;&#123;&#125; 以上是从 xcode : clang 中的 vector 和 memory 头文件中找到的源码，粘贴了部分我想展示的。 并且绘制了继承关系图，如下： 1234567891011121314151617classDiagram class _Tp class __compressed_pair_elem class __compressed_pair class __vector_base_common&#123; - pointer __begin__ - pointer __end__ - __compressed_pair&lt;pointer,allocator_type&gt; __end_cap_ &#125; class __vector_base class vector __vector_base &lt;|-- vector : Inheritance __vector_base_common &lt;|-- __vector_base : Inheritance __vector_base_common *-- __compressed_pair : Composition __compressed_pair_elem &lt;|-- __compressed_pair : Inheritance _Tp &lt;|-- __compressed_pair_elem : Inheritance 可以看到，我们使用的是 vector 模板类，它的 sizeof() = 24 ，也就是 class __vector_base_common 中定义的三根指针，在64位机中，指针为8字节。","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"容器","slug":"C/STL/容器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"vector","slug":"vector","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/vector/"}]},{"title":"两数之和","slug":"leetcode/两数之和","date":"2020-10-09T14:09:31.000Z","updated":"2020-10-10T08:47:35.488Z","comments":true,"path":"2020/10/09/leetcode/两数之和/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/09/leetcode/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"两数之和问题两数之和题目描述Leetcode 1.两数之和 难度:简单 描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 * 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例 12给定 nums = [2, 7, 11, 15], target = 9函数签名 vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) 解法一第一种思路是采用暴力法(虽然说暴力法是无法通过leetcode的,但确实是首先想到的方法)。 我们只需要两层循环遍历数组，在循环索引不相等但是之和为 target 的时候，返回两个索引组成的数组即可。 1234567891011121314vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target)&#123; vector&lt;int&gt; res; // 结果 if(nums.empty()) return res; for(int i=0;i&lt;nums.size()-1;++i)&#123; //为减少内存循环次数,i只循环到最大值-1 for(int j=i+1;j&lt;nums.size();++j)&#123; if(nums.at(i) + nums.at(j) == target)&#123; res.push_back(i); res.push_back(j); return res; &#125; &#125; &#125; return res;&#125; 因为数组中同一元素不能使用两遍，因此内层循环索引 j 只需要从 i+1 开始，但是注意的是 i 不能到达 nums.size()-1 ，否则 j 会越界。所以外层判断条件得是 i&lt;nums.size()-1 。 时间复杂度 : O(N^2) 空间复杂度 : O(1) 。 解法二第二种思路是采用哈希表。 我们需要遍历一次数组，存下每一个&lt;num,index&gt;对，再逐一判断 key:target-num[i] 是否出现在哈希表中。 123456789101112131415vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target)&#123; vector&lt;int&gt; res; // 结果 unordered_map&lt;int,int&gt; record; //&lt;数值,索引&gt; for(int i=0;i&lt;nums.size();++i) record[nums.at(i)] = i; // 等同于 record.insert(pair&lt;int,int&gt;(nums.at(i),i)); for(int i=0;i&lt;nums.size();++i) if(record.find(target-nums.at(i)) != record.end()) &#123; //找到 res.push_back(i); res.push_back(record[target - nums.at(i)]); return res; &#125; return res;&#125; 因为我们在 hashmap 中查找的时间复杂度是 O(1) 。 因此，时间复杂度 : O(N) , 空间复杂度 : O(N)。 解法三第三种思路是采用排序+双指针。 因为形式参数的nums是传引用，所以我们需要对传入的nums进行一次拷贝，在拷贝上进行排序。排序后采用双指针法，找到两个加数的索引。 12345678910111213141516171819vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target)&#123; vector&lt;int&gt; res; // 结果 vector&lt;int&gt; nums_cp(nums); // 不让排序操作改变原数组 sort(nums_cp.begin(),nums_cp.end()); int left = 0, right = nums_cp.size() - 1; while(left &lt; right)&#123; // 1 int sum = nums_cp.at(left) + nums_cp.at(right); if( sum == target)&#123; res.push_back(left); res.push_back(right); return res; &#125; else if( sum &gt; target) right --; else if( sum &lt; target) left ++; &#125; return res;&#125; 注释:1 不能有等号，虽然我们定义的left right 是左闭右闭区间，但是题目要求一个数不能使用两次。因此不能取相等的情况。 时间复杂度 : O(NlogN+N) = O(NlogN) 空间复杂度 : O(N) 主要是多了一份拷贝。 两数之和数据结构设计设计API1234567class TwoSum&#123;public: // 向数组中添加一个新的数 number void add(int number); // 查找当前数组中是否有两数之和为 value bool find(int value);&#125;; 实现12345678910111213141516171819202122232425262728class TwoSum&#123;private: map&lt;int,int&gt; record; //&lt;数值,索引&gt; static int index; public: void add(int number)&#123; record[number] = index++; &#125; bool find(int value)&#123; //采用双指针法在红黑树的map auto left = record.begin(); auto right = record.end(); right --; while(left != right)&#123; int sum = (*left).first + (*right).first; //每一个节点是一个pair if(sum == value) return true; else if(sum &lt; value) left ++; else if(sum &gt; value) right --; &#125; return false; &#125;&#125;;int TwoSum::index = 0; 实现find的时候，和我们做题的时候方法略有不同。因为我们做题的时候，是有vector作为数据的支撑，我们能够在一个随机访问的内存结构里存取数据，而现在我们整个类只有record这一个map&lt;int,int&gt;类的数据和一个静态索引值，而且红黑树的迭代器遍历顺序是按照key升序的，因此我们可以采用双指针的方式来遍历。 class TwoSum 空间复杂度 : O(N) add(int) 时间复杂度 : O(1) find(int) 时间复杂度 : O(N) 改进如果是一个查询次数明显对于插入次数的场景，那么我们的 find() 函数的效率就有点过于低下，我们会重复查询许多次。于是，我们可以把查询的结果也给存下来，记录下每一种可能的和的数值。 12345678910111213141516class TwoSum&#123;private: vector&lt;int&gt; nums; //记录现有数组 unordered_set&lt;int&gt; sums; //记录可能的和 public: void add(int number)&#123; for(int n:nums) //每一次插入都把所有和给记录下来 sums.insert(n+number); nums.push_back(number); &#125; bool find(int value)&#123; return (sums.find(value) != sums.end()); //查找到value返回true &#125;&#125;; class TwoSum 空间复杂度 : O(N) add(int) 时间复杂度 : O(N) find(int) 时间复杂度 : O(1) 学习自 labuladong 三数之和N数之和","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"双指针","slug":"双指针","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"初识STL","slug":"STL源码剖析/第一篇 认识STL","date":"2020-10-07T13:53:23.000Z","updated":"2020-10-09T10:10:01.299Z","comments":true,"path":"2020/10/07/STL源码剖析/第一篇 认识STL/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/07/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E4%B8%80%E7%AF%87%20%E8%AE%A4%E8%AF%86STL/","excerpt":"","text":"STL什么是STL？STL : standard Template Library 标准模板库，STL是C++的一个重要组成部分。 STL包含了众多头文件 : 头文件名称 类型 &lt;algorithm&gt; 算法 &lt;deque&gt; 容器 &lt;functional&gt; 仿函数 &lt;iterator&gt; 迭代器 &lt;vector&gt; 容器 &lt;list&gt; 容器 &lt;map&gt; 容器 &lt;memory.h&gt; 智能指针 &lt;numeric&gt; 数值算法 &lt;queue&gt; 容器 &lt;set&gt; 容器 &lt;stack&gt; 容器 &lt;utility&gt; 比较符 + pair 浏览完以上这一个表格，可以简单了解到STL的组成。 六大部件STL主要包含六个部件： 容器 containers 是一个class template 分配器 allocators 是一个 class template 算法 algorithms 是一个 function template(用起来像函数) 迭代器 iterators 是一个 class template 适配器 adapters 是一个 class template 仿函数 functors 是一个 class template 简单介绍容器容器是数据的承载，容器的设计使得我们”看不到”内存 分配器分配器为容器分配内存回收内存，使得我们不需要插手容器的内存管理 算法算法是模板函数，独立于容器，更加泛化。(有一些容器里有同名重新处理过的函数) 迭代器算法作用于容器的中介，存取数据的一种泛化指针，本质是一种用起来像指针的对象 适配器容器 / 仿函数 / 迭代器的转换，设计思想：适配器设计模式 仿函数作用于容器元素的一种用起来像函数的类 设计思想GP模板编程思想：容器与算法分开。 相对的，OO编程思想：把成员变量和成员函数封装起来。 简单代码演示123vector&lt;int,allocator&lt;int&gt;&gt; vi(ia,ia+6); //容器 分配器cout&lt;&lt;count_if(vi.begin(),vi.end(),not1(bind2nd(less&lt;int&gt;(),40)));//less&lt;int&gt;()原本是a和b比较，bind2nd适配器绑定第二参数,用a和40比,not1适配是变成了大于等于条件 学习自 : 侯捷 STL","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"}]},{"title":"单调队列","slug":"leetcode/单调队列","date":"2020-10-07T06:33:43.000Z","updated":"2020-10-09T10:10:08.588Z","comments":true,"path":"2020/10/07/leetcode/单调队列/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/07/leetcode/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","excerpt":"","text":"单调队列介绍单调队列是一种特殊的数据结构。用来保持一个有序的队列。(无序的数据出队列) 通过适配 deque 而来。 API123456789template&lt; class Type &gt;class monotonous_queue&#123;private: deque&lt;Type&gt; data; //或者使用queuepublic: void push(Type); //尾部插入到单调队列中 void pop(Type); //从头部离开单调队列 Type max(); //返回单调队列中的最大元素&#125;; 实现12345678910111213141516171819template &lt; class Type &gt;void monotonous_queue&lt;Type&gt;::push(Type n)&#123; while(!data.empty() &amp;&amp; n &gt; data.back()) //保持单调队列特性，尾部比输入小的数值全部舍弃 data.pop_back(); data.push_back(n); return;&#125;template &lt; class Type &gt;void monotonous_queue&lt;Type&gt;::pop(Type n)&#123; if(!data.empty() &amp;&amp; data.front() == n) //有可能在pop之前，就因为push()中的步骤pop掉 data.pop_front(); return;&#125;template &lt; class Type &gt;Type monotonous_queue&lt;Type&gt;::max()&#123; return data.front();&#125; 实际上单调队列这一种数据结构使用的是队列中的pop_back() push_back() pop_front() back() front() 方法，queue容器中不提供 pop_back() 方法，因此不可以通过适配 queue 而来。 Leetcode 239 滑动窗口最大值难度:hard 链接:https://leetcode-cn.com/problems/sliding-window-maximum/ 源码: 1234567891011121314vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; monotonous_queue&lt;int&gt; mq; vector&lt;int&gt; res; for(int i=0;i&lt;nums.size();++i)&#123; if(i&lt;k-1) //当前滑动窗口中的元素小于k个时,直接入队 mq.push(nums[i]); else&#123; //入队后,输出窗口中的最大值给res,再弹出最前端为 nums[i-k+1] 的值,没有就不弹出 mq.push(nums[i]); res.push_back(mq.max()); mq.pop(nums[i-k+1]); &#125; &#125; return res;&#125; 时间复杂度：O(N) 空间复杂度：O(k) 学习自labuladong","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"数据结构/队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"单调队列","slug":"单调队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"队列","slug":"队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"单调栈","slug":"leetcode/单调栈","date":"2020-10-06T06:33:43.000Z","updated":"2020-10-09T10:10:15.113Z","comments":true,"path":"2020/10/06/leetcode/单调栈/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/06/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88/","excerpt":"","text":"单调栈介绍单调栈是一种特殊的数据结构。专门用于解决一类问题叫做 Next Greater Number的问题。 性质：单调栈本身还是栈，只是每一次入栈，都会使得栈的排列有序。(其实也就是不满足有序的元素都不要) 通过适配 stack 而来。 Next Greater Number问题描述找到数组中每一个数之后最近的一个比该数大的数字(两种情况，返回索引或返回数值) 1234567891011vector&lt;int&gt; next_greater_elem(const vector&lt;int&gt; &amp; nums)&#123; vector&lt;int&gt; res(nums.size()); //为了倒序访问,提前确定大小方便索引 stack&lt;pair&lt;int,int&gt;&gt; s; //单调栈 : pair&lt;数字,索引&gt; for(int i=nums.size()-1;i&gt;=0;i--)&#123; while(!s.empty() &amp;&amp; s.top().first &lt;= nums[i]) //如果栈顶端的数无法满足有序性,就全弹出 s.pop(); res[i] = (s.empty() == true ) ? 0 : s.top().second-i; //这里返回的是距离,也可返回索引或数值 s.push(pair&lt;int,int&gt;(nums[i],i)); //插入pair&lt;数字,索引&gt; &#125; return res;&#125; 时间复杂度：O(N) 空间复杂度：O(N) Leetcode 相关题目496. 下一个更大元素I 503.下一个更大元素II 1118.一月有多少天 学习自labuladong","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"数据结构/栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"二叉树的遍历","slug":"编程技巧/二叉树遍历","date":"2020-09-25T10:58:19.000Z","updated":"2020-11-11T05:02:17.887Z","comments":true,"path":"2020/09/25/编程技巧/二叉树遍历/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/09/25/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/","excerpt":"","text":"二叉树遍历 博客文章主要目的是分享和记录。 分享给需要学习的同学，记录自己学习路上的点滴。 相信大家对于二叉树的定义以及结构，在本科《数据结构与算法》课程中或者在其他同学的博客中有所了解。在此，不在过多地回顾课本理论知识。 我们编码语言主要为C++，如下是二叉树在C++中类的表现形式，这边使用的是 struct 结构体，在C++中类和结构体的区别在于不标志 public , private 以及 protected 时, 成员变量和成员函数是 public 还是 private 以及默认的继承方式是 public 还是 private。使用 struct 的原因在于，结构体更想表达的是一种数据的组织形式，而不是ADT。 123456struct TreeNode &#123; int val; TreeNode* left; TreeNode* right; TreeNode*(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;&#125;; 并且配图可以更好地理解二叉树的结构。 二叉树的遍历方式在线性结构中，例如，在数组中我们采用索引值（即，地址偏移）的方式去遍历整个数组；在链表中我们采用迭代的方式去遍历整个链表。而二叉树和线性的数组和链表的最大区别在于，二叉树的每一个节点并非只有一个后继节点。因此就有了许多有趣的遍历方式。 分类按照遍历顺序可以分为三种: 前序 中序 后序 层序 按照遍历算法的写法可以分为： DFS（对应前中后的递归） BFS（对应层序） 还可以根据是否采用迭代写法分为： 迭代 递归 框架递归框架（前序中序后序框架）首先是递归，也是最简单书写的一种，其代码框架如下： 12345678void order(TreeNode * root)&#123; if(root == nullptr) return; // 前序 order(root-&gt;left); // 中序 order(root-&gt;right); // 后序&#125; 优缺点优点：递归很简单，我们只需要记住这一个代码框架就可以完成前中后序遍历； 缺点：递归过程中，从根节点出发不断递归左右节点，这一些函数调用的开销发生在栈空间，使得栈空间消耗巨大，甚至可能会导致栈溢出。 理解\u001c那么，为什么这样就可以实现遍历呢？ 递归写法必须有一个递归出口，也就是我们框架函数体内第一个语句，也就是我们递归到了叶子节点的时候，会调用 order(叶子节点的左孩子) 和 order(叶子节点的右孩子) 。那么这两个调用我们就应该停止递归了，也就是遇到了 root==nullptr 这个条件为 true ，递归返回。 那么对于任意一个非空节点来说我们需要做什么？我们无非是要做 : 访问它，访问它的左孩子，访问它的右孩子这三件事。那么既然有三件事，一定会涉及到顺序问题。这三者的顺序不同，就分出了三种访问顺序： 前序：根-左-右 中序：左-根-右 后序：左-右-根 比如，我们要按照中序的顺序输出二叉树的节点值： 12345678void order(TreeNode* root)&#123; if(root == nullptr) return; order(root-&gt;left); /*中序 begin */ cout &lt;&lt; root-&gt;val &lt;&lt; &#x27; &#x27;; //中序位置写执行语句,这一个区域写的root就是中序的节点 /*中序 end */ order(root-&gt;right);&#125;; 迭代框架（前序框架 与 中序框架）迭代框架没有递归框架那么简单，既没有对前中后序以及层序的通用模板，也没有递归那么语句短小，接下来主要介绍：前序，中序，后序，层序的迭代框架（模板）。 123456789101112131415161718vector&lt;int&gt; PreOrder(TreeNode *root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode *&gt; s; while (root || !s.empty()) &#123; if (root) &#123; s.push(root); // res.push_back(root-&gt;val); // PreOrder root = root-&gt;left; &#125; else &#123; root = s.top(); s.pop(); // res.push_back(root-&gt;val); // InOrder root = root-&gt;right; &#125; &#125; return res;&#125; 代码在上方，可以看到前序和中序的框架比较相似，在不同的位置执行操作，那么它的遍历顺序就可以不同。 理解前序遍历，我们总是先读根节点（或者对根节点做一系列操作），如果左孩子存在，再去访问当前根节点的左孩子，那么我们要访问当前节点的左孩子，如果我们需要之后再访问右孩子，我们岂不是无法回到那个根节点了？（树的结构不支持子节点到父节点的指针）。所以，我们需要借助一个辅助栈来存放没有访问过右节点的根节点，等我们把左子树访问完毕之后，再提出之前的根节点，来访问他的右子树。 如图，我们访问了节点1，去访问了节点2，那么我们访问完节点5之后需要回到节点1，再去访问节点3，因此必须把1给保留下来，但是我们不能用单个变量来保存节点1，因为在访问过程中，访问了节点2之后，访问节点4，再之后需要通过节点2，再去访问节点5，这样又需要一个变量来保存节点2，因此再迭代过程中，这个节点记录是一个变长的，所以需要一个辅助栈。 迭代框架（后序框架）前序和中序遍历的迭代框架是类似的，但是后序遍历的框架截然不同。后序遍历顺序：左-右-根。我们可以看到，后序的遍历顺序和前序遍历顺序（根-左-右）类似。我们可以稍微修改前序遍历的框架，再对数组进行反转，获得后序遍历顺序。 1234567891011121314151617181920212223vector&lt;int&gt; PostOrder(TreeNode *root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode *&gt; visit; TreeNode *cur = root; TreeNode *pre = nullptr; while (cur != nullptr || !visit.empty()) &#123; while (cur != nullptr) &#123; visit.push(cur); cur = cur-&gt;left; &#125; cur = visit.top(); if (cur-&gt;right == nullptr || cur-&gt;right == pre) &#123; visit.pop(); res.push_back(cur-&gt;val); pre = cur; cur = nullptr; &#125; else &#123; cur = cur-&gt;right; &#125; &#125; return res;&#125; 1234567891011121314151617181920vector&lt;int&gt; PostOrder_2(TreeNode *root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode *&gt; s; TreeNode *p = root; while (p != nullptr || !s.empty()) &#123; if (p != nullptr) &#123; res.push_back(p-&gt;val); //前序的位置 s.push(p); p = p-&gt;right; //区别在于遍历顺序是 根-右-左 &#125; else if(!s.empty())&#123; p = s.top(); s.pop(); p = p-&gt;left; &#125; &#125; reverse(res.begin(),res.end()); //得到 根-右-左, 反转之后得到 左-右-根 return res;&#125; 理解可以看一下以上的代码：PostOrder(TreeNode* root) 是正常思路的后序遍历迭代写法，而 PostOrder_2(TreeNode* root) 是前序遍历反转的写法。个人感觉前序遍历反转的模板和前序中序模板类似，思想方式较为统一。 迭代框架（层序遍历）层序遍历其实就是BFS的思想，遍历的顺序是按层从低到高来遍历。 1234567891011121314151617vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; deque&lt;TreeNode*&gt; q; q.push_back(root); while(!q.empty())&#123; int size = q.size(); res.push_back(vector&lt;int&gt;()); for(int i = 1;i &lt;= size;++i)&#123; TreeNode* node = q.front();q.pop_front(); res.back().push_back(node-&gt;val); if(node-&gt;left) q.push_back(node-&gt;left); if(node-&gt;right) q.push_back(node-&gt;right); &#125; &#125; return res;&#125; 理解 层序遍历相较于前中后序来说，它访问到了当前节点的兄弟节点以后，我们无法访问前节点的孩子节点。因此，这里不同的是，需要一个辅助的队列来存放同层的节点。 总结那么，二叉树的常见遍历写法都在这边啦。 递归写法因为每一个节点访问一次，所以时间复杂度为:O(N)，而递归需要在栈空间里开辟许多空间，平均递归的深度是logN，因此空间复杂度也是:O(logN)。 迭代写法因为每一个节点访问一次，所以时间复杂度为:O(N)，而迭代需要一个辅助栈或者辅助队列，平均的情况是把logN的节点放入栈或队列，最差的情况是把大多数节点全部放入栈或队列，因此空间复杂度也是：O(logN)。 而还有一个遍历写法叫做morris遍历，它能够实现空间复杂度为O(1)。但是写法较为复杂，准备另外再写一篇关于morris遍历的模板。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"数据结构/二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"C++11","slug":"C/C-11","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/C-11/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"迭代器","slug":"C/STL/迭代器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《设计模式》","slug":"读书笔记/《设计模式》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"},{"name":"单一职责模式","slug":"读书笔记/《设计模式》/单一职责模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/"},{"name":"组件协作模式","slug":"读书笔记/《设计模式》/组件协作模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/"},{"name":"《深入理解计算机系统》","slug":"读书笔记/《深入理解计算机系统》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"},{"name":"第八章 异常控制流","slug":"读书笔记/《深入理解计算机系统》/第八章-异常控制流","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"},{"name":"容器","slug":"C/STL/容器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E5%AE%B9%E5%99%A8/"},{"name":"网络通信","slug":"网络通信","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"传输层","slug":"网络通信/传输层","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"name":"TCP","slug":"网络通信/传输层/TCP","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"},{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"数据结构/栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"},{"name":"队列","slug":"数据结构/队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"},{"name":"二叉树","slug":"数据结构/二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"深入理解操作系统学习笔记","slug":"深入理解操作系统学习笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"C++11","slug":"C-11","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C-11/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"iterator","slug":"iterator","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/iterator/"},{"name":"设计模式","slug":"设计模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"操作系统","slug":"操作系统","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"vector","slug":"vector","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/vector/"},{"name":"tcp","slug":"tcp","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/tcp/"},{"name":"栈","slug":"栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"中等","slug":"中等","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%B8%AD%E7%AD%89/"},{"name":"简单","slug":"简单","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"链表","slug":"链表","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"字符串","slug":"字符串","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希集合","slug":"哈希集合","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/"},{"name":"list","slug":"list","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/list/"},{"name":"双指针","slug":"双指针","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"单调队列","slug":"单调队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"单调栈","slug":"单调栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]}