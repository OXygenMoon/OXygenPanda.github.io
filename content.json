{"meta":{"title":"劳振煜的知識倉儲","subtitle":"Study & Share","description":"致力于互联网应用&服务开发","author":"劳振煜","url":"https://OXygenPanda.github.io/OXygenPanda.github.io","root":"/OXygenPanda.github.io/"},"pages":[{"title":"书单","date":"2021-01-14T14:28:20.694Z","updated":"2020-11-10T11:22:57.808Z","comments":false,"path":"books/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-01-14T14:28:20.693Z","updated":"2020-11-10T12:34:07.179Z","comments":false,"path":"about/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/about/index.html","excerpt":"","text":"个人详细介绍 姓名：劳振煜 年龄：24岁 籍贯：浙江嘉兴 本科：宁波大学 通信工程 硕士：哈尔滨工程大学 计算机技术 联系方式 手机：18888641109 邮箱：&#76;&#97;&#111;&#122;&#104;&#101;&#x6e;&#121;&#x75;&#95;&#x39;&#54;&#49;&#x31;&#x31;&#50;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109; 自我介绍 热爱编程，喜欢C++，但接受转golang和Java，希望能够实现自我价值。 base : 上海，杭州，深圳，北京"},{"title":"分类","date":"2020-11-14T14:38:00.000Z","updated":"2020-11-14T14:38:11.043Z","comments":false,"path":"categories/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-11-08T11:53:34.000Z","updated":"2020-11-08T11:54:11.563Z","comments":true,"path":"friends/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-14T14:35:04.000Z","updated":"2020-11-14T14:36:29.320Z","comments":true,"path":"tags/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2020-11-10T11:38:00.000Z","updated":"2020-11-10T11:38:09.976Z","comments":true,"path":"links/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2020-11-10T11:38:00.000Z","updated":"2020-11-10T11:38:50.129Z","comments":true,"path":"repository/index.html","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"IO多路复用","slug":"HugeFour/OperatingSystem/IO多路复用/IO多路复用","date":"2021-01-20T06:07:00.000Z","updated":"2021-02-02T06:08:48.619Z","comments":true,"path":"2021/01/20/HugeFour/OperatingSystem/IO多路复用/IO多路复用/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/20/HugeFour/OperatingSystem/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","excerpt":"学习自 : https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=6979152329662416408 前言服务器应对并发时, 如果使用多线程程序, 每一个连接创建一个线程, 由于上下文切换, 处理句柄会导致代价很高. 所以很多时候, 使用的是单线程程序, 其中 DMA 保证了不同时候到来的 IO数据 不会丢失.","text":"学习自 : https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=6979152329662416408 前言服务器应对并发时, 如果使用多线程程序, 每一个连接创建一个线程, 由于上下文切换, 处理句柄会导致代价很高. 所以很多时候, 使用的是单线程程序, 其中 DMA 保证了不同时候到来的 IO数据 不会丢失. 最简单的一个由程序来接收IO数据的程序. 12345678while(1) &#123; for(Fdx in (FdA ~ FdE) &#123; if(Fdx 有数据) &#123; 读Fdx; 处理; &#125; &#125;&#125; 但是, 每一次由用户来询问内核, 开销较大, 因此有了 select(). select()1234567891011121314151617181920212223while(1) &#123; FD_ZERO(&amp;rset); for(i = 0; i &lt; 5; i ++) &#123; FD_SET(fds[i], &amp;rset); &#125; puts(&quot;round again&quot;); select(max + 1, &amp;rset, NULL, NULL, NULL); //阻塞函数 /* para 0:文件描述符最大的范围(因为第一位是fd=0,所以要加1) para 1:读文件描述符(比较关注) para 2:写文件描述符 para 3:异常文件描述符 para 4:超时时间 */ for(i = 0; i &lt; 5; i ++) &#123; if(FD_ISSET(fds[i], &amp;rset)) &#123; memset(buffer, 0, MAXBUF); read(fds[i], buffer, MAXBUF); puts(buffer); &#125; &#125;&#125; 工作原理 使用 rset(bitmap) 来标记注册的 Fds ; 将 rset 拷贝至内核态 ; select() 阻塞 ; 有数据到来后, 内核对有数据的 rset位 置位, 并且 select() 返回 ; 遍历 Fds 判断是否被置位, 如果置位就说明对应的 IO 有数据 ; 由于破坏了 rset位图, 需要重新遍历 Fds 标记 rest位图 ; 循环 2 - 6. 注意事项 rset 的数据结构以及存储的数据的表示 1234567rset的数据类型是 bitmap假设 fds 分别是 1, 2, 5, 7, 9那么rest 的值就是 bitmap&lt;1024&gt;0110&#x27;0101&#x27;01000...//左边第一个代表的是 fds 值为0的不存在//1024 因为 Linux 默认支持最大线程数是1024 工作状态 12无数据 : select() 阻塞有数据 : 内核 1. 对有数据来的FD置位 2. select() 返回 返回值 123成功 : 大于 0 出错 : -1超时 : 0 select() 的优点 将 rset 交给内核监听, 节约了一定的开销; select() 的核心是内核等待队列唤醒机制. select() 的缺点 rset : 1024 bitmap FDset 不可重用 用户态拷贝的时候切换到内核态, 仍然有开销 O(n) 时间复杂度去遍历得到哪一个 IO 有数据 poll()1234567891011121314151617181920212223242526272829303132struct pollfd &#123; int id; //fds short events; //关注的事件 short revents; //反馈(初始值为0)&#125;;for(i = 0; i &lt; 5; i++) &#123; memset(&amp;client, 0, sizeof(client)); addrlen = sizeof(client); pollfds[i].fd = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen); pollfds[i].events = POLLIN;&#125;sleep(1);while(1) &#123; puts(&quot;round again&quot;); poll(pollfds, 5, 50000); //阻塞 /* para 0 : 结构体数组名 para 1 : fds的个数 para 2 : 超时时间 */ for(i = 0; i &lt; 5; i ++) &#123; if(pollfds[i].revents &amp; POLLIN) &#123; //判 revents 和 关注的事件 pollfds[i].revents = 0; //置位达到可重用效果 memset(buffer, 0, MAXBUF); read(pollfds[i], fd, buffer, MAXBUF); puts(buffer); &#125; &#125;&#125; 工作原理用户态拷贝 fds 至内核态, 由内核监听(和 select() 一样) 注意事项 struct pollfd 的细节 123struct pollfd 的一个节点相当于是 rset 中的一位events 用于标记关注的事件, 如果同时关注多个事件, 事件1 &amp; 事件2revents 初始为0, 内核置数, 处理时清零, 可重用 工作状态 12无数据 : poll() 阻塞有数据 : 内核 1. pollfds.revents 置位 2. poll 返回 poll() 的优点 数组可以超过 1024 长(最大65535长) 重置 revents 后可重用 epoll()1234567891011121314151617181920212223struct epoll_event events[5];int epfd = epoll_create(10); // 1......for(i = 0; i &lt; 5; i ++) &#123; static struct epoll_event ev; memset(&amp;client, 0, sizeof(client)); addrlen = sizeof(client); ev.data.fd = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen); ev.events = EPOLLIN; epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev); // 2&#125;while(1) &#123; puts(&quot;round again&quot;); nfds = epoll_waits(epfd, events, 5, 10000); // 3 for(i = 0; i &lt; nfds; i ++) &#123; memset(buffer, 0, MAXBUF); read(events[i].data.fd, buffer, MAXBUF); puts(buffer); &#125;&#125; 工作流程1 : 创建白板 epfd 2 : 在白板上写字 : fd - events, 得到了一些列 fd - events 的 epfd 3 : epfd 由用户态和内核态共享内存 ( 实际上还是要拷贝到内核态, 在 epoll_ctl() 就拷贝 ) 注意事项 函数细节 12epoll_ctl() 向内核注册新的描述符或者改变某个文件描述符的状态, 已注册的描述符在内核中被维护成红黑树epoll_wait() 回调函数, 内核将有数据的描述符加入到一个链表中, 进程获得描述符数 工作状态 12没数据 : epoll() 阻塞(水平触发下, 边缘触发?)有数据 : 1. &quot;置位&quot;(重排,将有数据的fd-events放在最前面) 2. 返回值是有数据的IO数 两种触发模式 12345LT:水平触发 当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-BlockingET:边缘触发 和 LT 模式不同的是，通知之后进程必须立即处理事件。下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 epoll() 的优点 时间复杂度 O(1)","categories":[{"name":"Linux","slug":"Linux","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Linux/"}]},{"title":"红黑树","slug":"HugeFour/DataStructrues/tree/RBTree","date":"2021-01-15T14:48:00.000Z","updated":"2021-01-15T14:51:33.879Z","comments":true,"path":"2021/01/15/HugeFour/DataStructrues/tree/RBTree/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/15/HugeFour/DataStructrues/tree/RBTree/","excerpt":"","text":"红黑树名称 : 红黑树 优点 : 相较AVL树来说, 平衡条件宽松, 减少了很多因插入删除节点导致的调整. 适合于插入删除频繁的情况. AVL树适合于插入删除较少, 搜索较多的情况. 平衡条件 : 每个节点非黑即红 根节点是黑色 叶节点(NIL)是黑色 NIL : 虚拟空节点 如果一个节点是红色, 则它的两个子节点都是黑色的 从根节点触发到所有叶节点路径上, 黑色节点数量相同 (最长是最短路径的2倍 : 长边红黑相间, 短边黑色) 认识 : 平衡条件 4 和 5 限制了红黑树最长边和最短边的2倍长度关系. 本质上, 红黑树也是通过控制树高来保证平衡. 红黑树相比AVL树控制条件更弱, 因此插入删除调整的频次也会低. AVL树更适用于插入删除较少但是访问较多的情况.","categories":[{"name":"tree","slug":"tree","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/tree/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"快速排序","slug":"HugeFour/DataStructrues/sort/quick","date":"2021-01-15T10:00:00.000Z","updated":"2021-01-15T14:51:52.956Z","comments":true,"path":"2021/01/15/HugeFour/DataStructrues/sort/quick/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/15/HugeFour/DataStructrues/sort/quick/","excerpt":"","text":"快速排序基础知识名称 : 快速排序 性质 : 不稳定的排序算法 用途 : 分治思路的排序 复杂度 : 时间 O(nlogn) 空间 O(1) 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/************************************************************************ &gt; File Name: quick_sort2.cpp &gt; Author: Lao Zhenyu &gt; Mail: LaoZhenyu_961112@163.com &gt; Created Time: 五 1/15 17:48:29 2021************************************************************************/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;#include &lt;unordered_set&gt;using namespace std;void quickSort(vector&lt;int&gt; &amp;arr, int left, int right)&#123; if(left &gt;= right) return; int i,j,base; base = arr[left]; i = left, j = right; while(i &lt; j)&#123; while(arr[j] &gt;= base &amp;&amp; i &lt; j) j--; while(arr[i] &lt;= base &amp;&amp; i &lt; j) i++; if(i &lt; j) swap(arr[i], arr[j]); &#125; arr[left] = arr[i]; arr[i] = base; quickSort(arr, left, i - 1); quickSort(arr, i + 1, right);&#125;int main()&#123; vector&lt;int&gt; arr&#123;1,3,2,6,5,4,9,7,8,&#125;; quickSort(arr, 0, arr.size() - 1); for(int n : arr)&#123; cout &lt;&lt; n &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"排序算法","slug":"排序算法","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"归并排序","slug":"HugeFour/DataStructrues/sort/merge","date":"2021-01-14T12:00:00.000Z","updated":"2021-01-15T14:52:09.301Z","comments":true,"path":"2021/01/14/HugeFour/DataStructrues/sort/merge/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/14/HugeFour/DataStructrues/sort/merge/","excerpt":"","text":"归并排序基础知识名称 : 归并排序 性质 : 稳定的排序算法 作者 : 冯诺依曼 用途 : 分治思路的排序 复杂度 : 时间 O(nlogn) 空间 O(n) 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/************************************************************************ &gt; File Name: merge_sort.cpp &gt; Author: Lao Zhenyu &gt; Mail: LaoZhenyu_961112@163.com &gt; Created Time: 四 1/14 20:38:22 2021************************************************************************/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;#include &lt;unordered_set&gt;using namespace std;void merge(vector&lt;int&gt; &amp;arr, int left, int mid, int right)&#123; vector&lt;int&gt; L(mid - left + 1); vector&lt;int&gt; R(right - mid); int i,j,k; for(i = 0; i &lt; L.size(); ++ i)&#123; L[i] = arr[left + i]; &#125; for(j = 0; j &lt; R.size(); ++ j)&#123; R[j] = arr[mid + 1 + j]; &#125; i = 0; j = 0; k = left; while(i &lt; L.size() &amp;&amp; j &lt; R.size())&#123; if(L[i] &gt;= R[j])&#123; arr[k] = R[j]; j++; &#125; else &#123; arr[k] = L[i]; i++; &#125; k++; &#125; while(i &lt; L.size())&#123; arr[k] = L[i]; k++; i++; &#125; while(j &lt; R.size())&#123; arr[k] = R[j]; k++; j++; &#125;&#125;void mergeSort(vector&lt;int&gt; &amp;arr, int left, int right)&#123; if(left &lt; right)&#123; int mid = left + ((right - left) &gt;&gt; 1); mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); merge(arr, left, mid, right); &#125; return;&#125;int main()&#123; vector&lt;int&gt; arr&#123;1,3,2,4,5,6,9,7,8&#125;; mergeSort(arr,0, arr.size() - 1); for(auto n : arr)&#123; cout &lt;&lt; n &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"排序算法","slug":"排序算法","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"AVL树","slug":"HugeFour/DataStructrues/tree/AVLTree","date":"2021-01-07T13:00:00.000Z","updated":"2021-01-15T14:51:32.323Z","comments":true,"path":"2021/01/07/HugeFour/DataStructrues/tree/AVLTree/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/07/HugeFour/DataStructrues/tree/AVLTree/","excerpt":"","text":"AVL树基础知识名称 : AVL树 发明者 : G. M. Adelson-Velsky E.M. Landis 年代 : 1962年(58岁) 优点 : 由于对每个节点的左右子树的树高做了限制, 所以整棵树不会退化成一个链表 **学习重点 : ** 平衡二叉排序树,本质上也是二叉排序树, 所以拥有二叉排序树的所有性质 平衡二叉排序树的学习重点, 在于平衡条件以及平衡调整的相关学习 性质 : 平衡条件 : | H(left) - H(right) | ≤ 1 思考 : ​ 高度为 H 的树, 所包含节点的范围是? ​ BinarySearchTree : H ≤ size ≤ 2^H - 1 ​ AVLTree : low(H-2) + low(H-1) + 1 ≤ size ≤ 2^H - 1 (low(H) 是 H 高度的二叉树的最少节点数) 左边等于 1.5^H 操作SSS AVL树 - 左旋 左旋前 左旋后 AVL树 - 右旋 右旋前 右旋后 失衡类型h(1,2,3,4) 分别代表左孩子的左子树个高,左孩子的右子树高,右孩子的左子树高和右孩子的右子树高 LL类型:左子树的左孩子更高 满足条件 : h1 = max(h3, h4) + 2 = h2 + 1 调整方案 : K1 右旋 LR类型:左子树的右孩子更高 满足条件 : max(h2, h3) = h4 = h1 调整方案 : 小左旋, 大右旋(左孩子左旋, 根节点右旋) RL类型:右子树的左孩子更高 调整方案 : 小右旋, 大左旋 RR类型:右子树的右孩子更高 调整方案 : K1 左旋 平衡调整策略 发生在回溯阶段的, 第一个失衡节点处 理解平衡调整策略的关键在于 : 分析清楚四种情况下, ABCD四棵子树树高的关系 LL, 大右旋 LR, 先小左旋, 再大右旋 RL, 先小右旋, 再大左旋 RR, 大左旋 代码关键点 插入和删除以后, 注意调整树高字段, 先调低的root, 再调高的tmp 引入了NIL节点, 代替了 NULL和nullptr, NULL不可访问资源, NIL是一个实际节点, 可以访问资源(h,lchild,rchild) 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define L(n) (n-&gt;lchild)#define R(n) (n-&gt;rchild)#define H(n) (n-&gt;h)typedef struct Node&#123; int key,h; struct Node *lchild, *rchild;&#125;Node;//虚拟空节点, 为红黑树做准备的节点Node __NIL;#define NIL (&amp;__NIL)__attribute__((constructor))void init_NIL()&#123; NIL-&gt;key = 0, NIL-&gt;h = 0; NIL-&gt;lchild = NIL-&gt;rchild = nullptr;&#125;//优先初始化上面这一段代码/* * AVL树的若干操作: * 1. 创建节点 * 2. 销毁节点 * 3. 插入 * 4. 删除*/Node *getNewNode(int key)&#123; Node * tmp = (Node*)malloc(sizeof(Node)); tmp-&gt;key = key; tmp-&gt;h = 1; tmp-&gt;lchild = NIL, tmp-&gt;rchild = NIL; return tmp;&#125;void clear(Node * root)&#123; if(root == NIL) return; clear(root-&gt;lchild); clear(root-&gt;rchild); free(root); return;&#125;//调整高度void update_height(Node * root)&#123; root-&gt;h = (H(L(root)) &gt; H(R(root)) ? H(L(root)) : H(R(root))) + 1;&#125;//左旋Node * left_rotate(Node * root)&#123; Node * tmp = root-&gt;rchild; //新根节点 root-&gt;rchild = tmp-&gt;lchild; //新左挂旧右 tmp-&gt;lchild = root; //旧根挂新左 update_height(root); update_height(tmp); return tmp;&#125;//右旋Node * right_rotate(Node * root)&#123; Node * tmp = root-&gt;lchild; //新根 root-&gt;lchild = tmp-&gt;rchild; //新右成旧左 tmp-&gt;rchild = root; //旧根成新左 update_height(root); update_height(tmp); return tmp;&#125;//调整Node * maintain(Node * root)&#123; //平衡调整代码 if(abs(H(L(root)) - H(R(root))) &lt;= 1) return root; if(root-&gt;lchild-&gt;h &gt; root-&gt;rchild-&gt;h) &#123; //LR先小左旋 if(root-&gt;lchild-&gt;lchild-&gt;h &lt; root-&gt;lchild-&gt;rchild-&gt;h) root-&gt;lchild = left_rotate(root-&gt;lchild); //LL大右旋 root = right_rotate(root); &#125; else &#123; //RL先小右旋 if(root-&gt;rchild-&gt;rchild-&gt;h &lt; root-&gt;rchild-&gt;lchild-&gt;h) root-&gt;rchild = right_rotate(root-&gt;rchild); //RR大左旋 root = left_rotate(root); &#125; return root;&#125;Node * insert(Node * root, int key)&#123; if(root == NIL) return getNewNode(key); if(root-&gt;key == key) return root; if(key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild, key); if(key &gt; root-&gt;key) root-&gt;rchild = insert(root-&gt;rchild, key); update_height(root); return maintain(root);&#125;//寻找前驱节点,默认传入度为2的节点,前父节点有左子树Node * predeccessor(Node * root)&#123; Node * tmp = root-&gt;lchild; while(tmp-&gt;rchild) tmp = tmp-&gt;rchild; return tmp;&#125;Node * erase(Node * root, int key)&#123; if(root == NIL) return NIL; if(key &lt; root-&gt;key) &#123; root-&gt;lchild = erase(root-&gt;lchild, key); &#125; else if(key &gt; root-&gt;key) &#123; root-&gt;rchild = erase(root-&gt;rchild, key); &#125; else &#123; //删除当前节点 if(root-&gt;rchild == NIL || root-&gt;lchild == NIL)&#123; Node * tmp = root-&gt;rchild != NIL ? root-&gt;rchild : root-&gt;lchild; free(root); return tmp; &#125; else &#123; // 删除度为2的节点 Node * tmp = predeccessor(root); root-&gt;key = tmp-&gt;key; root-&gt;lchild = erase(root-&gt;lchild, root-&gt;key); &#125; &#125; update_height(root); return maintain(root);&#125;void print(Node * root)&#123; printf(&quot;(%d[%d], %d, %d)\\n&quot;, root-&gt;key, root-&gt;h, root-&gt;lchild-&gt;key, root-&gt;rchild-&gt;key );&#125;void output(Node * root)&#123; if(root == NIL) return; print(root); output(root-&gt;lchild); output(root-&gt;rchild); return ;&#125;int main(int argc, char ** argv)&#123; int op, val; Node* root = NIL; while(~scanf(&quot;%d%d&quot;, &amp;op, &amp;val))&#123; switch(op)&#123; case 0: root = erase(root, val); break; case 1: root = insert(root, val); break; &#125; output(root); printf(&quot;------------\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"tree","slug":"tree","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/tree/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"二叉搜索树","slug":"HugeFour/DataStructrues/tree/BinarySearchTree","date":"2021-01-06T12:00:00.000Z","updated":"2021-01-08T15:24:23.255Z","comments":true,"path":"2021/01/06/HugeFour/DataStructrues/tree/BinarySearchTree/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/06/HugeFour/DataStructrues/tree/BinarySearchTree/","excerpt":"","text":"二叉排序树基础知识名称 : 二叉排序树, 二叉搜索树 性质 : 左子树 &lt; 根节点 右子树 &gt; 根节点 用途 : 解决与排名有关的检索需求 插入过程 : 根据插入节点值和根节点比较, 选择左子树或右子树继续比较, 最终放在叶子节点上 删除过程 : 删除叶子节点 直接删除 删除度为1的节点 把孩子交给祖父节点 删除度为2的节点 中序遍历 : 10 17 20 28 29 30 32 性质 : 待删除节点的前驱无右子树, 后继无左子树, 因此前驱后继一定不是度为2的节点 将前驱或后继直接覆盖待删除节点后, 问题转换为删除叶子节点或者是度为1的节点 优化 : 删除掉处理度为0的代码逻辑，不影响代码整体功能 解决排名相关的检索需求，修改二叉搜索树的定义，增加size字段，记录每棵树的节点数目 K == LS - 1 : 根节点就是排名第k的元素 k &lt;= LS : 排名第k位的元素在左子树中 k &gt; LS : $search_k(root-&gt;rchild, k - LS - 1)$ 解决 top-k 问题，输出前k位的元素(找到小于第k位的所有元素) 根节点就是第k位元素, 输出左子树所有节点和根节点值 第k位元素在左子树中, 前k位元素全部在左子树中 第k位元素在右子树中, 说明左子树中的所有节点和根节点都是前k位元素 二叉排序树和快速排序的关系 二叉排序树是快速排序的逻辑结构 思考1: 快速排序算法的时间复杂度和二叉排序树建树时间复杂度之间的关系 思考2：快速选择算法和二叉排序树的关系 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;#define KEY(n) (n ? n-&gt;key : 0)#define SIZE(n) (n ? n-&gt;size : 0)#define L(n) (n ? n-&gt;lchild : 0)typedef struct Node&#123; int key, size; struct Node *lchild, *rchild;&#125;Node;/* * 二叉搜索树的若干操作: * 1. 创建节点 * 2. 销毁节点 * 3. 查找 * 4. 插入 * 5. 删除*//* * 优化1: 将删除度为0和度为1的节点的代码合并 * 优化2: 实现查找第k位的元素 * 优化3: 实现输出前k位的元素(TOP-K)*///更新树高void update_size(Node * root)&#123; root-&gt;size = SIZE(root-&gt;lchild) + SIZE(root-&gt;rchild) + 1;&#125;//创建节点Node * getNewNode(int key)&#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;key = key; p-&gt;size = 1; p-&gt;lchild = nullptr, p-&gt;rchild = nullptr; return p;&#125;//销毁树void clear(Node * root)&#123; if(root == nullptr) return; clear(root-&gt;lchild); clear(root-&gt;rchild); free(root); return;&#125;//查找int search(Node* root, int val)&#123; if(root == nullptr) return 0; if(root-&gt;key == val) return 1; if(root-&gt;key &gt; val) return search(root-&gt;lchild, val); if(root-&gt;key &lt; val) return search(root-&gt;rchild, val); return 0;&#125;//查找第k大的元素int search_k(Node * root, int k)&#123; if(root == nullptr) return -1; if(SIZE(L(root)) == k - 1) return root-&gt;key; if(k &lt;= SIZE(L(root))) &#123; return search_k(root-&gt;lchild, k); &#125; else &#123; return search_k(root-&gt;rchild, k - SIZE(L(root)) - 1); &#125;&#125;//插入Node * insert(Node * root, int val)&#123; if(root == nullptr) return getNewNode(val); if(root-&gt;key == val) return root; if(val &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild, val); if(val &gt; root-&gt;key) root-&gt;rchild = insert(root-&gt;rchild, val); update_size(root); return root;&#125;//寻找前驱(默认父节点有左孩子)Node * predecessor(Node * root)&#123; Node * tmp = root-&gt;lchild; while(tmp-&gt;rchild != nullptr) tmp = tmp-&gt;rchild; return tmp;&#125;//删除节点Node * erase(Node * root, int val)&#123; if(root == nullptr) return nullptr; if(root-&gt;key &gt; val) root-&gt;lchild = erase(root-&gt;lchild, val); else if(root-&gt;key &lt; val) root-&gt;rchild = erase(root-&gt;rchild, val); else &#123; //删除节点本身 //删除度为0的节点和度为1的节点操作相同 if(root-&gt;lchild == nullptr || root-&gt;rchild == nullptr)&#123; Node * tmp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild; free(root); return tmp; &#125; else &#123; //删除度为2的节点 Node * tmp = predecessor(root); root-&gt;key = tmp-&gt;key; root-&gt;lchild = erase(root-&gt;lchild, tmp-&gt;key); &#125; &#125; update_size(root); return root;&#125;//输出整棵树的所有节点 - 中序void output(Node * root)&#123; if(root == nullptr) return; output(root-&gt;lchild); printf(&quot;[%d, %d, %d, size : %d]\\n&quot;,KEY(root),KEY(root-&gt;lchild),KEY(root-&gt;rchild),SIZE(root)); output(root-&gt;rchild); return;&#125;//输出前k个节点void output_k(Node *root, int k)&#123; if(k == 0 || root == nullptr) return; if(k &lt;= SIZE(L(root)))&#123; output_k(root-&gt;lchild, k); &#125; else &#123; output(root-&gt;lchild); printf(&quot;[%d, %d, %d, size : %d]\\n&quot;,KEY(root),KEY(root-&gt;lchild),KEY(root-&gt;rchild),SIZE(root)); output_k(root-&gt;rchild, k - SIZE(L(root)) - 1); &#125; return;&#125;int main(int argc, char ** argv)&#123; int op, val; /* op : * 0 查找 * 1 插入 * 2 删除 * 3 查找第k位的元素 * 4 输出前k位的元素 */ Node * root = nullptr; while(~scanf(&quot;%d%d&quot;, &amp;op, &amp;val))&#123; switch(op)&#123; case 0: printf(&quot;search %d, result : %d\\n&quot;, val, search(root, val)); break; case 1: root = insert(root, val); break; case 2: root = erase(root, val); break; case 3: printf(&quot;search k %d, result : %d\\n&quot;,val, search_k(root, val)); break; case 4: &#123; printf(&quot;output top-%d elements\\n&quot;,val); output_k(root, val); printf(&quot;----------------\\n&quot;); &#125; break; &#125; if(op != 0 &amp;&amp; op != 4)&#123; output(root); printf(&quot;----------------\\n&quot;); &#125; &#125; return 0;&#125;","categories":[{"name":"tree","slug":"tree","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/tree/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"剑指 Offer 45. 把数组排成最小的数","slug":"leetcode/offer/剑指Offer 45","date":"2020-12-18T13:06:00.000Z","updated":"2020-12-18T13:11:01.136Z","comments":true,"path":"2020/12/18/leetcode/offer/剑指Offer 45/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/18/leetcode/offer/%E5%89%91%E6%8C%87Offer%2045/","excerpt":"剑指 Offer 45. 把数组排成最小的数题目描述剑指 Offer 45. 把数组排成最小的数 难度:中等 描述 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。","text":"剑指 Offer 45. 把数组排成最小的数题目描述剑指 Offer 45. 把数组排成最小的数 难度:中等 描述 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 示例 12345678910输入: [10,2]输出: &quot;102&quot; 输入: [3,30,34,5,9]输出: &quot;3033459&quot;限制:0 &lt; nums.length &lt;= 100输出结果可能非常大，所以你需要返回一个字符串而不是整数拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 解法思路是, 因为每一个数字内的相对关系是不能改变的, 因此不能把数字拆分成各个数位做排序. 因此, 可以寻找数字排列先后的规律, 比如, 10 和 2 两个数字可以组成 102 和 210 , 但是 102 &lt; 210 因此, 10 在前. 这就是一种排序规则. 可以写一个 lambda 表达式指导 sort() 按照刚刚模拟的方式来排序所有数字. 最后拼接到目标串中. 123456789101112131415class Solution &#123;public: string minNumber(vector&lt;int&gt;&amp; nums) &#123; vector&lt;string&gt; strs; string res; for(auto n : nums) strs.push_back(to_string(n)); sort(strs.begin(),strs.end(),[](const string &amp; a, const string &amp; b)-&gt;bool&#123; return a+b &lt; b+a; // 102 &lt; 210 &#125;); for(auto str : strs) res += str; return res; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"}]},{"title":"剑指 Offer 29. 顺时针打印矩阵","slug":"leetcode/offer/剑指Offer 29","date":"2020-12-15T13:40:00.000Z","updated":"2020-12-18T13:06:04.692Z","comments":true,"path":"2020/12/15/leetcode/offer/剑指Offer 29/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/15/leetcode/offer/%E5%89%91%E6%8C%87Offer%2029/","excerpt":"剑指 Offer 29. 顺时针打印矩阵题目描述剑指 Offer 29. 顺时针打印矩阵 难度:简单 描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。","text":"剑指 Offer 29. 顺时针打印矩阵题目描述剑指 Offer 29. 顺时针打印矩阵 难度:简单 描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 123456789输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]限制:0 &lt;= matrix.length &lt;= 1000 &lt;= matrix[i].length &lt;= 100 解法一第一种思路是模拟法, 模拟我们正常地顺时针行走, 提供一个方向数组, 提前判断下一步会不会超出边界, 如果超出, 那么就转向, 也就是改变 directionIndex 的值, 因为可能会从北回到东, 所以需要 mod 4 . 12345678910111213141516171819202122232425262728class Solution &#123;public: const int direction[4][2] = &#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125;&#125;; // 方向数组,东-南-西-北 vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size() == 0 || matrix[0].size() == 0) return &#123;&#125;; int row = matrix.size(), col = matrix[0].size(); vector&lt;vector&lt;bool&gt;&gt; visit(row, vector&lt;bool&gt;(col, false)); int total = row * col; vector&lt;int&gt; res(total); int rows = 0, cols = 0; int directionIndex = 0; for(int i = 0 ; i &lt; total ; ++ i)&#123; res[i] = matrix[rows][cols]; visit[rows][cols] = true; // 已经访问过 int nextrow = rows + direction[directionIndex][0]; // 下一个横坐标 int nextcol = cols + direction[directionIndex][1]; // 下一个纵坐标 //判断下一个坐标是否合法或者是否访问过, 访问过就改变方向 if(nextrow &lt; 0 || nextrow &gt;= row || nextcol &lt; 0 || nextcol &gt;= col || visit[nextrow][nextcol]) directionIndex = (directionIndex + 1) % 4; rows += direction[directionIndex][0]; cols += direction[directionIndex][1]; &#125; return res; &#125;&#125;; 解法二第二种思路是缩小边界法, 它一共是四个边界 l r u d 来表示, 当前 left right up down 四个边界.因为每一次都是沿着四条边移动, 而且每一次访问完一条边, 一定会有一条边界向内缩. 循环体里的 4 个 if 用于最终退出. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size() == 0 || matrix[0].size() == 0) return &#123;&#125;; int l = 0; int r = matrix[0].size() - 1; int u = 0; int d = matrix.size() - 1; vector&lt;int&gt; res; while(true)&#123; for(int i = l ; i &lt;= r ; ++ i) res.push_back(matrix[u][i]); if(++ u &gt; d) break; for(int j = u ; j &lt;= d ; ++ j) res.push_back(matrix[j][r]); if(-- r &lt; l) break; for(int i = r ; i &gt;= l ; -- i) res.push_back(matrix[d][i]); if(-- d &lt; u) break; for(int j = d ; j &gt;= u ; -- j) res.push_back(matrix[j][l]); if(++ l &gt; r) break; &#125; return res; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"}]},{"title":"内存管理","slug":"C++/内存管理","date":"2020-12-11T11:13:00.000Z","updated":"2020-12-11T11:18:25.688Z","comments":true,"path":"2020/12/11/C++/内存管理/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/11/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"内存管理 内存管理是一个很深刻的话题, 对于初学者来说, 内存管理看不到摸不着, 我们常使用 new / delete 来管理我们的堆内存. 仅此而已. 本文记录了侯捷老师内存管理课程的学习笔记以及部分自己写的代码. 目的是了解C++如何进行内存管理, 剖析源码, 能够设计自己的内存池. C++中内存管理工具 分配 释放 类型 是否可以重载 malloc() free() C函数 不可以 new delete C++表达式 不可以 ::operator new() ::operator delete() C++函数 可以 allocator&lt;T&gt;::allocate() allocator&lt;T&gt;::deallocate() C++标准库 可自由设计并搭配容器 用法示例 12345678910111213141516171819202122232425262728void* p1 = malloc(512); //512 bytesfree(p1);complex&lt;int&gt;* p2 = new complex&lt;int&gt;; //one objectdelete p2;void* p3 = ::operator new(512); //512 bytes::operator delete(p3);#ifdef __GUNC__ //GNUC 2.9 void* p4 = alloc::allocate(512); alloc::deallocate(p4,512); //得记得当初申请了多少的内存,比较适用于容器#endif/*************************/#ifdef __GNUC__ //GNUC 4.9 //allocate() 和 deallocate() 是 non-static 必须由 object 调用 void* p4 = allocator&lt;int&gt;().allocate(7); //分配7个int的内存大小 allocator&lt;int&gt;().deallocate((int*)p4, 7); //allocate() 和 deallocate() 是 non-static 必须由 object 调用 void* p5 = __gnu_cxx::__pool_alloc&lt;int&gt;().allocate(9); //分配9个int的内存大小 __gnu_cxx::__pool_alloc&lt;int&gt;().deallocate((int*)p5, 9); #endif new 运算符12345678910111213Complex* pc = new Complex(1,2);编译器转换→Complex *pc;try&#123; void* mem = operator new(sizeof(Complex)); //allocate pc = static_cast&lt;Complex*&gt;(mem); //cast pc-&gt;Complex::Complex(1,2); //construct //只有编译器才能够像上式直接调用 ctor&#125; catch (std::bad_alloc) &#123; //allocate 失败, 不执行 ctor&#125; operator new() vc98默认版本123456789101112void * operator new(size_t size, const std::nothrow t&amp;) _THROW0()&#123; //try to allocate size bytes void *p; while((p == malloc(size)) == 0)&#123; //buy more memory or return null pointer _TRY_BEGIN if(_callnewh(size) == 0) break; _CATCH(std::bad_alloc) return 0; _CATCH_END &#125; return (p);&#125; delete 运算符12345678Complex* pc = new Complex(1,2);...delete pc;编译器转换-&gt;pc-&gt;~Complex(); //先析构operator delete(pc); //然后释放内存 operator delete() vc98默认版本1234void __cdecl operator delete(void * p) _THROW0()&#123; //free an allocated object free(p);&#125; array new / array delete1234Complex * pca = new Complex[3];//触发三次ctor...delete [] pca; //触发三次dtor 内存分配的时候, 头部会有 cookie 方便回收. 1234567891011121314int * pi = new int[10];delete pi;vc6 : cookie61h(记录大小是60字节,1表示使用了这一块)Debugger Header(32 Bytes)intintint...intno man landPad(12 Bytes)61h placement new1new (p) 允许我们在已经申请的堆内存上, 构建一个对象. placement new 没有对应的 placement delete, 因为 placement new操作并没有分配内存. 12345678910111213char * buf = new char[sizeof(Complex)*3];Complex * pc = new (buf) Complex(1,2);...delete [] buf;编译器-&gt;Complex * pc;try &#123; void * mem = operator new(sizeof(Complex), buf); //实际上不操作 pc = static_cast&lt;Complex*&gt;(mem); //cast pc-&gt;Complex::Complex(1,2); //construct&#125; C++应用程序分配内存的途径应用程序 12345678910Foo *p = new Foo(x);delete p;编译器-&gt;不可以改变不可以重载Foo *p = (Foo*)operator new(sizeof(Foo));new (p) Foo(x);p-&gt;~Foo();operator delete(x); operator new / operator delete 1234567Foo *p = (Foo*)operator new(sizeof(Foo));调用 -&gt; ::operator new(size_t);调用 -&gt; malloc(size_t);operator delete(x);调用 -&gt; ::operator delete(void*);调用 -&gt; free(void*); 在类中重载 operator new 和 operator delete 12345Foo *p = (Foo*)operator new(sizeof(Foo));重载 Foo::operator new(size_t); -&gt; 调用 ::operator new(size_t);operator delete(x);重载 Foo::operator delete(void*); -&gt; 调用 ::operator delete(void*); C++容器分配内存的途径容器 12345T *p = allocate();construct();destroy();deallocate(p); 分配器 123allocate();deallocate();调用 -&gt; ::operator new or ::operator delete 重载 ::operator new / ::operator delete123456789101112131415161718192021222324252627void * myAlloc(size_t size)&#123; return malloc(size);&#125;void myFree(void * ptr)&#123; return free(ptr);&#125;inline void * operator new(size_t size)&#123; cout &lt;&lt; &quot;global new()&quot; &lt;&lt; endl; return myAlloc(size);&#125;inline void * operator new[](size_t size)&#123; cout &lt;&lt; &quot;global new[]&quot; &lt;&lt; endl; return myAlloc(size);&#125;inline void operator delete(void * ptr)&#123; cout &lt;&lt; &quot;global delete()&quot; &lt;&lt; endl; myFree(ptr);&#125;inline void operator delete[](void * ptr)&#123; cout &lt;&lt; &quot;global delete[]&quot; &lt;&lt; endl; myFree(ptr);&#125; 重载 operator new / operator delete12345678910111213141516171819class Foo &#123;public: /*重载这两个函数应该是 static, 编译器默认*/ void * operator new(size_t); void operator delete(void *, size_t); //第二参数 optional&#125;;Foo *p = new Foo;编译器-&gt;try &#123; void * mem = operator new(sizeof(Foo)); //此处调用类中重载的 operator new p = static_cast&lt;Foo*&gt;(mem); p-&gt;Foo::Foo(1,2);&#125;delete p; //使用 ::delete p; 可以绕过重载的 operator delete编译器-&gt;p-&gt;~Foo();operator delete(p); //此处调用类中重载的 operator delete 重载 placement new / placement delete12345678910111213141516171819202122232425262728293031class Foo &#123; /* 1,2默认版本; 3,4重载版本;*/ void * operator new(size_t size)&#123; // 调用 new Foo return malloc(size); &#125; void * operator new(size_t size, void * start)&#123; // 调用 new (&amp;) Foo return start; &#125; void * operator new(size_t size, long extra)&#123; // 调用 new (100) Foo return malloc(size + extra); &#125; void * operator new(size_t size, long extra, char init)&#123; //调用 new(100,&#x27;a&#x27;) Foo return malloc(size + extra); &#125; /* ** placement new 重载时, 第一参数必须为 size_t ** 否则, [Error] &#x27;operator new&#x27; takes type &#x27;size_t&#x27;(unsigned int) ** as first parameter */ /* ** placement delete 重载时, 不会被 delete 调用 ** 除非 new 的时候抛出异常, 才会去调用对应的重载的 operator delete() */&#125;;","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"内存管理","slug":"内存管理","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"数据结构 - 数组","slug":"HugeFour/DataStructrues/01数组 vector","date":"2020-12-10T11:42:00.000Z","updated":"2020-12-10T11:48:45.201Z","comments":true,"path":"2020/12/10/HugeFour/DataStructrues/01数组 vector/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/10/HugeFour/DataStructrues/01%E6%95%B0%E7%BB%84%20vector/","excerpt":"","text":"数据结构 - 数组该篇是数据结构的开篇. 数据结构学习拟定计划是学习 &lt;&lt;数据结构与算法 C++描述&gt;&gt; by Sartaj Sahni 的同时, 阅读 &lt;&lt;STL源码剖析&gt;&gt; by 侯捷, 完成对应数据结构在STL中的实现. 这一篇主要是 vector 的实现. 数组数组的特性较为简单, 在内存空间中连续, 存储同一类型元素, 查询时间复杂度为O(1), 插入删除时间复杂度为O(n). 数据与数据的关系只有先后关系. vector(未完成)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// linear.c//// Created by OXygen on 2020/12/9.//#include &quot;linear.h&quot;template &lt;typename _Tp&gt;class myvector &#123;protected: typedef _Tp value_type; typedef value_type* pointer; typedef pointer iterator; typedef _Tp&amp; reference;private: iterator start; iterator finish; iterator end_of_storage;public: // Construction &amp; Deconstruction myvector() &#123; start = finish = end_of_storage = nullptr; &#125; myvector(int capacity, value_type initElem = 0) &#123; if(capacity &gt; 0) initalloc(capacity,initElem); &#125; myvector(const myvector&amp; LeftVector) &#123; int size = LeftVector.size(); this-&gt;resize(size); for(int i = 0; i &lt; size ; ++ i)&#123; this[i] = LeftVector[i]; &#125; &#125;// myvector(myvector &amp;&amp; RightVector) noexcept &#123;&#125; ~myvector() &#123; this-&gt;clear(); start = finish = end_of_storage = nullptr; &#125;; // Operations myvector &amp; operator=(const myvector &amp; LeftVector) &#123; if(&amp;LeftVector == this) return *this; if(start != 0)&#123; this-&gt;clear(); &#125; int size = LeftVector.size(); this-&gt;resize(size); for(int i = 0; i &lt; size ; ++ i)&#123; this[i] = LeftVector[i]; &#125; return *this; &#125;// myvector &amp; operator=(myvector &amp;&amp; RightVector) noexcept &#123;&#125; bool operator==(const myvector &amp; LeftVector) &#123; if(&amp;LeftVector == this) return true; if(this-&gt;size() != LeftVector.size()) return false; for(int i = 0 ; i &lt; this-&gt;size() ; ++ i)&#123; if(this[i] != LeftVector[i]) return false; &#125; return true; &#125; bool operator!=(const myvector &amp; LeftVector) &#123; return !operator==(LeftVector); &#125; // Capacity int size() &#123; return (finish - start); &#125; int capacity() &#123; return (end_of_storage - start); &#125; bool empty() &#123; return (this-&gt;size() == 0); &#125; // Visit value_type front() &#123; //empty应该抛出异常 return *begin(); &#125; value_type back() &#123; //empty应该抛出异常 return *(end() - 1); &#125; iterator begin() &#123; return start; &#125; iterator end() &#123; return finish; &#125; // Modifiers void clear() &#123;&#125; void insert(iterator location, value_type InsertElem) &#123;&#125; void erase(iterator location) &#123;&#125; void erase(iterator _begin, iterator _end) &#123;&#125; void push_back(value_type PushElem) &#123;&#125; void emplace_back(value_type PushElem) &#123;&#125; void pop_back() &#123;&#125; void resize() &#123;&#125;private: void initalloc(int capacity, value_type Elem)&#123; start = new value_type[capacity]; iterator it = start; for(int i = 0 ; i &lt; capacity ; ++ i, ++ it) &#123; *it = Elem; &#125; end_of_storage = it + 1; finish = it; &#125; void growalloc()&#123; &#125;&#125;;","categories":[{"name":"vector","slug":"vector","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/vector/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"剑指 Offer 14- I. 剪绳子","slug":"leetcode/offer/剑指Offer 14 I","date":"2020-12-07T13:40:00.000Z","updated":"2020-12-07T13:46:11.673Z","comments":true,"path":"2020/12/07/leetcode/offer/剑指Offer 14 I/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/07/leetcode/offer/%E5%89%91%E6%8C%87Offer%2014%20I/","excerpt":"剑指 Offer 14- I. 剪绳子题目描述剑指 Offer 14- I. 剪绳子 难度:中等 描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]*k[1]*…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。","text":"剑指 Offer 14- I. 剪绳子题目描述剑指 Offer 14- I. 剪绳子 难度:中等 描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]*k[1]*…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1234567输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 解法这样的题目, 适合先枚举多个例子找规律. 我们枚举到6,7,8的时候, 应该可以感受到, 每个数需要尽量地拆分多的数字3, 但是最终拆分剩下4的时候, 需要转换成2+2. 我们不需要循环地去重复 : n -= 3 和 res *= 3 , 因为, 这样的循环可以计算出运算的次数. 使用count = n / 3 得知以上的循环会进行多少次, count % 3 得知以上的循环会剩下什么数. 如果剩下的数字是 1 说明我们把4拆分成了3+1, 所以回退一步, 结果为pow(3, count - 1) * 4 如果剩下的数字是 0 说明这个数字n可以全部拆分成3, 所以结果为pow(3, count) 如果剩下的数字是 2 说明结果为pow(3, count) * 2 123456789101112131415161718192021class Solution &#123;public: int cuttingRope(int n) &#123; /* 2 : 1 + 1 -&gt; 1 3 : 2 + 1 4 : 2 + 2 5 : 3 + 2 6 : 3 + 3 7 : 3 + 2 + 2 8 : 3 + 3 + 2 */ if( n == 2 || n == 3) return (n - 1); int count = n / 3; int rest = n % 3; return (rest == 1) ? pow(3, count - 1) * 4 : (rest == 0) ? pow(3, count) : rest * pow(3, count); &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"}]},{"title":"2020.12.07 861. 翻转矩阵后的得分","slug":"leetcode/daily/861. 翻转矩阵后的得分","date":"2020-12-07T13:00:00.000Z","updated":"2020-12-07T13:21:15.728Z","comments":true,"path":"2020/12/07/leetcode/daily/861. 翻转矩阵后的得分/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/07/leetcode/daily/861.%20%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/","excerpt":"861. 翻转矩阵后的得分题目描述861. 翻转矩阵后的得分 难度:中等 描述 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。 在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。 返回尽可能高的分数。","text":"861. 翻转矩阵后的得分题目描述861. 翻转矩阵后的得分 难度:中等 描述 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。 在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。 返回尽可能高的分数。 示例 12345678910输入 : [[0,0,1,1],[1,0,1,0],[1,1,0,0]]输出 : 39解释 :转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39提示 :1 &lt;= A.length &lt;= 201 &lt;= A[0].length &lt;= 20A[i][j] 是 0 或 1 解法首先, 16一定比8大. 也就是说, 最高位的b1一定比低位的b1表示的数字要大. 因此, 可以通过反转行, 来使得最高位是b1. 其次, 行已经达到最优的情况, 该反转列了, 列的反转结果会导致b0和b1的数量交换, 因此, 如果一列上b1的数量大于b0时, 不需要反转, 否则反转. 经过行列反转后, 达到最优解. 计算结果. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int matrixScore(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int m = A.size(); if(m == 0) return 0; int n = A[0].size(); // 反转行 for(int i = 0 ; i &lt; m ; ++ i)&#123; if(A[i][0] == 0)&#123; //首位是0才需要行反转 for(int j = 0 ; j &lt; n ; ++ j)&#123; A[i][j] = A[i][j] == 0 ? 1 : 0; &#125; &#125; &#125; // 反转列 int mid = (m + 1) / 2; int count = 0; for(int j = 0 ; j &lt; n ; ++ j)&#123; count = 0; for(int i = 0 ; i &lt; m ; ++ i)&#123; count += A[i][j]; &#125; if(count &lt; mid)&#123; //1的数量小于一半时才需要列反转 for(int i = 0 ; i &lt; m ; ++ i) A[i][j] = A[i][j] == 0 ? 1 : 0; &#125; &#125; // 计算 int res = 0; for(int i = 0 ; i &lt; m ; ++ i)&#123; for(int j = 0 ; j &lt; n ; ++ j)&#123; res += A[i][j] * pow(2, n - 1 - j); &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"每日一题","slug":"Leetcode/每日一题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"}]},{"title":"仓库介绍","slug":"github/仓库介绍","date":"2020-11-24T06:56:00.000Z","updated":"2020-11-24T14:06:41.085Z","comments":true,"path":"2020/11/24/github/仓库介绍/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/24/github/%E4%BB%93%E5%BA%93%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"深入理解操作系统课程学习 - 清华大学 记录清华大学深入理解操作系统课程学习的笔记","categories":[{"name":"github","slug":"github","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/github/"}]},{"title":"深入理解计算机网络","slug":"HugeFour/Network/Deep_into_Network","date":"2020-11-23T11:20:00.000Z","updated":"2020-12-06T13:31:13.039Z","comments":true,"path":"2020/11/23/HugeFour/Network/Deep_into_Network/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/23/HugeFour/Network/Deep_into_Network/","excerpt":"计算机网络学习本文章记录着小劳的计算机网络学习, 从2020.11.22开始学习, 目标能够掌握概念, 对网络编程有一个偏底层的理解. 学习自韩立刚老师的b站课程. 传送门 : b站 韩立刚 计算机网络","text":"计算机网络学习本文章记录着小劳的计算机网络学习, 从2020.11.22开始学习, 目标能够掌握概念, 对网络编程有一个偏底层的理解. 学习自韩立刚老师的b站课程. 传送门 : b站 韩立刚 计算机网络 custom 计算机网络 第一章 计算机网络第一章的主要内容是 : 概述 课程安排第一章 : 概述 第二章 : 物理层 第三章 : 数据链路层 第四章 : 网络层 第五章 : 运输层 第六章 : 应用层 第七章 : 网络安全 第八章 : 因特网上的音频,视频服务 第九章 : 无线网络 第十章 : 下一代因特网 计算机网络在信息时代的作用21世纪的特征 : 数字化, 网络化, 信息化 网络化 : 三网(电信网络, 计算机网络, 有线电视网络) 计算机网络 : 因特网, 其他网络(政府网络, 军用网络) 计算机网络的重要功能连通性 : 彼此联通, 交换信息 共享 : 信息共享, 软硬件共享(软 : ssh ; 硬 : 打印机等设备) 因特网概述终端到网络(路由器)的距离大约是100米, 路由器与路由器的连接扩展了网络的距离和接入网设备的数量. 概念网络 : 许多计算机连接在一起 互联网 : 许多网络连接在一起 (internet) 因特网 : 全球最大的一个互联网 (Internet, 使用 TCP/IP 协议) 因特网发展的三个阶段1st : ARPANET向互联网发展 (上世纪60年代 - 80 年代中期) 1969年 分组交换网 1975年 互联网 1983年 TCP/IP (因特网起源) 2nd : 三级结构的因特网 (上世纪80年代中期 - 90 年代初期) 分层次, 比如 : 学校网 - 区域网 - 主干网(带宽 : 45 M) 3rd : 多层次ISP结构的因特网 ISP : Internet Service Provider 因特网服务提供商 第一层ISP - 第二层ISP - 第三层ISP(提供接入) - 校园网等 如果服务器需要提供的客户范围较小, 应该接入越低层的ISP 因特网的标准化工作因特网协会 : ISOC 因特网体系结构委员会 IAB : 因特网研究部 IRTF : 因特网研究指导小组 IRSG 因特网工程部 IETF : 因特网工程指导小组 IESG 因特网的组成因特网的核心部分 因特网的边缘部分 主机之间的通信方式 : 客户端服务器方式 (Client / Server 方式) 对等方式 (Peer-to-Peer 方式) 数据交换方式 : 电路交换 (Circuit Switching) 交换机同时只能提供网络中的两个终端通信 过程 : 申请占用通信资源, 一直占用通信资源, 释放通信资源 适用于 : 实时性通信, 核心路由器之间可以使用电路交换 报文交换 (Message Switching) 报文一般比分组长的多 报文交换的时延较长 分组交换 (Packet Switching) 完整的一个数据包称为报文, 需要分为多个组进行发送 每一个分组带上一个首部 分组的优势在于, 通信时路径可以复用 接收端去电首部后, 拼接分组成报文 路由器有存储转发功能 优点 : 高效, 灵活, 迅速, 可靠 问题 : 时延, 开销 计算机在我国的发展中国在1994年4月20日正式接入互联网. 计算机网络的类别计算机网络最简单的定义 : 一些互相连接的, 自治的计算机的集合 作用范围(使用的技术) : 广域网 : WAN (花钱买服务, 花钱买带宽 城域网 : MAN 局域网 : LAN (自己购买设备, 带宽固定, 自己维护, 距离100米之内) 使用者 : 公用网, 专用网 拓扑结构 : 总线型, 环型, 星型, 树型, 网状 交换方式 : 电路交换, 报文交换, 分组交换 工作方式 : 资源子网, 通信子网, 接入网 计算机网络的性能以下5点是性能指标 : 速率速率是指连接在计算机网络上的主机在数字信道上传送数据位数的速率, 也称为 data rate 或者 bit rate. 单位是 b/s kb/s Mb/s Gb/s 一般来说, 运营商告诉的100M是指100Mbps, 转换成下行速率是 100 / 8 = 12.5 Mbit / s 带宽带宽是指数据通信领域中, 数字信道所能传送的最高速率 吞吐量吞吐量是指在单位时间内通过某个网络的数据量 时延时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 发送时延 = 数据块长度(比特) / 信道带宽(比特/秒) 传播时延 = 信道长度(米) / 信号在信道上的传播速率(米/秒) 处理时延 = 网络节点存储转发处理时间 排队时延 = 网络节点缓存队列排队时间 利用率信道利用率 = 有数据通过时间 / (有 + 无) 数据通过时间 网络利用率 = 信道利用率加权平均值 D = D0 / (1 - U) [D0 : 网络空闲时延 D : 网络当前时延 U : 信道利用率] 以下7点是非性能指标 : 费用, 质量, 标准化, 可靠性, 可扩展性, 可升级性, 管理与维护 计算机网络的体系机构概念ISO : 国际标准化组织 OSI/RM : 互联网法律上的国际标准 TCP/IP Suite : 因特网事实上的国际标准 Network Protocols : 数据交换遵守的规则, 标准或约定 网络体系结构 : 计算机网络各层及协议的集合 OSI 参考模型OSI 是七层模型 : ​ 应用层 - 能够产生网络流量, 能够和用户交互的应用程序 ​ 表示层 - 加密, 压缩, 编解码 (开发人员考虑) ​ 会话层 - 服务和客户端建立的会话 查木马 netstat -nb | more ​ 传输层 - 可靠传输建立会话, 不可靠传输不建立会话(QQ发消息, DNS解析), 流量控制 ​ 网络层 - IP地址编址 选择最佳路径 动态路由 ​ 链路层 - 数据如何封装 为数据包添加物理层地址(MAC地址) ​ 物理层 - 电压 接口标准 分层的作用 : 1.标准化 ; 2.降低耦合度 开发者考虑应用层到会话层, 网络工程师考虑传输层到链路层 网络排错 : 从底层往上检查(比如 : 先看网线, IP, 浏览器检查) 网络安全和OSI参考模型 : ​ 物理层安全 - 给别人提供了接入网络的机会 ​ 链路层安全 - ADSL密码, 无线网卡密码 ​ 网络层安全 - 网关设置内网中某些网段可以访问外网, 某一些不可以 ​ 应用层安全 - SQL注入漏洞, 上传漏洞(文件类型检查) TCP/IP模型TCP/IP 是五层模型 : ​ 应用层 ​ 传输层 ​ 网络层 ​ 链路层 ​ 物理层 开放系统信息交换涉及的概念 : 实体 : 交换信息的硬件和软件的进程 协议 : 控制两个对等实体通信的规则 服务 : 下层向上层提供服务, 上层需要使用下层提供的服务来实现本层的功能 服务访问点 : 相邻两层实体间交换信息的地方 TCP/IP 模型的数据单元 : ​ 应用层 - 传输数据单元 PDU ​ 运输层 - 运输层报文 ​ 网络层 - IP数据报(IP分组) ​ 数据链路层 - 数据帧 ​ 物理层 - bits 计算机网络 第二章由于是物理层, 暂时先跳过学习 计算机网络 第三章 第三章的主要内容是 : 数据链路层 数据链路层基本概念及基本问题基本概念数据发送模型 : 主机1 - 电话网 - 路由器1 - 局域网 - 路由器2 - 广域网 - 路由器3 - 局域网 - 主机2. 在路由器上数据上升到网络层, 再进行转发. 数据链路层的信道类型 : 点对点信道 广播信道 链路与数据链路 : 链路 (link) 是一条点对点的物理线路段 数据链路 (data link) 除了物理线路外, 还必须有通信协议来控制这些数据的传输 帧 : 链路层传输的数据单元 获得网络层的数据报增加帧头和帧尾, 传递给物理层 三个基本问题 封装成帧(一定要知道哪里开始哪里结束) 封装成帧就是在一段数据的前后分别添加首部和尾部, 然后就构成一个帧, 确定帧的边界. 首部和尾部的一个重要作用就是进行帧定界. 帧的数据部分长度最大为1500字节. 帧首部和帧尾部定界的作用 : 确保数据的完整性 透明传输(数据中存在开始和结束的标识, 进行转变) 在帧数据部分出现了SOH帧首部或EOT帧尾部内容, 会出现提前结束. 解决方法 : 发送端的数据链路层在数据中出现控制字符”SOH”或者”EOT”的前面插入转义字符”ESC”(十六进制编码为1B). 字节填充或字符填充——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符. 如果转义字符也出现在数据中, 那么应该在转义字符前插入一个转义字符. 当接收端收到连续的两个转义字符时, 就删除前面一个. 差错控制(检查帧的正确性) 传输过程中可能会产生比特差错 : 1 可能会变成 0 , 0 可能会变成 1. 在一段时间内, 传输错误的比特占所传输比特总数的比率称为误码率 BER (bit error rate). 误码率与信噪比有很大的关系. 为了保证数据传输的可靠性, 在计算机网络传输数据时, 必须采用各种差错检测措施. 循环冗余检验 CRC : 在数据链路层传送的帧中, 广泛使用了 CRC 的技术. 在发送端, 先把数据划分为组. 假定每组为 k 个比特 假设待传送的一组数据 M = 101001 (k = 6), 我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送. 101001 - 000 (增加3位0, 要求除数是4位) / 1101 = 001 (FCS) , 把001加在101001后面, 组成 101001001 , 接收方除以相同的四位数 1101, 如果最终结果是 0 , 说明没有出错. 这个四位数 1101 或者更多位的数, 是链路层保证双方相同的. 链路层的差错控制, 是无差错接收, 只接受没有比特差错的情况, 不需要重传.(重传是传输层的要求) 帧检验序列 FCS : 在数据后面添加上的冗余码称为帧检验序列 FCS. 循环冗余检验 CRC 和帧检验序列 FCS 并不等同. (CRC 不是获得 FCS 的唯一途径) 两种情况下的数据链路层使用点对点信道的数据链路层PPP协议( Pointer-to-Pointer Protocol) 用户使用拨号电话线接入因特网的时候, 一般都是使用PPP协议. 具有拨号, 身份验证, 可以记账的特性. PPP协议应该满足的要求 : 简单, 封装成帧, 透明性, 多层网络层协议, 多种类型链路, 差错检测, 检测连接状态, 最大传送单元, 网络层地址协商, 数据压缩协商. PPP协议不需要满足的要求 : 纠错, 流量控制, 序号, 多点线路, 半双工或单工链路. PPP协议的组成 : 数据链路层协议可以用于异步串行或同步串行介质. 它使用LCP(链路控制协议)建立并维护数据链路连接. 网络控制协议(NCP)允许在点到点连接上使用多种网络层协议. |3. 上层协议 : IP IPX AppleTalk | |2. 网络控制协议 NCP 针对每一个网络层协议 | |2. 链路控制协议 LCP | |2. 高级数据链路控制协议 HDLC | |1. 物理层 | PPP协议帧格式 : 首部 : | F{1} | A{1} | C{1} | 协议{2} | . 其中, A,C = FF,03 是固定的. 一般 首部和尾部的 : F(=7E) 协议{2} : 0x0021 - PPP帧的信息字段就是IP数据报 0xC021 - 信息字段是PPP链路控制数据 0x8021 - 网络控制数据 0xC023 - 安全性认证PAP 0xC025 - LQR 0xC223 - 安全性认证CHAP 数据部分 : IP数据报不超过1500字节. 尾部 : | FCS{2} | F{1} | . PPP协议的头尾的 F(=7E) 字段相同. 使用PPP协议以字节为单位还是以比特为单位发送数据时, 填充方案不相同, 具体如下 : 字节填充 : 信息字段出现标志字段的值的问题 : 信息字段的 0x7E 被拆分称为0x7D 0x5E, 信息字段的 0x7D 被拆分成0x7D 0x5D, ASCII 控制符(数值小于0x20)前加一个 0x7D 字节.(因此实际传输的信息可能是达不到1500字节) 零比特填充方法 : 避免出现和 0x7E 一样的比特序列, 0111,1110, 因此连续5个1补一个0 PPP协议用在SONET/SDH链路时, 是使用同步传输一连串的比特连续传送). 这时, PPP协议采用零比特填充方法来实现透明传输. 在发送端, 只要连续发现5个连续的1, 就立即填充一个0. 接收端扫描时, 5个连续的1后删除1个0.(可以用于避免0x7E的出现) PPP协议的工作状态 : 当用户拨号接入ISP时, 路由器的调制解调器对拨号做出确认, 并建立一条物理连接. PC机向路由器发送一系列的LCP分组(封装成多个PPP帧). 这些分组及其响应选择一些PPP参数, 和进行网络层配置, NCP给新接入的PC机分配一个临时的IP地址, 使PC机称为因特网上的一个主机. 通信完毕时, NCP释放网络层连接, 收回原来分配出去的IP地址. 接着, LCP释放数据链路层连接. 最后释放的是物理层连接. 使用广播信道的数据链路层补充知识 : 局域网的特定与优点 局域网最主要的特点是 : 网络为一个单位所拥有, 且地理范围和结点数目均有限. 局域网具有如下的一些主要优点 : 具有广播功能, 从一个站点可以很方便地访问全网. 局域网上的主机可以共享连接在局域网上的各种硬件和软件资源. 便于系统的扩展和逐渐地演变, 各设备的位置可灵活调整和改变. 提高了系统的可靠性, 可用性和生存性. 共享通信媒体 静态划分信道 : 频分复用, 时分复用, 波分复用, 码分复用. 动态媒体接入控制(多点接入) : 随机接入(被以太网采用), 受控接入(已不被采用) 认识以太网 最初的以太网是将许多计算机都连接在一根总线上. 当初认为这样的链接方式既简单又可靠, 因为总线上没有有源器件. 问题是, 同时只有一个设备发送数据, 而且所有的设备都可以接收到数据包, 不够安全. 以太网协议 : 以太网使用的是CSMA/CD协议 (带冲突检测的多点接入技术) 多点接入 : 表示许多计算机以多点接入的方式连接在一根总线上 载波监听 : 是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据, 如果有, 则暂时不要发送数据, 以免碰撞. (P35 以太网的冲突检测暂时跳过) 以太局域网以太网的两个标准 : DIX Ethernet V2 是世界上第一个局域网产品(以太网)的规约. IEEE 的 802.3 标准. 以太网与数据链路层的两个子层 : 为了使数据链路层能更好地适应多种局域网标准, 802 委员会就将局域网的数据链路层拆成两个子层 : 逻辑链路控制 LLC 子层 媒体接入控制 MAC 子层 以太网提供的服务 : 以太网提供的服务是不可靠的交付, 即尽最大努力的交付. 当接收站收到有差错的数据帧时就丢弃此帧, 其他什么都不做. 差错的纠正由高层来决定. 如果高层发现丢弃一些数据而进行重传, 但以太网并不知道这是一个重传的帧, 而是当做一个新的数据帧来发送. (集线器部分暂时跳过) 以太网的信道利用率 : 以太网的信道被占用的情况 : 争用期长度为 2tao , 即端到端传播时延的两倍. 检测到碰撞后不发送干扰信号. 帧长为 L (bit) , 数据发送速率为 C (b/s) , 因而帧的发送时间为 L/C = T0 (s) 信道利用率的最大值 : 各站发送数据都不发生碰撞的话, Smax = T0 / (T0 + tao) MAC层 : 在局域网中, 硬件地址又称为物理地址, 或 MAC 地址. MAC地址一共是48位二进制位, 其中高24位为厂家地址段, 低24位由厂家自行指派. 适配器检查MAC地址 : 适配器从网络上每收到一个MAC帧就首先用硬件检查MAC帧中的MAC地址 : 如果是发送往本站的帧则手下, 然后再进行其他的处理. 否则就将此帧丢弃, 不再进行其他的处理. “发往本站的帧” 包括以下三种类型的帧 : 单播帧 (一对一) 广播帧 (一对全体) (MAC地址全1) 多播帧 (一对多) 以太网帧格式 : MAC帧 : | 目的地址{6} | 源地址{6} | 类型{2} | IP数据报{46 - 1500} | FCS{4} | 最短是64字节 物理层 : | 前同步码{7} | 帧开始定界符{1} | MAC帧 | 无效的MAC帧 : 帧的长度不是整数个字节; 用收到的帧检验序列 FCS 查出有差错; 数据字段的长度不在 46 ~ 1500 字节之间; 有效的MAC帧长度为 64 ~ 1518 字节之间; 对于检查出的无效的MAC帧就简单地丢弃. 以太网不负责重传丢弃的帧. 帧间最小间隔 : 帧间最小间隔为 9.6 us , 相当于 96 bit 的发送时间. 一个站在检测到总线开始空闲时, 还要等待 9.6 us 才能再次发送数据. 这样做是为了使刚刚收到的数据帧的站的接收缓存来得及清理, 做好接收下一帧的准备. 扩展以太网集线器扩展 : 主机使用光纤和一对光纤调制解调器连接到集线器. 使用集线器连接最好低于30台机器, 冲突域变少, 冲突增大. 网桥扩展 : 在一个较小的冲突域里收发数据, 网桥不会转发到其他冲突域中, 可以减少冲突. 网桥有自学习算法并且建立转发表. 透明网桥使用了生成树算法 : 为了避免产生转发的帧在网络中不断地兜圈子. 交换机(多接口的高速网桥)扩展 : 安全, 效率高, 10M的交换机指的是每一个端口都是10M, 每一个端口都是全双工 交换机学习到的转发表格式 : | Vlan | Mac Address | Type | Ports | 虚拟局域网LAN和VLAN : 交换机的使用使得VLAN的创建成为可能. 虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组. 这些网段具有某些共同的需求. 每一个 VLAN 的帧都有一个明确的标识符, 指明发送这个帧的工作站是属于哪一个 VLAN. 虚拟局域网其实只是局域网给用户提供的一种服务, 而不是一种新型局域网. 一个 VLAN = 一个广播域 = 逻辑网段(子网) ISL 标记(思科方式) : ISL 干道使 VLAN 能够跨骨干 通过特定集成电路来实现 不需要再客户计算机上采取配置, 客户机不能够看到ISL头 在交换机之间, 路由器和交换机, 交换机和支持ISL网卡的服务器之间配置 ISL 封装 : | DA | Type | User | SA | LEN | AAAA03 | HSA | VLAN | BPDU | INDEX | RES | 以太网帧 | CRC | 虚拟局域网帧格式 : 虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符, 称为 VLAN 标记 (tag) , 用来指明发送该帧的工作站属于哪一个虚拟局域网. 格式 : | 目的地址{6} | 源地址{6} | VLAN标记{4} | 类型{2} | 数据{46 ~ 1500} | FCS{4} | 高速以太网速率达到或超过 100 Mb/s 的以太网称为高速以太网. 100BASE-T 以太网 : 可以全双工方式下工作而无冲突发生. 因此, 不使用 CSMA/CD 协议. MAC帧格式仍然是 802.3 标准规定的. 帧间时间间隔从 9.6 us 变成了 0.96 us. 吉比特以太网 : 允许在1 Gb/s 下全双工和半双工两种方式工作. 使用 802.3 协议规定的帧格式. 在半双工方式下使用 CSMA/CD 协议, 全双工不需要. 与 10BASE-T 和 100BASE-T 技术向后兼容. 10吉比特以太网 : 以太网的工作范围已经从局域网(校园网, 企业网)扩大到城域网和广域网, 从而实现了端到端的以太网传输. 这种工作方式的好处是 : 成熟的技术, 互操作性好, 在广域网中使用以太网时价格便宜, 统一的帧格式简化了操作和管理. Cisco建网3层模型普通的交换机 : 连接计算机, 需要接口数量多 汇聚层交换机 : 连接普通的交换机, 一般单位是整栋楼 核心层交换机 : 连接汇聚层交换机, 一般单位是一个一个区域 交换机安全交换机可以设置某一个端口只能和指定的MAC地址的主机交换数据, 保证链路层安全. 也可以设置某个端口只能连接一台计算机. 否则, 关闭端口. 计算机网络 第四章 第四章的主要内容是 : 网络层 网络层提供的两种服务网络层关注的是如何将分组从源端沿着网络路径送达目的端. 两种服务 : 虚电路服务 数据报服务 虚电路(专线,固定. 不需要写IP地址)虚电路表示这是一条逻辑上的连接, 分组都沿着这条逻辑连接按照存储转发方式传送, 而并不是真正建立了一条物理连接. 电路交换的电话通信是先建立一条真正的连接. 因此分组交换的虚连接和电路交换的连接只是类似, 并不完全一样. 数据报(灵活,低耦合. 需要写IP地址)网络层向上只提供简单灵活的, 无连接的, 尽最大努力交付的数据报服务. 网络在发送分组时不需要先建立连接. 每一个分组(IP数据报)独立发送, 与其前后的分组无关. 网络层不提供服务质量的承诺. 即所传送的分组可能出错, 丢失, 重复和失序, 当然也不保证分组传送的时限. 尽最大努力交付的好处 : 由于传输网络不提供端到端的可靠传输服务, 这就使网络中的路由器可以做的比较简单, 而且价格低廉. 如果主机中的进程通信需要是可靠的, 那么就由网络的主机中的运输层负责(包括差错处理, 流量控制等). 采用这种设计思路的好处是 : 网络的造价大大降低, 运行方式灵活, 能够适应多种应用. 因特网能够发展到今日的规模, 充分证明了当初采用这种设计思路的正确性. 虚电路服务和数据报服务的比较虚电路 思路 : 可靠通信应当由网络来保证 连接的建立 : 必须有 终点地址 : 仅在连接建立阶段使用, 每个分组使用短的虚电路号 分组的转发 : 属于同一条虚电路的分组均按照同一路由进行转发 当结点出故障时 : 所有通过出故障的结点的虚电路均不能工作 分组的顺序 : 总是按发送顺序到达终点 端到端的差错处理和流量控制 : 可以由网络负责, 也可以由用户主机负责 数据报 思路 : 可靠通信应当由用户主机来保证 连接的建立 : 不需要 终点地址 : 每个分组都有终点的完整地址 分组的转发 : 每个分组独立选择路由进行转发 当结点出故障时 : 由故障的结点可能会丢失分组, 一些路由可能会发生变化 分组的顺序 : 到达终点时不一定按发送顺序 端到端的差错处理和流量控制 : 由用户主机负责 网际协议 IP虚拟互联网网络互连的设备 中间设备又称为中间系统或者中继系统. 物理层中继系统 : 转发器 或者 集线器 数据链路层中继系统 : 网桥 或者 交换机 网络层中继系统 : 路由器 网络层以上的中继系统 : 网关 当中继系统是集线器或网桥时, 一般不称为网络互连, 因为这仅仅是把一个网络扩大了, 而这仍然是一个网络. 网关由于比较复杂, 目前使用的较少. 互联网都是指用路由器进行互连的网络. 由于历史原因, 许多有关 TCP/IP 的文献将网络层使用的路由器称为网关. 网络互联的问题 互联在一起的网络要进行通信, 会遇到许多问题需要解决, 如 : 不同的寻址方案, 不同的最大分组长度, 不同的网络接入机制, 不同的超时控制, 不同的差错恢复方法, 不同的状态报告方法, 不同的路由选择技术, 不同的用户接入控制, 不同的服务, 不同的管理与控制方式. IP协议简介 网际协议IP 是 TCP/IP 体系中两个最主要的协议之一. 与 IP协议配合使用的还有四个协议 : 地址解析协议 ARP (Address Resolution Protocol) 逆地址解析协议 RARP (Reserve Address Resolution Protocol) 网际控制报文协议 ICMP (Internet Control Message Protocol) 网际组管理协议 IGMP (Internet Group Management Protocol) IP地址IP层次结构 层次化IP地址 : 层次化IP地址将32位的IP地址分为网络ID和主机ID 网络地址 网络地址唯一指定了每一个网络. 同一网络中的每台计算机都共享相同的网络地址, 并用它作为自己IP地址的一部分. A类地址 : 8位网络号 (net-id : 0…….) 最大网络数 126 第一个可用的网络号 1 最后一个可用的网络号 127 每个网络的最大主机数 16777214 B类地址 : 16位网络号(net-id : 10…… ……..) 最大网络数 16383 第一个可用的网络号 128.1 最后一个可用的网络号 191.255 每个网络的最大主机数 65534 C类地址 : 24位网络号(net-id : 110….. …….. ………) 最大网络数 2097151 第一个可用的网络号 192.0.1 最后一个可用的网络号 223.255.255 每个网络的最大主机数 254 D类地址 : 组播 (1110 28.) E类地址 : 研究 (1111 28.) 特殊的几个地址 : **** 127.0.0.1 本地回环地址 169.254.0.0 无法自动分配地址时,分配这个网段 RFC1918指明的专用地址(private address): 10.0.0.0 - 10.255.255.255 172.16.0.0 - 172.31.255.255 192.168.0.0 - 192.168.255.255 子网掩码 子网掩码的作用是确定IP地址的网络号的位数. 划分子网和构造超网划分子网 划分子网可以让一个网络号继续拆分出多个子网, 使得使用更加地充分. 比如, 一个C类地址的网络号是24位, 可以容纳254台主机, 可以进一步使用第25位主机号用于子网络号, 拆分126台和126台主机的两个子网.同时, 子网掩码也要往后移动一位. 划分四个子网时, 取2位作为子网络号, 因此可以用的主机号范围是 : A: (0网络) 1 - 62 (63广播) B: 65 - 126 C: 129 - 190 D: 192 - 254 网关是主机号为1的IP地址, 是路由器的出口IP地址. 广播是主机号为最大的IP地址. 最小划分到, 网络号为24位,子网络号为6位,主机号为2位: 00网络,01网关,02主机,03广播. 构造超网 将网络号左移若干位, 可以构造超网. IP地址与硬件地址使用IP地址通信, 而不是直接使用MAC地址通信, 是因为, IP地址可以确定源地址和目标地址, 而MAC地址在每一次转发的时候都需要改变. 除非没有网络层设备, 所有主机全部使用超大的交换机相连, 每一次广播都可以得知目标MAC地址的主机进行转发. ARP协议 IP地址 → ARP → MAC地址 ARP欺骗: 在同一个网段里的计算机在需要知道一个IP地址的MAC地址时,会进行广播, 这个时候本应只有网关会回复你, 但是有其他主机告诉你MAC地址的话, 你就会受到ARP欺骗, 他把他自己作为”网关”, 可以控制每一个主机的带宽. RARP协议 MAC地址 → RARP → IP地址(地址请求的过程) IP数据报格式首部{20} | 数据部分 首部{20} : | 版本{4b} | 首部长度{4b} | 区分服务{1} | 总长度{2} | | 标识{2} | 标志{3b} | 片偏移{29b} | | 生存时间{1} | 协议{1} | 首部检验和{2} | | 源地址{4} | | 目的地址{4} | 可变部分 : | 可选字段 | 填充至4字节的整数倍 | | 数据部分 | 版本 : 4位,指定IP协议版本(IPv4, IPv6) 首部长度 : 4位,除数据部分以外的首部有多长(4位能够表示0-15,一个数代表4个字节,因此最大值为60字节) 区分服务 : 8位,只有使用区分服务,该字段才起作用. 总长度 : 16位,首部和数据之和的长度.(因此最大值为65535字节,不能超过最大传送单元MTU) 标识 : 16位,计数器,用来产生数据报的标识,不是序号,每产生一个数据包+1 标志 : 3位,目前只有前两位有意义,标志字段的最低位是MF.MF=1标识后面还有分片,MF=0标识后面没有分片.标识字段中间位是DF,只有DF=0才允许分片. 片偏移 : 13位,较长的分组在分片后,某片在原分组中的相对位置,片偏移以8个字节为偏移单位.比如1400/8 = 175 生存时间 : 8位,记为TTL,经过路由器的C++最大跳数 协议 : 8位,标记数据报携带的数据使用的协议 首部校验和 : 16位,用于检错,反码算术运算求和 可变部分 : 支持排错,测量以及安全等措施,1字节-40字节,很少被用到. IP转发分组的流程数据路由: 路由器在不同网段转发数据报 网络畅通的条件: 能去能回,沿途的路由器都必须知道到源地址和目标地址网络下一跳给哪个接口 网际控制报文协议 ICMPICMP简介为了提高IP数据报交付成功的机会,在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol) ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告 ICMP不是高层协议,而是IP层协议 ICMP报文作为IP层数据报的数据,加上数据报的首部,组成IP数据报发送出去. ICMP种类ICMP报文的种类有两种,即ICMP差错报告报文和ICMP询问报文. ICMP的前4个字节是统一的格式,共有三个字段: 即类型,代码和检验和.接着的4个字节的内容与ICMP的类型有关. 差错报告报文(ping指令收到的是差错报告) 有五种: 终点不可达,源点抑制,时间超过,参数问题,改变路由(重定向) 询问报文(ping指令发送的是询问) 有两种: 回送请求和回答报文,时间戳请求和回答报文 ping的过程A —ping—&gt; B A 创建一个数据报, 格式如: | IP数据报首部 | 8字节 | IP数据报的数据字段(前面的8字节也属于IP数据报数据) | B 收到ICMP询问报文后, 丢弃8字节以外的IP数据报的数据字段,组装ICMP的前8字节, 格式如: | 首部 | ICMP前8字节 | IP数据报首部 | 8字节 | 再发送给 A 因特网的路由选择协议RIP动态路由协议RIP协议最早, 每30秒周期性地广播, 每一个目的地告诉相邻路由器0跳能到自己,路由器告诉相邻路由器1跳能到,然后不断地告诉其他路由器,如果某一条路径断开,30秒之后又能重新选择到一条通路.(依据跳数不一定是最佳路径,有一些跳数大的路径带宽大) OSPF内部网关协议向本自治系统中所有路由器发送信息,这里使用的方法是洪泛法. 发送的信息就是与本路由器相邻的所有路由器的链路状态, 但这是路由器所知道的部分信息. 只有当链路状态发生变化时,路由器才用洪泛法向所有路由器发送此信息. 相比RIP协议,OSPF是触发式更新路由表. OSPF维护三个表: 邻居表 hello包(局域网2s一次) 链路状态表 互相交换邻居表,构造网络拓扑图 计算路由表 迪杰斯特拉算法来计算最短路径,路径值是带宽 BGP外部网关协议BGP是不同自治系统的路由器之间交换路由信息的协议.边界网关协议BGP只能是力求寻找一条能够到达目的网络且较好的路由(不能成环),而非寻找一条最佳的路径.每一个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人. 虚拟专用网 VPNVPN: 在互联网上传输私网数据, 因为私网数据不能在广域网上传输,所以在数据报前面再增加一个目标网络网关的目标地址和自己的网关源地址. 目标网关获得数据报之后解析得到一个数据报,目标地址是私网中的某个主机. 例如: 局域网数据报: | 10.0.0.2 | 10.0.0.8 | 数据 | 广域网数据报: | 23.23.2.2 | 23.23.2.20 | 10.0.0.2 | 10.0.0.8 | 数据 | 网络地址转换 NAT1994年提出. 需要在专用网连接到因特网的路由器上安装NAT软件. 装有NAT软件的路由器叫做NAT路由器.它至少有一个有效的外部全球地址IPg. 所有使用本地地址的主机和外界通信时都要在NAT路由器上将其本地地址转换成IPg才能和因特网连接. 私网里的IP和端口号都被NAT路由器进行了转换,端口使用的是NAT的端口,存储一张IP与端口映射表即可.","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"剑指 Offer 13. 机器人的运动范围","slug":"leetcode/offer/剑指Offer 13","date":"2020-11-20T13:30:00.000Z","updated":"2020-11-24T13:49:51.688Z","comments":true,"path":"2020/11/20/leetcode/offer/剑指Offer 13/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/20/leetcode/offer/%E5%89%91%E6%8C%87Offer%2013/","excerpt":"剑指 Offer 13. 机器人的运动范围题目描述剑指 Offer 13. 机器人的运动范围 难度:中等 描述 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？","text":"剑指 Offer 13. 机器人的运动范围题目描述剑指 Offer 13. 机器人的运动范围 难度:中等 描述 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 123456789输入：m = 2, n = 3, k = 1输出：3输入：m = 3, n = 1, k = 0输出：1限制:1 &lt;= n,m &lt;= 1000 &lt;= k &lt;= 20 解法机器人的运动范围虽然是在一个左上顶点为[0,0], 右下顶点为[m-1,n-1]的矩形中运动, 但是机器人必须从[0,0]出发, 也就是说虽然有一些点是符合各数位之和小于 k 的, 但是机器人不可达就不应该计算在内. 这里, 我直接把所有符合要求的点全部记录在一个二维数组中, 然后通过 dfs 来求出 “岛屿” 的大小. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;private: bool _legalArea(int i, int j, int k)&#123; //true : i 和 j 的各个位之后小于k int sum = 0; while(i)&#123; sum += i % 10; i /= 10; &#125; while(j)&#123; sum += j % 10; j /= 10; &#125; return (sum &lt;= k); &#125; void dfs(int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; map)&#123; if(i&lt;0 || i&gt;=map.size() || j&lt;0 || j&gt;= map[0].size() || map[i][j] == 0) return; count++; map[i][j] = 0; int dx[4]&#123;0,0,-1,1&#125;; int dy[4]&#123;-1,1,0,0&#125;; for(int k = 0 ; k &lt; 4; ++ k)&#123; dfs(i+dx[k],j+dy[k],map); &#125; return; &#125;public: int count = 0; int movingCount(int m, int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; map(m, vector&lt;int&gt;(n,0)); for(int i = 0 ; i &lt; m ; ++ i)&#123; for(int j = 0 ; j &lt; n ; ++ j)&#123; if(_legalArea(i,j,k) == true)&#123; map[i][j] = 1; &#125; &#125; &#125; dfs(0,0,map); return count; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"DFS","slug":"DFS","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/DFS/"}]},{"title":"博客文章以及Github仓库引导","slug":"top","date":"2020-11-20T06:56:00.000Z","updated":"2020-12-06T14:42:57.801Z","comments":true,"path":"2020/11/20/top/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/20/top/","excerpt":"","text":"博客文章引导 我的博客, 即劳振煜的知識倉儲, 也就是您当前访问的博客. 博客是基于 Hexo 的静态博客, 部署于我的 Github 上. 该博客主要用来记录我在学习以及未来工作中的所感所悟. 留作记录以便自己在未来温故或帮助到正在看博客的你. 博客的内容区别于 Github 的内容, 主要是博客将会记录完整的有体系的内容, 而 Github 上的各个仓库主要是用于记录学习笔记与实验, 自己造轮子, 学习他人的开源项目. C++ STL 数据结构 计算机网络 操作系统 设计模式 Leetcode Github仓库引导 我的Github, 也就是上方链接. 你可以搜索 OXygenPanda 访问. 虽然没有很多 star, 但是仍然坚持学习, 坚持记录, 坚持分享. 计算机网络课程学习 - 韩立刚老师 记录计算机网络课程学习的笔记 深入理解操作系统课程学习 - 清华大学 记录清华大学深入理解操作系统课程学习的笔记","categories":[],"tags":[]},{"title":"剑指 Offer 12. 矩阵中的路径","slug":"leetcode/offer/剑指Offer 12","date":"2020-11-18T02:30:00.000Z","updated":"2020-11-24T13:49:56.629Z","comments":true,"path":"2020/11/18/leetcode/offer/剑指Offer 12/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/18/leetcode/offer/%E5%89%91%E6%8C%87Offer%2012/","excerpt":"剑指 Offer 12. 矩阵中的路径题目描述剑指 Offer 12. 矩阵中的路径 难度:中等 描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[“a”,“b”,”c”,”e”], [“s”,“f”,“c”,”s”], [“a”,”d”,“e”,”e”]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。","text":"剑指 Offer 12. 矩阵中的路径题目描述剑指 Offer 12. 矩阵中的路径 难度:中等 描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[“a”,“b”,”c”,”e”], [“s”,“f”,“c”,”s”], [“a”,”d”,“e”,”e”]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 示例 123456789输入: board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出: true输入: board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;输出: false限制:1 &lt;= board.length &lt;= 2001 &lt;= board[i].length &lt;= 200 解法这是一道很经典的走迷宫题目了, 而且学习过DFS的话, 一定也看到过或者做过这道题目. DFS: 深度优先搜索的意图是通过迭代的方式穷极一条路径, 如果最终无法匹配则舍弃(可以提前剪枝), 然后再选择其他路径再一往无前走到底. 在这个题目里的意思是, 我先从每一个位置 (i,j) 递归出N条长度和字符串长度相同的路径, 如果路径正好能够和字符串匹配则返回 true , 如果不匹配则再去寻找其他路径. 但是有几个优化的地方 : 提前剪枝 : 判断边界不在 board 范围内, 或者当前位置的字符和我期待的字符串的某个字符不同就提前结束 board[i][j] = ‘#’ : 可以不使用 visit 数组来标记是否访问过该节点, 通过先把当前字符修改后还原节约空间 或运算的短路 : 像注释里那么写的话, 每一层递归都会做四次运算, 递归深度过大的话, 会超时; 而像 13:16 这么写, 可以有效利用”短路”, 当某一个dfs返回true时, 不需要去执行后续的递归操作, 大大节约了时间. 1234567891011121314151617181920212223242526272829303132class Solution &#123;private: int n, m; bool dfs(int i, int j, vector&lt;vector&lt;char&gt;&gt; &amp; board, string word, int start)&#123; if(i&lt;0 || i&gt;=n || j&lt;0 || j&gt;=m || board[i][j] != word[start]) return false; if(word.length() == start + 1) return true; char tmp = board[i][j]; board[i][j] = &#x27;#&#x27;; int dx[4] = &#123;1,-1,0,0&#125;; int dy[4] = &#123;0,0,-1,1&#125;; bool ret = dfs(i+dx[0], j+dy[0], board, word, start + 1) || dfs(i+dx[1], j+dy[1], board, word, start + 1) || dfs(i+dx[2], j+dy[2], board, word, start + 1) || dfs(i+dx[3], j+dy[3], board, word, start + 1); // for(int index = 0; index &lt; 4; ++index)&#123; // ret |= dfs(i+dx[index], j+dy[index], board, word, start + 1); board[i][j] = tmp; return ret; &#125;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; n = board.size(), m = board[0].size(); for(int i = 0; i &lt; n; ++i) for(int j = 0;j &lt; m; ++j) if(dfs(i, j, board, word, 0)) return true; return false; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"DFS","slug":"DFS","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/DFS/"}]},{"title":"剑指 Offer 11. 旋转数组的最小数字","slug":"leetcode/offer/剑指Offer 11","date":"2020-11-17T10:45:00.000Z","updated":"2020-11-24T14:19:31.780Z","comments":true,"path":"2020/11/17/leetcode/offer/剑指Offer 11/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/17/leetcode/offer/%E5%89%91%E6%8C%87Offer%2011/","excerpt":"剑指 Offer 11. 旋转数组的最小数字题目描述剑指 Offer 11. 旋转数组的最小数字 难度:简单 描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。","text":"剑指 Offer 11. 旋转数组的最小数字题目描述剑指 Offer 11. 旋转数组的最小数字 难度:简单 描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 12345输入：[3,4,5,1,2]输出：1输入：[2,2,2,0,1]输出：0 解法遥记得很久以前写斐波那契数列的问题时, 不考虑时间空间复杂度. 一股脑把所有的斐波那契数存下来, 现在针对这一题来说, 它没有必要存下每一个斐波那契数, 只需要返回第n个,所以就把DP问题优化了一下,减少了空间复杂度.mod的位置比较重要, 因为中途计算的时候可能会使得dp_2超出整形范围,所以在运算时就得mod. 1234567891011121314class Solution &#123;public: int fib(int n) &#123; if(n == 0 || n == 1) return n; int mod = 1e9+7; int dp_0 = 0, dp_1 = 1, dp_2; for(int i = 2; i &lt;= n; ++i)&#123; dp_2 = (dp_0 + dp_1) % mod; dp_0 = dp_1; dp_1 = dp_2; &#125; return dp_2; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指 Offer 10- I. 斐波那契数列","slug":"leetcode/offer/剑指Offer 10","date":"2020-11-17T10:25:00.000Z","updated":"2020-11-24T14:19:27.176Z","comments":true,"path":"2020/11/17/leetcode/offer/剑指Offer 10/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/17/leetcode/offer/%E5%89%91%E6%8C%87Offer%2010/","excerpt":"","text":"剑指 Offer 10- I. 斐波那契数列题目描述剑指 Offer 10. 斐波那契数列 难度:简单 描述 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 12345678输入：n = 2输出：1输入：n = 5输出：5 限制：0 &lt;= n &lt;= 100 解法遥记得很久以前写斐波那契数列的问题时, 不考虑时间空间复杂度. 一股脑把所有的斐波那契数存下来, 现在针对这一题来说, 它没有必要存下每一个斐波那契数, 只需要返回第n个,所以就把DP问题优化了一下,减少了空间复杂度.mod的位置比较重要, 因为中途计算的时候可能会使得dp_2超出整形范围,所以在运算时就得mod. 1234567891011121314class Solution &#123;public: int fib(int n) &#123; if(n == 0 || n == 1) return n; int mod = 1e9+7; int dp_0 = 0, dp_1 = 1, dp_2; for(int i = 2; i &lt;= n; ++i)&#123; dp_2 = (dp_0 + dp_1) % mod; dp_0 = dp_1; dp_1 = dp_2; &#125; return dp_2; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"shared_ptr的简单实现","slug":"C++/smart_ptr","date":"2020-11-12T11:23:00.000Z","updated":"2020-11-24T14:13:10.597Z","comments":true,"path":"2020/11/12/C++/smart_ptr/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/12/C++/smart_ptr/","excerpt":"智能指针的实现 程序运行时需要分配内存释放内存, 在C++中我们使用关键词 new 和 delete . new 是一个运算符, 负责申请堆内存, 分为两个步骤 : 1.malloc 2.operator new, 即先申请内存, 再构造对象. 最后返回该堆内存的指针. delete也是一个运算符, 负责释放堆内存, 分为两个步骤 :1.operator delete 2.free, 即先调用对象的析构函数, 再释放内存. 堆内存需要程序员手动释放, 因此如果程序抛出异常, 来不及释放内存或者忘记释放内存都会导致内存泄漏.","text":"智能指针的实现 程序运行时需要分配内存释放内存, 在C++中我们使用关键词 new 和 delete . new 是一个运算符, 负责申请堆内存, 分为两个步骤 : 1.malloc 2.operator new, 即先申请内存, 再构造对象. 最后返回该堆内存的指针. delete也是一个运算符, 负责释放堆内存, 分为两个步骤 :1.operator delete 2.free, 即先调用对象的析构函数, 再释放内存. 堆内存需要程序员手动释放, 因此如果程序抛出异常, 来不及释放内存或者忘记释放内存都会导致内存泄漏. 因此, C++11以后有了三种更加安全, 更加智能的”指针”. 说是指针, 其实是用起来像指针的类. 这一种思想和STL的仿函数, 迭代器中类似. 标准库提供的三种智能指针的区别在于管理底层指针的方法不同, shared_ptr 允许多个指针指向同一个对象, unique_ptr 则”独占”所指向的对象. 标准库还定义了一种名为weak_ptr的伴随类, 它是一种弱引用, 指向shared_ptr所管理的对象, 这三种智能指针都定义在memory头文件中. 这一篇文章主要是手动实现了一下 shared_ptr 和 unique_ptr 类. shared_ptr123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;template&lt;typename T&gt;class myshared_ptr&#123; private: T * _ptr; int * _count; public: // 构造函数 myshared_ptr():_ptr(nullptr),_count(nullptr)&#123; std::cout &lt;&lt; &quot;default ctor&quot; &lt;&lt; std::endl; &#125; myshared_ptr(T * ptr):_ptr(ptr),_count(new int(1))&#123; std::cout &lt;&lt; &quot;raw pointer ctor : &quot; &lt;&lt; *ptr &lt;&lt; std::endl; &#125; myshared_ptr(myshared_ptr &amp; ref):_ptr(ref._ptr),_count(&amp;(++*(ref._count)))&#123; std::cout &lt;&lt; &quot;shared_ptr ctor : &quot; &lt;&lt; *ref._ptr &lt;&lt; std::endl; &#125; // 析构函数 ~myshared_ptr()&#123; if(--*(this-&gt;_count) == 0)&#123; std::cout &lt;&lt; *_ptr &lt;&lt; &quot; dector!&quot; &lt;&lt; std::endl; delete _ptr; delete _count; &#125; &#125; // 拷贝赋值 myshared_ptr &amp; operator=(myshared_ptr &amp; ref)&#123; if(&amp;ref == this) return *this; ++*ref._count; if(--*(this-&gt;_count) == 0)&#123; std::cout &lt;&lt; *_ptr &lt;&lt; &quot; dector!&quot; &lt;&lt; std::endl; delete this-&gt;_ptr; delete this-&gt;_count; &#125; this-&gt;_ptr = ref._ptr; this-&gt;_count = ref._count; std::cout &lt;&lt; &quot;operator = success&quot; &lt;&lt; std::endl; return *this; &#125; public: // 引用 T operator*()&#123; if(_count == 0) return (T)0; return *this-&gt;_ptr; &#125; // 箭头 T * operator-&gt;()&#123; if(_count == 0) return 0; return this-&gt;_ptr; &#125;&#125;; 123456789//main()int main(int argc, char **argv)&#123; myshared_ptr&lt;string&gt; pstr1(new string(&quot;hello&quot;)); myshared_ptr&lt;string&gt; pstr2(pstr1); myshared_ptr&lt;string&gt; pstr3(new string(&quot;world&quot;)); pstr3 = pstr1; return 0;&#125; 123456789//运行结果--------------------raw pointer ctor : helloshared_ptr ctor : helloraw pointer ctor : worldworld dector!operator = successhello dector! unique_ptr1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;struct Deleter&#123; public: template&lt;typename T&gt; void operator()(T *p)&#123; delete p; &#125;&#125;;template&lt;typename T, typename D = Deleter&gt;class myunique_ptr&#123; /* * 1. 一个对象只能有一个 unique_ptr 指向, 当指针销毁,对象也销毁 * 2. 初始化 unique_ptr 只能采用直接初始化的方式(explicit 修饰构造函数) * 3. 不支持拷贝构造和拷贝赋值 * 4. 支持搬移构造和搬移赋值获得函数返回值或者函数局部变量 * 5. 必须提供删除器 * */ private: T * _ptr; D del; public: explicit myunique_ptr(T *pointer = nullptr, const D &amp;dd = D()) :_ptr(pointer),del(dd)&#123;&#125; ~myunique_ptr()&#123; delete _ptr; &#125; public: myunique_ptr(const myunique_ptr&amp;) = delete; myunique_ptr &amp; operator=(const myunique_ptr&amp;) = delete; public: myunique_ptr(myunique_ptr &amp;&amp; right_value) :_ptr(right_value._ptr),del(std::move(right_value.del))&#123; right_value._ptr = nullptr; &#125; myunique_ptr &amp; operator=(myunique_ptr &amp;&amp; right_value) noexcept&#123; if(this != &amp;right_value)&#123; std::cout &lt;&lt; &quot;operator &amp;&amp; right_value&quot; &lt;&lt; std::endl; del(*this); _ptr = right_value._ptr; del = std::move(right_value.del); right_value._ptr = nullptr; &#125; return *this; &#125; public: // release() 返回资源,释放管理 T * release()&#123; T * tmp = _ptr; _ptr = nullptr; return tmp; &#125; // reset() // reset(T * ptr) void reset()&#123; del(_ptr); &#125; void reset(T * ptr)&#123; if(_ptr != nullptr)&#123; del(_ptr); _ptr = ptr; &#125; &#125; // swap() void swap(myunique_ptr &amp; other) noexcept&#123; using std::swap; swap(_ptr, other._ptr); swap(del, other.del); &#125; public: T* get() &#123; return _ptr; &#125; D&amp; get_deleter() &#123; return del; &#125; T&amp; operator*() &#123; return *_ptr; &#125; T* operator-&gt;() &#123; return _ptr; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//mainclass base&#123;public: base()&#123; std::cout &lt;&lt; &quot;ctor&quot; &lt;&lt; std::endl; &#125; ~base()&#123; std::cout &lt;&lt; &quot;dector&quot; &lt;&lt; std::endl; &#125; base(const base&amp;)&#123; std::cout &lt;&lt; &quot;left_value ctor&quot; &lt;&lt; std::endl; &#125; base(base&amp;&amp;)&#123; std::cout &lt;&lt; &quot;right_value ctor&quot; &lt;&lt; std::endl; &#125;&#125;;struct base_deleter&#123; public: void operator()(base* p) const&#123; std::cout &lt;&lt; &quot;deleter function call&quot; &lt;&lt; std::endl; delete p; &#125;&#125;;int main(int argc, char ** argv)&#123; // myunique_ptr&lt;string&gt; uptr1; // myunique_ptr&lt;string&gt; uptr2(new string(&quot;abc&quot;)); // myunique_ptr&lt;string&gt; uptr3(nullptr); // base_deleter d; myunique_ptr&lt;base,base_deleter&gt; uptr1; myunique_ptr&lt;base,base_deleter&gt; uptr2(nullptr); myunique_ptr&lt;base,base_deleter&gt; uptr3(new base); myunique_ptr&lt;base,base_deleter&gt; uptr4(new base, d); base* fp = uptr4.release(); assert(uptr4.get() == nullptr); delete fp; uptr3.reset(new base()); return 0;&#125; 123456789//结果--------------------ctorctordectorctordeleter function calldectordector","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"}],"tags":[{"name":"C++11","slug":"C-11","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C-11/"},{"name":"智能指针","slug":"智能指针","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"}]},{"title":"深入理解操作系统学习笔记","slug":"HugeFour/OperatingSystem/QingHua/Deep_into_OperatingSystem_all","date":"2020-11-08T12:07:00.000Z","updated":"2020-11-24T14:14:46.807Z","comments":true,"path":"2020/11/08/HugeFour/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/08/HugeFour/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/","excerpt":"第一章 第一章的主要内容是 : 操作系统的一些知识 操作系统是什么？用户角度：操作系统是一个控制软件","text":"第一章 第一章的主要内容是 : 操作系统的一些知识 操作系统是什么？用户角度：操作系统是一个控制软件 管理应用程序 为应用程序提供服务 杀死应用程序 程序角度：操作系统是资源管理器 管理外设、分配资源 抽象 将CPU抽象成进程 将磁盘抽象成文件 将内存抽象成地址空间 操作系统层次位于硬件之上，应用程序之下。 操作系统的界面和内核Linux Windows Android 的界面属于外壳(Shell) ，而不是内核(kernel)。操作系统研究的是内核，处于Shell之下。 操作系统内部组件 CPU调度器 物理内存管理 虚拟内存管理 文件系统管理 中断处理与设备驱动 操作系统特征 并发 一段时间内运行多个进程（并行 : 一个时间点运行多个进程，一般要求有多个CPU) 需要OS管理和调度 共享 “同时”共享 互斥共享 虚拟 让每一个用户觉得的有一个计算机专门为他服务 异步 程序是走走停停，而不是一直运行 第二章 第二章的主要内容是 : 操作系统的异常/中断/系统调用 探究计算机启动过程作用解析 Disk : 存放OS和Bootloader BOIS : 基于I/O处理系统 Bootloader : 加载OS，将OS放入内存 结构 Disk |___ OS |___ Bootloader 开机流程 BIOS 开机后，寻找显卡和执行BIOS (此时, CS : IP = 0xF000 : 0xFFF0, CS/IP 两个寄存器) 将Bootloader从磁盘的引导扇区加载到0x7C00 (Bootloader一共占用512M字节的内存) 跳转到 CS : IP = 0x0000 : 0x7C00 Bootloader 将操作系统的代码和数据从硬盘加载到内存中 跳转到操作系统的起始地址 中断、异常、系统调用中断中断来源于外设，来自不同的硬件设备的计时器和网络的中断。 中断流程 硬件：设置中断标记（CPU初始化） 将内部、外部事件设置中断标记 中断事件的ID 软件 保存当前处理状态（寄存器之类的一些数据） 根据中断事件的ID跳转到中断服务程序，中断服务程序处理 清楚中断标记 异常异常来源于不良的应用程序，非法指令或者其他坏的处理状态（如：内存出错）。 异常处理流程 保存现场 异常处理 杀死了产生异常的程序 重新执行异常指令 恢复现场 系统调用系统调用来源于应用程序，应用程序主动向操作系统发出服务请求。程序访问主要是通过高层次的API，而不是直接调用系统调用函数。 APIs Win32 API 用于Windows POSIX API 用于 POSIX-based systems（包括UNIX，LINUX，Mac OS X） Java API 用于JAVA虚拟机 特点 通常情况下，每个系统调用有对应的序号 系统调用接口根据这些序号来维护表的索引 系统调用接口调用内核态中预期的系统调用 并返回系统调用的状态和其他任何返回值 用户不需要知道系统调用是如何实现的 只需要获取API和了解操作系统将什么作为返回结果 操作系统接口的细节大部分都隐藏在API中 用户态：操作系统运行中，CPU处于的特权级别，不能直接执行特权指令 内核态：操作系统运行中，CPU处于的特权级别，可以执行任何一条指令 系统调用：触发CPU从用户态到内核态的转换，切换程序和内核的堆栈，需要一定的开销 跨越操作系统边界的开销（值得的且必须的，保证了操作系统的安全性） 在执行时间上的开销超过程序调用 开销： 建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销 建立内核堆栈 验证参数 内核态映射到用户态的地址空间（更新页面映射权限） 内核态独立地址空间（TLB） 区别 类型 源头 处理时间 响应 中断 外设 异步 持续，对应用程序透明 异常 应用程序意向不到的行为 同步 杀死或重新执行指令 系统调用 应用程序请求系统提供服务 同步或异步 等待和持续 异步：应用程序不知道什么时候会发生中断 同步：执行到某一条指令一定会发生该事件 为什么应用程序不能直接访问硬件？ 在计算机运行时，内核是被信任的第三方 只有内核可以执行特权指令 为了方便应用程序 第三章 第三章的主要内容是 : 操作系统的物理内存管理 计算机体系结构 CPU 内存 I/O 内存分层体系内存分层体系运行内存(主存) / 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间. CPU可以访问的内存包括两大类 : 寄存器 / cache(L1缓存 / L2缓存) 层次 微处理器(CPU访问) |___CPU寄存器 / L1缓存 |___L2缓存 主存(程序访问) 磁盘(程序访问) 从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。 内存管理目标 抽象：逻辑地址空间 保护：独立地址空间 共享：访问相同内存 虚拟：更多的地址空间 内存管理方法 程序重定位 分段 分页 虚拟内存 按需分页虚拟内存 实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求 地址空间地址空间的定义 物理地址空间 —— 硬件支持的地址空间( address : [0, Max_sys] ) 逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] ) 连续内存分配内存碎片问题内存碎片问题指的是空闲的内存无法被利用 外部碎片 : 分配单元间的未使用内存 内部碎片 : 分配单元内的未使用内存 分区的动态分配分区的动态分配方式有以下三种 : 第一匹配分配 : 在内存中找到第一个比需求大的空闲块, 分配给应用程序 最优适配分配 : 在内存中找到最小的空闲块, 分配给应用程序 最差适配分配 : 在内存中找到最大的空闲块, 分配给应用程序 分配方式的区别 分配方式 第一匹配分配 最优适配分配 最差适配分配 分配方式实现需求 1. 按地址排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区 1. 按尺寸排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区 1. 按尺寸排序的空闲块列表2. 分配最大的分区3. 重分配需要检查是否可以合并相邻空闲分区 优势 简单 / 易于产生更大空闲块 比较简单 / 大部分分配是小尺寸时高效 分配很快 / 大部分分配是中尺寸时高效 劣势 产生外部碎片 / 不确定性 产生外部碎片 / 重分配慢 / 产生很多没用的微小碎片 产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配 三种分配方式并无优劣之分，因为我们无法判断内存请求的大小 碎片整理方法可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。 压缩式碎片整理 重置程序以合并碎片 要求所有程序是动态可重置的 问题 : 何时重置 ? (在程序处于等待状态时才可以重置) 需要考虑内存拷贝的开销 交换式碎片整理 运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存 问题 : 哪些程序应该被回收 ? 情况 : 运行中 : P3 等待中 : P1 P2 P4 内存分布 -&gt; 主存 : OS / P1 / P3 / P2 / P4 磁盘 : 空 当P3程序需要更大的内存时 -&gt; 内存分布 -&gt; 主存 : OS / P1 / P3 / P2 磁盘 : P4 第四章 第四章的主要内容是：操作系统的非连续内存分配 第三章介绍的是连续内存管理, 即 : 操作系统加载到内存以及程序加载到内存中时, 分配一块连续的空闲(内存)块. 但是容易出现碎片问题, 这一章介绍的非连续内存分配可以有效的减少碎片的出现. 非连续内存分配的必要性连续内存分配的缺点 分配给一个程序的物理内存是连续的 内存利用率低 有外碎片 / 内碎片的问题 非连续内存分配的优点 一个程序的物理地址空间是非连续的 更好的内存利用和管理 允许共享代码与数据(共享库等…) 支持动态加载和动态链接 非连续内存分配的缺点 建立虚拟地址和物理地址的转换难度大 软件方案 硬件方案(采用硬件方案) : 分段 / 分页 非连续内存分配分段(Segmentation)段 : 在程序中会有来自不同文件的函数 ; 在程序执行时, 不同的数据也有不同的字段, 比如 : 堆 / 栈 / .bss / .data 等 **分段 : ** 更好的分离和共享 程序的分段地址空间如下图所示 : 分段寻址方案 逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联. 一个段 : 一个内存”块” 程序访问内存地址需要 : 一个二维的二元组(s, addr) → (段号, 地址) 操作系统维护一张段表, 存储(段号, 物理地址中的起始地址, 长度限制) 物理地址 : 段表中的起始地址 + 二元组中的偏移地址 分页(Paging)分页地址空间划分物理内存至固定大小的帧(Frame) 大小是2的幂, 512 / 4096 / 8192 划分逻辑地址空间至相同大小的页(Page) 大小是2的幂, 512 / 4096 / 8192 建立方案 → 转换逻辑地址为物理地址(pages to frames) 页表 MMU / TLB 帧(Frame) 物理内存被分割为大小相等的帧. 一个内存物理地址是一个二元组(f, o) → (帧号, 帧内偏移) 帧号 : F位, 共有2^F个帧 帧内偏移 : S位, 每帧有2^S个字节 物理地址 = 2^S * f + o (例子 : 16-bit地址空间, 9-bit(512 byte) 大小的页帧 物理地址 = (3,6) 物理地址 = 2^9 * 3 + 6 = 1542) 分页和分段的最大区别 : 这里的 S 是一个固定的数, 而分段中的长度限制不定 页(Page) 一个程序的逻辑地址空间被划分为大小相等的页. 页内偏移的大小 = 帧内偏移的大小 页号大小 &lt;&gt; 帧号大小 一个逻辑地址是一个二元组(p, o) → (页号, 页内偏移) 页号 : P位, 共有2^P个页 页内偏移 : S位, 每页有2^S个字节 虚拟地址 = 2^S * p + o 页寻址方案操作系统维护一张页表, 页表保存了逻辑地址——物理地址之间的映射关系 存储 : (页号, 帧号) 逻辑地址空间应当大于物理内存空间 页映射到帧 页是连续的虚拟内存 帧是非连续的物理内存(有助于减少碎片的产生) 不是所有的页都有对应的帧 页表(Page Table)页表概述每一个运行的程序都有一个页表 属于程序运行状态, 会动态变化 PTBR : 页表基址寄存器 转换流程 CPU根据程序的page的页号的若干位, 计算出索引值index, 在页表中搜索这个index, 得到的是帧号, 帧号和原本的offset组成物理地址. 页表中还有一些特殊标志位 dirty bit, resident bit, (0 : 对应的物理页帧在内存中不存在 ; 1 : 存在) clock / reference bit 转换实例 16位地址的系统 32KB的物理内存 每页的 1024 byte 逻辑地址空间 : (4, 0) … (3, 1023) 页表 : Flags | Frame nums 1 0 1 0 0 0 0 0 → 内存访问异常(可能要杀死程序) 0 1 1 0 0 1 0 0 → 页帧是4 偏移是 1023 → 物理地址 (4, 1023) 分页机制的性能问题访问一个内存单元需要2次内存访问 一次用于获取页表项 一次用于访问数据 页表可能非常大 64位机器如果每页1024字节, 那么一个页表的大小会是多少？(2^64 / 2^10 = 2^54 存放不下) 每一个运行的程序都需要有一个页表 如何处理？ 缓存(Caching) 间接(Indirection)访问 转换后备缓冲区(TLB)缓解时间问题 Translation Look-aside Buffer(TLB) 是一个缓冲区. CPU中有快表TLB(可以将经常访问的页表存放在这边) 缓存近期访问的页帧转换表项 TLB使用关联内存实现, 具备快速访问性能 如果TLB命中, 物理页号可以很快被获取 如果TLB未命中, 对应的表项被更新到TLB中(x86的CPU由硬件实现, 其他的可能是由操作系统实现) 二级/多级页表时间换空间 二级页表 将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表. 一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号 节约了一定的空间, 在一级页表中如果resident bit = 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留 多级页表 通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树” 反向页表解决大地址空间问题 目的 : 根据帧号获得页号 反向页表只需要存在一张即可 有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表 不是让页表与逻辑地址空间的大小相对应, 而是当页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间 基于页寄存器(Page Registers)的方案存储 (帧号, 页号) 使得表大小与物理内存大小相关, 而与逻辑内存关联减小. 每一个帧和一个寄存器关联, 寄存器内容包括 : resident bit : 此帧是否被占用 occupier : 对应的页号 p protection bits : 保护位 实例 : 物理内存大小是 : 4096 * 4096 = 4K * 4KB = 16 MB 页面大小是 : 4096 bytes = 4 KB 页帧数 : 4096 = 4 K 页寄存器使用的空间(假设8 bytes / register) : 8 * 4096 = 32 Kbytes 页寄存器带来的额外开销 : 32K / 16M = 0.2% 虚拟内存大小 : 任意 优势 : 转换表的大小相对于物理内存来说很小 转换表的大小跟逻辑地址空间的大小无关 劣势 : 需要的信息对调了, 即根据帧号可以找到页号 如何转换回来? (如何根据页号找到帧号) 在需要在反向页表中搜索想要的页号 基于关联内存(associative memory)的方案硬件设计复杂, 容量不大, 需要放置在CPU中 如果帧数较少, 页寄存器可以被放置在关联内存中 在关联内存中查找逻辑页号 成功 : 帧号被提取 失败 : 页错误异常 (page fault) 限制因素: 大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电) 基于哈希(hash)的方案哈希函数 : h(PID, p) 从 PID 标号获得页号 在反向页表中通过哈希算法来搜索一个页对应的帧号 对页号做哈希计算, 为了在帧表中获取对应的帧号 页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数 为了查找页 i , 执行下列操作 : 计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器 检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败 第五章 第五章的主要内容是：操作系统的虚拟内存管理技术 虚拟内存的起因使用硬盘/磁盘使更多的程序在有限的内存中运行 理想的存储器 : 更大更快更便宜和非易失性的存储区 覆盖技术如果是程序太大, 超出了内存的容量, 可以采用手动的概率(overlay)技术, 只把需要的指令和数据保存在内存当中 目的 : 是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用. 原理 : 把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行. 必要部分(常用功能)的代码和数据常驻内存; 可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存; 不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区. 也就是说,程序松耦合的部分可以按需装入内存,不需要的时候放在外存中,多个不常用部分共用一个分区. 实例 : A(20k) __B(50k) __ D(30k) | __ C(30k) __ E(20k) |____ F(40k) 因此不需要将整个程序190k的数据全部放入内存中, 而是划分为 常驻区(20k) 覆盖区0(50k) 覆盖区1(40k) 压缩至了110k的内存空间使用 缺点 : 由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度; 覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省. 交换技术如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中 目的 : 多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源 原理 : 可将暂时不能运行的程序送到外存, 从而获得空闲内存空间. 操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间. 存在问题 : 交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出; 交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取 程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法 覆盖技术和交换技术的对比特点 : 覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构. 交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构. 换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部. 在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 : 覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担. 交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销. 虚拟内存管理技术如果想要在有限容量的内存中, 以更小的页粒度为单位装入更多更大的程序, 可以采用自动的虚拟存储技术 目标 像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉. 像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换. 程序局部性原理 程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域. 时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内 ; 空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内. 程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果. 实例 : 1234567891011121314题目描述 :页面大小为4k, 分配给每个进程的物理页面是1. 在一个进程中, 定义了如下的二维数组 int A[1024][1024]. 该数组按行存放在内存, 每一行放在一个页面中.考虑一下程序的编写方法对缺页率的影响?程序编写方法1 : (发生了1024*1024次缺页中断)for(j = 0; j &lt; 1024; j++) for(i = 0; i &lt; 1024; i++) A[i][j] = 0;程序编写方法2 : (发生了1024次缺页中断)for(i = 0; i &lt; 1024; i++) for(j = 0; j &lt; 1024; j++) A[i][j] = 0; 基本概念 可以在页式或段式内存管理的基础上实现 在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行; 在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序; 另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段. 基本特征 大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如32位的虚拟地址理论上可以访问4GB, 而可能计算机上仅有256M的物理内存, 但硬盘容量大于4GB. 部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的; 不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性. 虚拟页式内存管理 页式内存管理 页表 : 完成逻辑页到物理页帧的映射 根据页号去页表中寻找索引, 先查看 resident bit 是否为0, 0表示不存在, 1表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址. 虚拟页式内存管理 大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能. 基本思路 当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行. 在运行的过程中, 如果发现要运行的程序或要访问的数据不再内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行. 页表表项 逻辑页号 | 访问位 | 修改位 | 保护位 | 驻留位 | 物理页帧号 驻留位 : 表示该页是在内存中还是在外存. 保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等 修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存 访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法. 缺页中断处理过程 : 如果在内存中有空闲的物理页面, 则分配一物理页帧f, 然后转第4步; 否则转到第2步; 采用某种页面置换算法, 选择一个将被替换的物理页帧f, 它所对应的逻辑页为q, 如果该页在内存期间被修改过, 则需要把它写回外存; 对q所对应的页表项修改, 把驻留位置为0; 将需要访问的页p装入到物理页面f当中; 修改p所对应的页表项的内容, 把驻留位置为1, 把物理页帧号置为f; 重新运行被中断是指令. 在何处保存未被映射的页? 能够简单地识别在二级存储器中的页 交换空间(磁盘或者文件) : 特殊格式, 用于存储未被映射的页面 后备存储(二级存储) : 一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)的某个位置 代码段 : 映射到可执行二进制文件 动态加载的共享库程序段 : 映射到动态调用的库文件 其他段 : 可能被映射到交换文件(swap file) 虚拟内存性能 为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT) EAT = 访存时间 * 页表命中几率 + page fault处理时间 * page fault几率 实例 : 访存时间 : 10 ns 磁盘访问时间 : 5 ms 参数 p = page fault 几率 参数 q = dirty page 几率(对页面写操作) EAT = 10*(1-p) + 5000000*p*(1+q) 第六章 第六章的主要内容是：操作系统的虚拟内存管理技术中的页面置换算法 功能与目标功能 : 当缺页中断发生, 需要调入新的页面而内存已满时, 选择内存当中哪个物理页面被置换. 目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数). 具体来说, 把未来不再使用的或短期内较少使用的页面换出, 通常只能在局部性原理指导下依据过去的统计数据来进行预测. 页面锁定 : 用于描述必须常驻内存的操作系统的关键部分或时间关键的应用进程. 实现的方式是 : 在页表中添加锁定标记位(lock bit). 实验设置与评价方法实例 : 记录一个进程对页访问的一个轨迹 举例 : 虚拟地址跟踪(页号, 偏移)… (3,0) (1,9) (4,1) (2,1) (5,3) (2,0) … 生成的页面轨迹 3, 1, 4, 2, 5, 2, 1, … 模拟一个页面置换的行为并且记录产生页缺失数的数量 更少的缺失, 更好的性能 局部页面置换算法最优页面置换算法基本思路 : 当一个缺页中断发生时, 对于保存在内存当中的每一个逻辑页面, 计算在它的下一次访问之前, 还需等待多长时间, 从中选择等待时间最长的那个, 作为被置换的页面. 这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问. 可用作其他算法的性能评价的依据.(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况, 在第二遍运行时即可使用最优算法) 先进先出算法基本思路 : 选择在内存中驻留时间最长的页面淘汰. 具体来说, 系统维护着一个链表, 记录了所有位于内存当中的逻辑页面. 从链表的排列顺序来看, 链首页面的驻留时间最长, 链尾页面的驻留时间最短. 当发生一个缺页中断时, 把链首页面淘汰出去, 并把新的页面添加到链表的末尾. 性能较差, 调出的页面有可能是经常要访问的页面. 并且有 belady现象. FIFO算法很少单独使用. 最近最久未使用算法LRU(Least Recently Used) 基本思路 : 当一个缺页中断发生时, 选择最久未使用的那个页面, 并淘汰. 它是对最优页面置换算法的一个近似, 其依据是程序的局部性原理, 即在最近一小段时间(最近几条指令)内, 如果某些页面被频繁地访问, 那么再将来的一小段时间内, 他们还可能会再一次被频繁地访问. 反过来说, 如果过去某些页面长时间未被访问, 那么在将来它们还可能会长时间地得不到访问. LRU算法需要记录各个页面使用时间的先后顺序, 开销比较大. 两种可能的实现方法是 : 系统维护一个页面链表, 最近刚刚使用过的页面作为首节点, 最久未使用的作为尾结点. 再一次访问内存时, 找出相应的页面, 把它从链表中摘下来, 再移动到链表首. 每次缺页中断发生时, 淘汰链表末尾的页面. 设置一个活动页面栈, 当访问某页时, 将此页号压入栈顶, 然后, 考察栈内是否有与此页面相同的页号, 若有则抽出. 当需要淘汰一个页面时, 总是选择栈底的页面, 它就是最久未使用的. 时钟页面置换算法基本思路 : 需要用到页表项的访问位, 当一个页面被装入内存时, 把该位初始化为0. 然后如果这个页面被访问, 则把该位置设为1; 把各个页面组织成环形链表(类似钟表面), 把指针指向最老的页面(最先进来); 当发生一个缺页中断时, 考察指针所指向的最老页面, 若它的访问位为0, 立即淘汰; 若访问位为0, 然后指针往下移动一格. 如此下去, 直到找到被淘汰的页面, 然后把指针移动到下一格. 流程 : 如果访问页在物理内存中, 访问位置1. 如果不在物理页, 从指针当前指向的物理页开始, 如果访问位0, 替换当前页, 指针指向下一个物理页; 如果访问位为1, 置零以后访问下一个物理页再进行判断. 如果所有物理页的访问位都被清零了, 又回到了第一次指针所指向的物理页进行替换. 二次机会算法因为考虑到时钟页面置换算法, 有时候会把一些 dirty bit 为1(有过写操作)的页面进行置换, 这样的话, 代价会比较大. 因此, 可以结合访问位和脏位一起来决定应该置换哪一页. used dirty → used dirty 0 0 replace 0 1 0 0 1 0 0 0 1 1 0 1 相当于说, 替换的优先级, 没有读写也没写过, 那么直接走, 如果写过或者访问过, 那么给你一次机会, 如果又写过, 又访问过, 那么久给你两次机会. 最不常用算法Least Frequently used, LFU 基本思路 : 当一个缺页中断发生时, 选择访问次数最少的那个页面, 并淘汰. 实现方法 : 对每一个页面设置一个访问计数器, 每当一个页面被访问时, 该页面的访问计数器加1. 当发生缺页中断时, 淘汰计数值最小的那个页面. LRU和LFU的对比 : LRU考察的是多久未访问, 时间越短越好. 而LFU考察的是访问的次数和频度, 访问次数越多越好. Belady现象(科学家名字)在采用FIFO算法时, 有时会出现分配的物理页面数增加, 缺页率反而提高的异常现象; 出现原因 : FIFO算法的置换特征与进程访问内存的动态特征是矛盾的, 与置换算法的目标是不一致的(即替换较少使用的页面), 因此, 被他置换出去的页面不一定是进程不会访问的. LRU / FIFO 和 Clock 的比较LRU和FIFO都是先进先出的思路, 只不过LRU是针对页面最近访问时间来进行排序, 所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了). 而FIFO是针对页面进入内存的时间来进行排序, 这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的. 如果一个页面在进入内存后没有被访问, 那么它的最近访问时间就是它进入内存的时间. 换句话说, 如果内存当中的所有页面都未曾访问过, 那么LRU算法就退化为了FIFO算法. 例如 : 给进程分配3个物理页面, 逻辑页面的访问顺序是 : 1,2,3,4,5,6,1,2,3 … 全局页面置换算法工作集模型前面介绍的各种页面置换算法, 都是基于一个前提, 即程序的局部性原理. 但是此原理是否成立? 如果局部性原理不成立, 那么各种页面置换算法就没有说明分别, 也没有什么意义. 例如 : 假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,6,7,8,9…, 即单调递增, 那么在物理页面数有限的前提下, 不管采用何种置换算法, 每次的页面访问都必然导致缺页中断. 如果局部性原理是成立的, 那么如何来证明它的存在, 如何来对它进行定量地分析? 这就是工作集模型. 工作集工作集 : 一个进程当前正在使用的逻辑页面集合. 可以使用一个二元函数 W(t, delta) 来表示 : t 是当前的执行时刻; delta 称为工作集窗口, 即一个定长的页面访问的时间窗口; W(t, delta) = 在当前时刻 t 之前的 delta 时间窗口当中的所有页面所组成的集合(随着 t 的变化, 该集合也在不断的变化) |W(t, delta)| 是工作集的大小, 即逻辑页的数量. 工作集大小的变化 : 进程开始执行后, 随着访问新页面逐步建立较稳定的工作集. 当内存访问的局部性区域的位置大致稳定时, 工作集大小也大致稳定; 局部性区域的位置改变时, 工作集快速扩张和收缩过渡到下一个稳定值. 常驻集常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合. 工作集是进程在运行过程中固有的性质, 而常驻集取决于系统分配给进程的物理页面数目, 以及所采用的页面置换算法; 如果一个进程的整个工作集都在内存当中, 即常驻集 包含 工作集, 那么进程将很顺利地运行, 而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态); 当进程常驻集的大小达到某个数目之后, 再给它分配更多的物理页面, 缺页率也不会明显下降. 工作集页置换算法当工作集窗口在滑动过程中, 如果页面不在集合中, 那么就会直接丢失这个不在窗口中页面, 而不会等待缺页中断再丢弃. 缺页率置换算法可变分配策略 : 常驻集大小可变. 例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小. 可采用全局页面置换的方式, 当发生一个缺页中断时, 被置换的页面可以是在其他进程当中, 各个并发进程竞争地使用物理页面. 优缺点 : 性能较好, 但增加了系统开销. 具体实现 : 可以使用缺页率算法来动态调整常驻集的大小. 缺页率 : 表示 “缺页次数 / 内存访问次数” 影响因素 : 页面置换算法, 分配给进程的物理页面数目, 页面本身的大小, 程序的编写方法. 抖动问题 如果分配给一个进程的物理页面太少, 不能包含整个的工作集, 即常驻集 属于 工作集, 那么进程将会造成很多的缺页中断, 需要频繁的在内存与外存之间替换页面, 从而使进程的运行速度变得很慢, 我们把这种状态称为 “抖动”. 产生抖动的原因 : 随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以OS要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡. 第七章 第七章的主要内容是：进程 进程(process)描述进程定义进程 : 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程. 进程的组成进程包括 : 程序的代码 程序处理的数据 程序计数器中的值, 指示下一条将运行的指令 一组通用的寄存器的当前值, 堆, 栈 一组系统资源(如打开的文件) 进程和程序的联系 : 程序是产生进程的基础 程序的每次运行构成不同的进程 进程是程序功能的体现 通过多次执行, 一个程序可以对应多个进程, 通过调用关系, 一个进程可包括多个程序. 进程和程序的区别 : 进程是动态的, 程序是静态的 : 程序是有序代码的集合. 进程是程序的执行, 进程有核心态 / 用户态. 进程是暂时的, 程序是永久的. 进程是一个状态变化的过程, 程序可以长久保存. 进程和程序的组成不同 : 进程的组成包括程序, 数据和进程控制块(进程状态信息) 进程的特点动态性 : 可动态地创建, 结果进程; 并发性 : 进程可以被独立调度并占用处理机运行; (并发:一段, 并行:一时刻) 独立性 : 不同进程的工作不相互影响;(页表是保障措施之一) 制约性 : 因访问共享数据, 资源或进程间同步而产生制约. 抛出了一个问题 : 如果你要设计一个OS, 怎么样来实现其中的进程管理机制? 进程控制结构描述进程的数据结构 : 进程控制块 (Process Control Block) 操作系统为每个进程都维护了一个PCB, 用来保存与该进程有关的各种状态信息. 进程控制块 : 操作系统管理控制进程运行所用的信息集合. 进程的创建 : 为该进程生成一个PCB 进程的终止 : 回收它的PCB 进程的组织管理 : 通过对PCB的组织管理来实现 (PCB具体包含什么信息? 如何组织的? 进程的状态转换?) PCB有以下三大类信息 : 进程标志信息. 如本进程的标志, 本进程的产生者标志(父进程标志). 用户标志 处理机状态信息保存区 : 保存进程的运行现场信息 : 用户可见寄存器. 用户程序可以使用的数据, 地址等寄存器 控制和状态寄存器. 如程序计数器(PC), 程序状态字(PSW) 栈指针. 过程调用, 系统调用, 中断处理和返回时需要用到它 进程控制信息 调度和状态信息. 用于操作系统调度进程并占用处理机使用. 进程间通信信息. 为支持进程间与通信相关的各种标志, 信号, 信件等, 这些信息都存在接收方的进程控制块中. 存储管理信息. 包含有指向本进程映像存储空间的数据结构. 进程所用资源. 说明由进程打开, 使用的系统资源. 如打开的文件等. 有关数据结构的链接信息. 进程可以连接到一个进程队列中, 或连接到相关的其他进程的PCB. 进程的组织方式 链表 : 同一状态的进程其PCB成一链表, 多个状态对应多个不同的链表.(各状态的进程形成不同的链表 : 就绪链表, 阻塞链表) 索引表 : 同一状态的进程归入一个index表(由index指向PCB), 多个状态对应多个不同的index表(各状态的进行形成不同的索引表 : 就绪索引表, 阻塞索引表) 进程状态(state)进程的生命期管理进程创建引起进程创建的3个主要事件 : 系统初始化; 用户请求创建一个新进程; 正在运行的进程执行了创建进程的系统调用. 进程运行内核选择一个就绪的进程, 让它占用处理机并执行 (为何选择?如何选择?) 进程等待(阻塞)在以下情况下, 进程等待(阻塞): 请求并等待系统服务, 无法马上完成 启动某种操作, 无法马上完成 需要的数据没有到达 进程只能自己阻塞自己, 因为只有进程自身才能知道何时需要等待某种事件的发生. 进程唤醒唤醒进程的原因 : 被阻塞进程需要的资源可被满足 被阻塞进程等待的事件到达 将该进程的PCB插入到就绪队列 进程只能被别的进程或操作系统唤醒 进程结束在以下四种情况下, 进程结束 : 正常退出(自愿) 错误退出(自愿) 致命错误(强制性) 被其他进程杀死(强制性) 进程状态变化模型进程的三种基本状态 : 进程在生命结束前处于三种基本状态之一. 不同系统设置的进程状态数目不同. 三种基本状态 运行状态(Running) : 当一个进程正在处理机上运行时 就绪状态(Ready) : 一个进程获得了除处理机之外的一切所需资源, 一旦得到处理机即可运行 等待状态(阻塞状态 Blocked) : 一个进程正在等待某一时间而暂停运行时. 如等待某资源, 等待输入/输出完成. 进程其它的基本状态 创建状态(New) : 一个进程正在被创建, 还没被转到就绪状态之前的状态 结束状态(Exit): 一个进程正在从系统中消失时的状态, 这是因为进程结束或由于其它原因所导致. 可能的状态变化如下 : NULL → New : 一个新进程被产生出来执行一个程序 New → Ready: 当进程创建完成并初始化后, 一切就绪准备运行时, 变为就绪状态 Ready → Running : 处于就绪态的进程被进程调度程序选中后, 就分配到处理机上来运行 Running → Exit : 当进程表示它已经完成或者因出错, 当前运行进程会由操作系统作结束处理 Running → Ready : 处于运行状态的进程在其运行过程中, 由于分配它的处理机时间片用完而让出处理机 Running → Blocked: 当进程请求某样东西且必须等待时 Blocked → Ready : 当进程要等待某事件到来时, 它从阻塞状态变到就绪状态 进程挂起进程挂起, 为了合理且充分地利用系统资源. 进程在挂起状态时, 意味着进程没有占用内存空间, 处在挂起状态的进程映像在磁盘上.(把进程放到磁盘上) 两种挂起状态 阻塞挂起状态 : 进程在外存并等待某事件的出现; 就绪挂起状态 : 进程在外存, 但只要进入内存, 即可运行. 与挂起相关的状态转换 挂起 : 把一个进程从内存转到外存, 可能有以下几种情况 : 阻塞到阻塞挂起 : 没有进程处于就绪状态或就绪进程要求更多内存资源时, 会进行这种转换, 以提交新进程或运行时就绪进程. 就绪到就绪挂起 : 当有高优先级阻塞(系统认为会很快就绪的)进程和低优先级就绪进程时, 系统会选择挂起低优先级就绪进程. 运行到就绪挂起 : 对抢先式分时系统, 当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时, 系统可能会把运行进程转导就绪挂起状态. 在外存时的状态转换 : 阻塞挂起到就绪挂起 : 当有阻塞挂起因相关事件出现时, 系统会把阻塞挂起进程转换为就绪挂起进程. 解挂, 激活 : 把一个进程从外存转到内存; 可能有以下几种情况 : 就绪挂起到就绪 : 没有就绪进程或挂起就绪进程优先级高于就绪进程时, 会进行这种转换. 阻塞挂起到阻塞 : 当一个进程释放足够内存时, 系统会把一个高优先级阻塞挂起(系统认为会很快出现所等待的事件)进程转换为阻塞进程. 抛出一个问题 : OS怎么通过PCB和定义的进程状态来管理PCB, 帮助完成进程的调度过程? 状态队列 由操作系统来维护一组队列, 用来表示系统当中所有进程的当前状态; 不同的状态分别用不同的队列来表示(就绪队列, 各种类型的阻塞队列); 每个进程的PCB都根据它的状态加入到相应的队列当中, 当一个进程的状态发生变化时, 它的PCB从一个状态中脱离出来, 加入到另外一个队列. 线程(thread)为什么使用线程?实例 : 编写一个MP3播放软件. 核心功能 : (1)从MP3音频文件中读取数据; (2)对数据进行解压缩; (3)把解压缩后的音频数据播放出来. 1234567//单进程方式while(1)&#123; Read(); Decompress(); Play();&#125;//问题: 播放出来的声音能否连贯? 各个函数之间不是并发执行, 影响资源的使用效率. 123456789101112131415//多进程//进程1while(1)&#123; Read();&#125;//进程2while(1)&#123; Decompress();&#125;//进程3while(1)&#123; Play();&#125;//问题: 进程之间如何通信,共享数据?另外,维护进程的系统开销较大://创建进程时,分配资源,建立PCB;撤销进程时,回收资源,撤销PCB;进程切换时,保存当前进程的状态信息 因此需要提出一种新的实体, 满足以下特征: 实体之间可以并发执行; 实体之间共享相同的地址空间. 这实体就是线程. 什么是线程线程是进程当中的一条执行流程. 从两个方面重新理解进程: 从资源组合的角度: 进程把一组相关的资源组合起来,构成了一个资源平台(环境),包括地址空间(代码段,数据段),打开的文件等各种资源; 从运行的角度: 代码在这个资源平台上的一条执行流程(线程). 线程 = 进程 - 共享资源 线程的优缺点线程的优点: 一个进程中可以同时存在多个线程; 各个线程之间可以并发地执行; 各个线程之间可以共享地址空间和文件等资源. 线程的缺点: 一个线程崩溃, 会导致其所属进程的所有线程崩溃.(给它了”权限”就得有更高的”责任”) 线程所需的资源 不同的线程需要独立的寄存器和堆栈, 共享代码,数据和文件等. 线程和进程的比较 进程是资源分配单位, 线程是CPU调度单位; 进程拥有一个完整的资源平台, 而线程只独享必不可少的资源, 如寄存器和栈; 线程同样具有就绪,阻塞和执行三种基本状态,同样具有状态之间的转换关系; 线程能减少并发执行的时间和空间开销: 线程的创建时间比进程短;(直接利用所属进程的一些状态信息) 线程的终止时间比进程短;(不需要考虑把这些状态信息给释放) 同一进程内的线程切换时间比进程短;(同一进程不同线程的切换不需要切换页表) 由于同一进程的各线程之间共享内存和文件资源, 可直接进行不通过内核的通信.(直接通过内存地址读写资源) 线程的实现主要有三种线程的实现方式: 用户线程 : 在用户空间实现; POSIX Pthreads, Mach C-threads, Solaris threads 内核线程 : 在内核中实现; Windows, Solaris, Linux 轻量级进程: 在内核中实现,支持用户线程; Solaris 用户线程 操作系统只能看到进程, 看不到线程, 线程的TCB在线程库中实现; 在用户空间实现的线程机制, 它不依赖于操作系统的内核, 由一组用户级的线程库来完成线程的管理, 包括进程的创建,终止,同步和调度等. 由于用户线程的维护由相应的进程来完成(通过线程库函数),不需要操作系统内核了解用户进程的存在,可用于不支持线程技术的多进程操作系统; 每个进程都需要它自己私有的线程控制块(TCB)列表,用来跟踪记录它的各个线程的状态信息(PC,栈指针,寄存器),TCB由线程库函数来维护; 用户线程的切换也是由线程库函数来完成,无需用户态/核心态切换,所以速度特别快; 允许每个进程拥有自定义的线程调度算法. 用户线程的缺点: 阻塞性的系统调用如何实现?如果一个线程发起系统调用而阻塞,则整个进程在等待; 当一个线程开始运行时,除非它主动地交出CPU的使用权,否则它所在的进程当中的其他线程将无法运行; 由于时间片分配给进程,所以与其他进程比,在多线程执行时,每个线程得到的时间片较少,执行会较慢. 内核线程 操作系统能够看到进程也可能看到线程,线程在内核中实现; 内核线程是在操作系统的内核当中实现的一种线程机制,由操作系统的内核来完成线程的创建,终止和管理. 在支持内核线程的操作系统中,由内核来维护进程和线程的上下文信息(PCB和TCB); 线程的创建,终止和切换都是通过系统调用,内核函数的方式来进行,由内核来完成,因此系统开销较大; 在一个进程当中,如果某个内核线程发起系统调用而被阻塞,并不会影响其他内核线程的运行; 时间片分配给线程,多线程的进程获得更多CPU时间; Windows NT 和 Windows 2000/XP 支持内核线程. 轻量级进程 它是内核支持的用户线程.一个进程可以有一个或多个轻量化进程,每个量级进程由一个单独的内核线程来支持.(Solaris,Linux) 上下文切换停止当前运行进程(从运行状态变成其他状态),并且调度其他进程(转变为运行状态) 必须在切换之前存储许多部分的进程上下文 必须能够在之后恢复他们,所以进程不能显示它曾经被暂停过 必须快速(上下文切换时非常频繁) 需要存储什么上下文? 寄存器(PC,SP…),CPU状态等信息 一些时候可能会费时,所以我们应该尽可能避免 操作系统为活跃进程准备了进程控制块 操作系统将进程控制块放置在一个合适的队列中 就绪队列 等待IO队列(每个设备的队列) 僵尸队列 进程控制创建进程fork()的简单实现 对子进程分配内存 复制父进程的内存和CPU寄存器到子进程 开销昂贵 在99%的情况下,我们在调用fork()之后调用exec() 在fork()操作中内存复制是没有作用的 子进程将可能关闭打开的文件和连接 开销因此是最高的 为什么不能结合它们在一个调用中(OS/2, windows)? vfork() 一个创建进程的系统调用,不需要创建一个同样的内存映像 一些时候称为轻量级fork() 子进程应该几乎立即调用exec() 现在不再使用如果我们使用 copy on write 技术 加载和执行进程系统调用exec()加载程序取代当前运行的进程 exec()调用允许一个进程”加载”一个不同的程序并且在main开始执行(事实上 _start) 它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv) 如果调用成功(相同的进程,不同的程序) 代码,stack,heap重写 123456789int pid = fork(); //创建子进程if(pid == 0) &#123; //子进程 exec_status = exec(&quot;calc&quot;, argc, argv0,argv1,...); printf(&quot;Why would I execute?&quot;);&#125; else if(pid &gt; 0) &#123; //父进程 printf(&quot;Whose your daddy?&quot;); ... child_status = wait(pid);&#125; 等待和终止进程wait()系统调用是被父进程用来等待子进程的结束 一个子进程向父进程返回一个值,所以父进程必须接受这个值并处理 wait()系统调用担任这个要求 它使父进程去睡眠来等待子进程的结束 当一个子进程调用exit()的时候,操作系统解锁父进程,并且将通过exit()传递得到的返回值作为wait调用的一个结果(连同子进程的pid一起)如果这里没有子进程存活,wait()立刻返回 当然,如果这里有为父进程的僵尸等待,wait()立即返回其中一个值(并且解除僵尸状态) 进程结束执行之后,它调用exit() 这个系统调用: 将这程序的”结果”作为一个参数 关闭所有打开的文件,连接等等 释放内存 释放大部分支持进程的操作系统结构 检查是否父进程是存活着的: 如果是的话,它保留结果的值直到父进程需要它;在这种情况里,进程没有真正死亡,但是它进入了僵尸状态 如果没有,它释放所有的数据结构,这个进程死亡 清理所有等待的僵尸进程 进程终止是最终的垃圾收集(资源回收) 第八章 第八章的主要内容是：调度算法(感觉清华这门课程前几章比较精彩,后续讲的有点混乱) 背景上下文切换 切换CPU的当前任务, 从一个进程/线程到另一个 保存当前进程/线程在PCB/TCB中的执行上下文(CPU状态) 读取下一个进程/线程的上下文 CPU调度 从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程 调度程序: 挑选进程/线程的内核函数(通过一些调度策略) 什么时候进行调度? 内核运行调度程序的条件(满足一条即可) 一个进程从运行状态切换到等待状态 一个进程被终结 不可抢占 调度程序必须等待事件结束 可以抢占 调度程序在中断被相应后执行 当前的进程从运行切换到就绪, 或者一个进程从等待切换到就绪 当前运行的进程可以被换出 调度原则 调度策略 人们通常都需要”更快”的服务 什么是更快? 传输文件时的高带宽 玩游戏时的低延迟 这两个因素是独立的 和水管类比 低延迟: 喝水的时候想要一打开水龙头水就流出来 高带宽: 给游泳池充水时希望从水龙头里同时流出大量的水,并且不介意是否存在延迟 我们的目标: 减少响应时间: 及时处理用户的输出并且尽快将输出提供给用户 减少平均响应时间的波动: 在交互系统中,可预测性比高差异性低平均更重要 增加吞吐量: 减少开销(操作系统开销,上下文切换);系统资源的高效率用(CPU,IO设备) 减少等待时间: 减少每个进程的等待时间 程序执行模型 执行模型 : 程序在CPU突发和IO中交替 每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU 在时间分片机制下,线程可能在结束当前CPU突发前被迫放弃CPU 评价指标 CPU使用率: CPU处于忙状态所占时间的百分比 吞吐量: 在单位时间内完成的进程数量 周转时间: 一个进程从初始化到结束,包括所有等待时间所花费的时间 等待时间: 进程在就绪队列中的总时间 响应时间: 从一个请求被提交到产生第一次相应所花费的总时间 各指标在操作系统上的表现: 低延迟调度增加了交互式表现(如果移动了鼠标,但是屏幕中的光标却没动,我们可能会重启电脑) 操作系统需要保证低吞吐量不受影响(我想要结束长时间的编程,所以操作系统必须不时进行调度,即使存在许多交互任务) 吞吐量是操作系统的计算带宽 响应时间是操作系统的计算延迟 公平的目标 举例: 保证每个进程占用相同的CPU时间 这公平嘛?如果一个用户比其他用户运行更多的进程怎么办 举例: 保证每个进程都等待相同的时间 公平通常会增加平均响应时间 调度算法 FCFS(先来先服务) First come, First Served 如果进程在执行中阻塞,队列中的下一个会得到CPU 优点: 简单 缺点: 平均等待时间波动较大 花费时间少的任务可能排在花费时间长的任务后面 可能导致IO和CPU之间的重叠处理(CPU密集型进程会导致IO设备闲置时,IO密集型进程也在等待) SPN(SJF) SRT(短进程优先(短作业优先)短剩余时间优先)[最优平均等待时间] Shortest Process Next(Shortest Job First) Shortest Remaining Time 选择预测的完成时间来将任务入队 可以是抢占的或者是不可抢占的 可能导致饥饿 连续的短任务流会使场任务饥饿 短任务可用时的任何场任务的CPU时间都会增加平均等待时间 需要预测未来 怎么预估下一个CPU突发的持续时间 简单的解决: 询问用户 如果用户欺骗就杀死进程 如果不知道怎么办? HRRN(最高响应比优先) Highest Response Ratio Next Round Robin(轮循) 使用时间切片和抢占来轮流执行任务 在叫做量子(或者时间切片)的离散单元中分配处理器 时间片结束时,切换到下一个准备好的进程 花销: 额外的上下文切换 时间量子太大: 等待时间过长 极限情况退化成FCFS 时间量子太小: 反应迅速 吞吐量由于大量的上下文切换开销受到影响 目标: 选择一个合适的时间量子 经验规则: 维持上下文切换开销处于1%以内 Multilevel Feedback Queues(多级反馈队列) 优先级队列中的轮循 就绪队列被划分成独立的队列: 比如前台(交互),后台(批处理) 每个队列拥有自己的调度策略: 比如前台(RR),后台(FCFS) 调度必须在队列间进行: 固定优先级: 先处理前台,然后处理后台;可能导致饥饿 时间切片: 每个队列都得到一个确定的能够调度其进程的CPU总时间;比如80%使用RR的前台,20%使用FCFS的后台 一个进程可以在不同的队列中移动 例如,n级优先级-优先级调度在所有级别中,RR在每个级别中 时间量子大小随优先级级别增加而增加 如果任务在当前的时间量子中没有完成,则降到下一个优先级 优点: CPU密集型任务的优先级下降很快;IO密集型任务停留在高优先级 Fair Share Scheduling(公平共享调度) FSS控制用户对系统资源的访问 一些用户组比其他用户组更重要 保证不重要的组无法垄断资源 未使用的资源按照每个组所分配的资源的比例来分配 没有达到资源使用率目标的组获得更高的优先级 评价方式确定性建模: 确定一个工作量,然后计算每个算法的表现 队列模型: 用来处理随机工作负载的数学方法 实现/模拟: 建立一个允许算法运行实际数据的系统;最灵活,最具一般性 实时调度 实时系统 定义: 正确性依赖于其时间和功能两方面的一个操作系统 性能指标: 时间约束的及时性;速度和平均性能相对不重要 主要特征: 时间约束的可预测性 分类: 强实时系统: 需要在保证时间内完成重要的任务,必须完成 弱实时系统: 要求重要的进程的优先级更高,尽量完成,并非必须 任务(工作单元): 一次计算,一次文件读取,一次信息传递等 属性: 去的进展所需要的资源;定时参数. 单调速率(RM) 最佳静态优先级调度 通过周期安排优先级 周期越短优先级越高 执行周期最短的任务 截止日期最早优先(EDF) 最佳的动态优先级调度 Deadline越早优先级越高 执行Deadline最早的任务 多处理器调度多处理器的CPU调度更复杂: 多个相同的单处理器组成一个多处理器 优点: 复杂共享 对称多处理器(SMP) 每个处理器运行自己的调度程序 需要在调度程序中同步 优先级反转可以发生在任务基于优先级的可抢占的调度机制中 当系统内的环境强制使高优先级任务等待低优先级任务时发生 第九章 第九章的主要内容是：同步 背景第一章到第八章内容, 到目前为止 多道程序设计: 现代操作系统的重要特性 并行很有用(为什么?) 提示: 多个并发实体: CPU IO 用户 等 进程,线程: 操作系统抽象出来用于支持多道程序设计 CPU调度: 实现多道程序设计的机制 调度算法: 不同的策略 独立的线程: 不和其他线程共享资源或状态 确定性: 输入状态决定结果 可重现: 能够重现起始条件, IO 调度顺序不重要 合作线程: 在多个线程中共享状态 不确定性 不可重现 不确定性和不可重现意味着bug可能是间歇性发生的 进程,线程;计算机,设备需要合作 合作优点: 共享资源 一台电脑,多个用户 一个银行存款余额,多台ATM机 嵌入式系统 加速 IO操作和计算可以重叠 多处理器 模块化 将大程序分解成小程序 gcc会调用cpp,cc1,cc2,as,ld 使系统易于扩展 程序可以调用函数fork()来创建一个新的进程 操作系统需要分配一个新的并且唯一的进程ID 因此在内核中,这个系统调用会运行 new_pid = next_pid++; 翻译成机器指令: Load next_pid Reg1 STORE Reg1 new_pid INC Reg1 STORE Reg1 next_pid 假设两个进程并发执行 如果next_pid等于100, 那么其中一个进程得到的ID应该是100, 另一个进程的ID应该是101, next_pid应该增加到102 可能在INC前进行了上下文切换, 最终导致两个进程的pid都是100,而next_pid也是101 无论多个线程的指令序列怎样交替执行,程序都必须正常工作 多线程程序具有不确定性和不可重现的特点 不经过专门设计,调试难度很高 不确定性要求并行程序的正确性 先思考清楚问题,把程序的行为设计清楚 切忌给予着手编写代码,碰到问题再调试 一些概念前面的现象称为Race Condition(竞态条件) 系统缺陷: 结果依赖于并发执行或者时间的顺序,时间 不确定性 不可重现 怎么样避免竞态? Atomic Operator(原子操作) 原子操作是指一次不存在任何终端或者失败的执行 该执行成功结束 或者根本没有执行 并且不应发生任何部分执行的状态 实际上操作往往不是原子的 有些看上去是原子操作,实际上不是 连x++这样的简单语句,实际上是由三条指令构成的 有时候甚至连单条假期指令都不是原子的(Pipeline,super-scalar,out-of-order,pape fault) 临界区(Critical section)是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域 互斥(Mutual exclusion)是指当一个 进程处于临界区并访问共享资源时,没有其他进程会处于临界区并且访问任何相同的共享资源 死锁(Dead lock)是指两个或以上进程,在相互等待完成特定任务,而最终没法将自身任务进行下去 饥饿(Starvation)是指一个可执行的进程,被调度器持续忽略,以至于虽然处于可执行状态却不被执行 临界区互斥: 同一时间临界区中最多存在一个线程 Progress: 如果一个线程想要进入临界区,那么它最终会成功 有限等待: 如果一个线程i处于入口区,那么在i的请求被接受之前,其他线程进入临界区的时间是有限制的 无忙等待(可选): 如果一个进程在等待进入临界区,那么在它可以进入之前会被挂起 方法1:禁用硬件中断没有中断,没有上下文切换,因此没有并发 硬件将中断处理延迟到中断被启用之后 大多数现代计算机体系结构都提供指令来完成 进入临界区 禁用中断 离开临界区 开启中断 一旦中断被禁用,线程就无法被停止 整个系统都会为你停下来 可能导致其他线程处于饥饿状态 要是临界区可以任意长怎么办? 无法限制响应中断所需的时间(可能存在硬件影响) 要小心使用,适合于较小的操作 方法2:基于软件的解决方案满足进程Pi和Pj之间互斥的经典的基于软件的解决方法(1981年) 使用两个共享数据项 int turn; //指示该谁进入临界区 bool flag[]; //指示进程是否准备好进入临界区 进入临界区: 123flag[i] = true;turn = j;while(flag[j] &amp;&amp; turn == j); 退出临界区: 1flag[i] = false; 实例: 12345678do&#123; flag[i] = true; turn = j; while(flag[j] &amp;&amp; turn == j); CRITICAL SECTION flag[i] = false; REMAINDER SECTION&#125;while(true); Bakery 算法(N个进程的临界区) 进入临界区之前,进程接收一个数字 得到的数字最小的进入临界区 如果进程Pi和Pj收到相同的数字,那么如果i&lt;j,Pi先进入临界区,否则Pj先进入临界区 编号方案总是按照枚举的增加顺序生成数字 Dekker算法(1965): 第一个针对双线程例子的正确解决方案 Bakery算法(1979): 针对n线程的临界区问题解决方案 复杂: 需要两个进程的共享数据项 需要忙等待: 浪费CPU时间 没有硬件保证的情况下无真正的软件解决方案: Perterson算法需要原子的LOAD和STORE指令 方法3:更高级的抽象硬件提供了一些原语 像中断禁用, 原子操作指令等 大多数现代体系结构都这样 操作系统提供更高级的编程抽象来简化并行编程 例如,锁,信号量 从硬件原语中构建 锁是一个抽象的数据结构 一个二进制状态(锁定,解锁),两种方法 Lock::Acquire() 锁被释放前一直等待,然后得到锁 Lock::Release() 锁释放,唤醒任何等待的进程 使用锁来编写临界区 前面的例子变得简单起来: 123lock_next_pid-&gt;Acquire();new_pid = next_pid++;lock_next_pid-&gt;Release(); 大多数现代体系结构都提供特殊的原子操作指令 通过特殊的内存访问电路 针对单处理器和多处理器 Test-and-Set 测试和置位 从内存中读取值 测试该值是否为1(然后返回真或假) 内存值设置为1 交换 交换内存中的两个值 1234567891011bool TestandSet(bool *target)&#123; bool rv = *target; *target = true; return rv;&#125;void Exchange(bool *a, bool *b)&#123; bool tmp = *a; *a = *b; *b = tmp;&#125; 总结 锁是更高等级的编程抽象 互斥可以使用锁来实现 通常需要一定等级的硬件支持 常用的三种实现方法 禁用中断(仅限于单处理器) 软件方法(复杂) 原子操作指令(单处理器或多处理器均可) 可选的实现内容: 有忙等待 无忙等待 第十章 第十章的主要内容是：信号量和管程 信号量信号量的抽象数据类型 一个整形(sem),具有两个原子操作 P(): sem减一,如果sem&lt;0,等待,否则继续 V(): sem加一,如果sem≤0,唤醒一个等待的P 信号量是整数 信号量是被保护的变量 初始化完成后,唯一改变一个信号量的值的办法是通过P()和V() 操作必须是原子 P()能够阻塞,V()不会阻塞 我们假定信号量是公平的 没有线程被阻塞在P()仍然堵塞如果V()被无限频繁调用(在同一个信号量) 在实践中,FIFO经常被使用 两个类型信号量 二进制信号量: 可以是0或1 计数信号量: 可以取任何非负数 两者相互表现(给定一个可以实现另一个) 信号量可以用在2个方面 互斥 条件同步(调度约束——一个线程等待另一个线程的事情发生) 信号量使用 用二进制信号量实现的互斥 12345mutex = new Semaphore(1);mutex-&gt;P();...mutex-&gt;V(); 用二进制信号量实现的调度约束 1234567891011condition = new Semaphore(0);//Thread A...condition-&gt;P(); //等待线程B某一些指令完成之后再继续运行,在此阻塞...//Thread B...condition-&gt;V(); //信号量增加唤醒线程A... 一个线程等待另一个线程处理事情 比如生产东西或消费东西(生产者消费者模式),互斥(锁机制)是不够的 有界缓冲区的生产者-消费者问题 一个或者多个生产者产生数据将数据放在一个缓冲区里 单个消费者每次从缓冲区取出数据 在任何一个时间只有一个生产者或消费者可以访问该缓冲区 正确性要求 在任何一个时间只能有一个线程操作缓冲区(互斥) 当缓冲区为空时,消费者必须等待生产者(调度,同步约束) 当缓存区满,生产者必须等待消费者(调度,同步约束) 每个约束用一个单独的信号量 二进制信号量互斥 一般信号量 fullBuffers 一般信号了 emptyBuffers 123456789101112131415161718192021class BoundedBuffer&#123; mutex = new Semaphore(1); fullBuffers = new Semaphore(0); //说明缓冲区初始为空 emptyBuffers = new Semaphore(n); //同时可以有n个生产者来生产&#125;;BoundedBuffer::Deposit(c)&#123; emptyBuffers-&gt;P(); mutex-&gt;P(); Add c to the buffer; mutex-&gt;V(); fullBuffers-&gt;V();&#125;BoundedBuffer::Remove(c)&#123; fullBuffers-&gt;P(); mutex-&gt;P(); Remove c from buffer; mutex-&gt;V(); emptyBuffers-&gt;V();&#125; 信号量实现使用硬件原语 禁用中断 原子指令 类似锁 禁用中断 1234567891011121314151617181920class Semaphore&#123; int sem; WaitQueue q;&#125;;Semaphore::P()&#123; --sem; if(sem &lt; 0)&#123; Add this thread t to q; block(p); &#125;&#125;;Semaphore::V()&#123; ++sem; if(sem &lt;= 0)&#123; Remove a thread t from q; wakeup(t); &#125;&#125; 信号量的双用途 互斥和条件同步 但等待条件是独立的互斥 读,开发代码比较困难 程序员必须非常精通信号量 容易出错 使用的信号量已经被另一个线程占用 忘记释放信号量 不能够处理死锁问题 管程目的: 分离互斥和条件同步的关注 什么是管程 一个锁: 指定临界区 0或者多个条件变量: 等待,通知信号量用于管程并发访问共享数据 一般方法 收集在对象,模块中的相关共享数据 定义方法来访问共享数据 Lock Lock::Acquire() 等待直到锁可用,然后抢占锁 Lock::Release() 释放锁,唤醒等待者如果有 Condition Variable 允许等待状态进入临界区 允许处于等待(睡眠)的线程进入临界区 某个时刻原子释放锁进入睡眠 Wait() operation 释放锁,睡眠,重新获得锁放回 Signal() operation(or broadcast() operation) 唤醒等待者(或者所有等待者),如果有 实现 需要维持每个条件队列 线程等待的条件等待signal() 1234567891011121314151617181920class Condition&#123; int numWaiting = 0; WaitQueue q;&#125;;Condition::Wait(lock)&#123; numWaiting++; Add this thread t to q; release(lock); schedule(); //need mutex require(lock);&#125;Condition::Signal()&#123; if(numWaiting &gt; 0)&#123; Remove a thread t from q; wakeup(t); //need mutex numWaiting--; &#125;&#125; 管程解决生产者-消费者问题 12345678910111213141516171819202122232425class BoundedBuffer&#123; Lock lock; int count = 0; //buffer 为空 Condition notFull, notEmpty;&#125;;BoundedBuffer::Deposit(c)&#123; lock-&gt;Acquire(); //管程的定义:只有一个线程能够进入管程 while(count == n) notFull.Wait(&amp;lock); //释放前面的锁 Add c to the buffer; count++; notEmpty.Signal(); lock-&gt;Release();&#125;BoundedBuffer::Remove(c)&#123; lock-&gt;Acquire(); while(count == 0) notEmpty.Wait(&amp;lock); Remove c from buffer; count--; notFull.Signal(); lock-&gt;Release();&#125; 开发,调试并行程序很难 非确定性的交叉指令 同步结构 锁: 互斥 条件变量: 有条件的同步 其他原语: 信号量 怎么样有效地使用这些结构 制定并遵循严格的程序设计风格,策略 经典同步问题 读者-写者问题 动机: 共享数据的访问 两种类型的使用者: 读者(不修改数据) 写者(读取和修改数据) 问题的约束: 允许同一时间有多个读者,但在任何时候只有一个写者 当没有写者时,读者才能访问数据 当没有读者和写者时,写者才能访问数据 在任何时候只能有一个线程可以操作共享变量 多个并发进程的数据集共享 读者: 只读数据集;他们不执行任何更新 写者: 可以读取和写入 共享数据 数据集 信号量CountMutex初始化为1 信号量WriteMutex初始化为1 整数Rcount初始化为0(当前读者个数) 读者优先设计 只要有一个读者处于活动状态, 后来的读者都会被接纳.如果读者源源不断的出现,那么写者使用处于阻塞状态. 12345678910111213141516//信号量实现//writersem_wait(WriteMutex);write;sem_post(WriteMutex);//readersem_wait(CountMutex);if(Rcount == 0) sem_wait(WriteMutex); //确保后续不会有写者进入++Rcount;read;--Rcount;if(Rcount == 0) sem_post(WriteMutex); //全部读者全部离开才能唤醒写者sem_post(CountMutex); 写者优先设计 一旦写者就绪,那么写者会尽可能的执行写操作.如果写者源源不断的出现的话,那么读者就始终处于阻塞状态. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//writerDatabase::Write()&#123; Wait until readers/writers; write database; check out - wake up waiting readers/writers;&#125;//readerDatabase::Read()&#123; Wait until no writers; read database; check out - wake up waiting writers;&#125;//管程实现AR = 0; // # of active readersAW = 0; // # of active writersWR = 0; // # of waiting readersWW = 0; // # of waiting writersCondition okToRead;Condition okToWrite;Lock lock;//writerPublic Database::Write()&#123; //Wait until no readers/writers; StartWrite(); write database; //check out - wake up waiting readers/writers; DoneWrite();&#125;Private Database::StartWrite()&#123; lock.Acquire(); while((AW + AR) &gt; 0)&#123; WW++; okToWrite.wait(&amp;lock); WW--; &#125; AW++; lock.Release();&#125;Private Database::DoneWrite()&#123; lock.Acquire(); AW--; if(WW &gt; 0)&#123; okToWrite.signal(); &#125; else if(WR &gt; 0)&#123; okToRead.broadcast(); //唤醒所有reader &#125; lock.Release();&#125;//readerPublic Database::Read()&#123; //Wait until no writers; StartRead(); read database; //check out - wake up waiting writers; DoneRead();&#125;Private Database::StartRead()&#123; lock.Acquire(); while(AW + WW &gt; 0)&#123; //关注等待的writer,体现出写者优先 WR++; okToRead.wait(&amp;lock); WR--; &#125; AR++; lock.Release();&#125;private Database::DoneRead()&#123; lock.Acquire(); AR--; if(AR == 0 &amp;&amp; WW &gt; 0)&#123; //只有读者全部没有了,才需要唤醒 okToWrite.signal(); &#125; lock.Release();&#125; 哲学家就餐问题(学习自 github.com/cyc2018) 共享数据: Bowl of rice(data set) Semaphone fork [5] initialized to 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N // 右邻居#define THINKING 0#define HUNGRY 1#define EATING 2typedef int semaphore;int state[N]; // 跟踪每个哲学家的状态semaphore mutex = 1; // 临界区的互斥，临界区是 state 数组，对其修改需要互斥semaphore s[N]; // 每个哲学家一个信号量void philosopher(int i) &#123; while(TRUE) &#123; think(i); take_two(i); eat(i); put_two(i); &#125;&#125;void take_two(int i) &#123; down(&amp;mutex); state[i] = HUNGRY; check(i); up(&amp;mutex); down(&amp;s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去&#125;void put_two(i) &#123; down(&amp;mutex); state[i] = THINKING; check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了 check(RIGHT); up(&amp;mutex);&#125;void eat(int i) &#123; down(&amp;mutex); state[i] = EATING; up(&amp;mutex);&#125;// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行void check(i) &#123; if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123; state[i] = EATING; up(&amp;s[i]); &#125;&#125; 第十一章 第十一章的主要内容是：死锁和进程通信 死锁问题一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源 示例: 系统有2个磁带驱动器 P1和P2各有一个,都需要另外一个 系统模型资源类型R1,R2,..,Rm(CPU, memory space, IO devices) 每个资源类型Ri有Wi个实例. 每个进程使用资源如下: require,get ← free resource use,hold ← requested,used resource release ← free resource 可重复使用的资源 在一个时间只能有一个进程使用且不能被删除 进程获得资源,后来释放由其他进程重用 处理器,IO通道,主和副存储器,设备和数据结构,如文件,数据库和信号量 如果每个进程拥有一个资源并请求其他资源,死锁可能发生 使用资源 创建和销毁 在IO缓存区的中断,信号,消息,信息 如果接收消息阻塞可能会发生死锁 可能少见的组合事件会引起死锁 资源分配图 一组顶点V和边E的集合 V有两种类型: P={P1,P2,…,Pn},集合包括系统中的所有进程 R={R1,R2,…,Rm},集合包括系统中的所有资源类型 requesting,claiming edge - directed edge Pi → Rj assignment,holding edge - directed edge Rj → Pi 基本情况 如果图中不包含循环: 没有死锁 如果图中包含循环: 如果每个资源类只有一个实例,那么死锁 如果每个资源类有几个实例,可能死锁 死锁特征死锁出现一定会出现以下四个条件,但是出现以下四个条件不一定死锁: 互斥: 在一个时间只能有一个进程使用资源 持有并等待: 进程保持至少一个资源正在等待获取其他进程持有的额外资源 无抢占: 一个资源只能被进程资源释放,进程已经完成了它的任务之后 循环等待: 存在等待进程集合{P0,P1,…,Pn},P0正在等待P1所占用的资源,P1正在等待P2占用的资源…Pn-1在等待Pn的资源,Pn正在等待P0所占用的资源 死锁处理方法常见方法 确保系统永远不会进入死锁状态 运行系统进入死锁状态,然后恢复. 忽略这个问题,假装系统中从来没有发生死锁,用于大多数操作系统,包括UNIX Deadlock Prevention 预防限制申请方式 互斥 - 共享资源不是必须的,必须占用非共享资源 占用并等待 - 必须保证当一个进程请求的资源,它不持有任何其他资源 需要进程请求并分配其所有资源,它开始执行之前或允许进程请求资源仅当进程没有资源 资源利用率低,可能发生饥饿 无抢占 - 如果进程占有某些资源,并请求其他不能被立即分配的资源,则释放当前正占有的资源 被抢占资源添加到资源列表中 只有当它能够获得旧的资源以及它请求新的资源,进程可以得到执行 循环等待 - 对所有资源类型进行排序,并要求每个进程按照资源的顺序进行申请 Deadlock Avoidance 避免需要系统具有一些额外的先验信息提供 最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的最大数目 资源的分配状态是通过限定提供与分配的资源数量,和进程的最大需求 死锁避免算法动态检查的资源分配状态,以确保永远不会有一个环形等待状态 当一个进程请求可用资源,系统必须判断立即分配是否能使系统处于安全状态 系统处于安全状态指: 针对所有进程,存在安全序列 序列&lt;P1,P2,…,Pn&gt;是安全的: 针对每个Pi,Pi要求的资源能够由当前可用的资源+所有的Pj持有的资源来满足,其中j&lt;i. 如果Pi资源的需求不是立即可用,那么Pi可以等到所有Pj完成 当Pi完成后,Pi+1可以得到所需要的资源,执行,返回所分配的资源,并终止. 用同样的方法,Pi+2,Pi+3和Pn能获得其所需的资源. 如果系统处于安全状态→无死锁 如果系统处于不安全状态→可能死锁 避免死锁: 确保系统永远不会进入不安全状态 Deadlock Detection 检测每个资源类型单一实例 Maintain wait-for graph 节点是进程 Pi→Pj: Pi等待Pj 定期调用检测算法来搜索图中是否存在循环 算法需要n^2次操作,n是图中顶点的数目 数据结构: Available: 长度为M的向量表示每种类型可用资源的数量 Allocation: 一个nxm矩阵定义了当前分配给各个进程每种类型资源的数量,如果Alocation[i, j] = k, 进程Pi拥有资源Rj的k个实例 Request: 一个nxm矩阵表示各进程的当前请求.如果Request[i, j] = k,表示进程Pi请求k个资源Pj的实例 具体算法(跳过了,看视频) 检查算法使用 何时,使用什么样的频率来检测依赖于: 死锁多久可能会发生? 多少进程需要被回滚? one for each disjoint cycle 如果检测算法多次被调用,有可能是资源图有多个循环,所以我们无法分辨出多个可能死锁进程中的哪些”造成”死锁 Recovery from Deadlock 恢复终止所有的死锁进程 在一个时间内终止一个进程直到死锁消除 终止进程的顺序应该是: 进程的优先级 进程运行了多久以及需要多少时间才能完成 进程占用的资源 进程完成需要的资源 多少进程需要被终止 进程是交互还是批处理 选择一个受孩子 - 最小的成本 回滚 - 返回到一些安全状态,重启进程到安全状态 饥饿 - 同一进程可能一直被选作受害者,包括回滚的数量 IPC概述进程通信的机制及同步 不使用共享变量的进程通信 IPC facility 提供2个操作: send(message) - 消息大小固定或者可变 receive(message) 如果P和Q想通信,需要: 在它们之间建立通信链路 通过send/recevie交换消息 通信链路的实现 物理(例如,共享内存,硬件总线) 逻辑(例如,逻辑属性) 直接通信进程必须正确的命名对方: send(P, message) - 发送消息到进程P receive(Q, message) - 从进程Q接收信息 通信链路的属性 自动建立链路 一条链路恰好对应一对通信进程 每对进程之间只有一个链路存在 链路可以是单向的,但通常是双向的 间接通信定向从消息队列接收消息 每个消息对垒都有一个唯一的ID 只有它们共享了一个消息队列,进程才能够通信 通信链路的属性 只有进程共享一个共同的消息队列,才建立链路 链接可以与许多进程相关联 每对进程可以共享多个通信链路 链接可以是单向或者双向 操作 创建一个新的消息队列 通过消息队列发送和接收消息 销毁消息队列 原语的定义如下: send(A, message) receive(A, message) 通信链路缓冲 通信链路缓存大小: 0容量 - 0 message : 发送方必须等待接收方 有限容量 - n messages的有限长度 : 发送方必须等待,如果队列满 无限容量 - 无限长度 : 发送方不需要等待 信号信号Signal 软件中断通知事件处理 Examples: SIGFPE, SIGKILL, SIGUSRI, SIGSTOP, SIGCONT 接收到信号时会发生什么? catch: 指定信号处理函数被调用 ignore: 依靠操作系统的默认操作(abort, memory dump, suspend or resume process) mask: 闭塞信号因此不会传送(可能是暂时的,当处理同样类型的信号) 不足: 不能传输要交换的任何数据 管道数据交换 子进程从父进程继承文件描述符(0 stdin, 1 stdout, 2 stderr) 进程不知道(或不关心)从键盘,文件,程序读取或写入到终端,文件,程序. 例如: $ ls | more (两个进程, 管道是缓存,对于ls来说是stdout,对于more来说是stdin ) 消息队列消息队列按FIFO来管理消息 message: 作为一个字节序列存储 message queues: 消息数组 FIFO &amp; FILO configuration 共享内存进程 每个进程都有私有地址空间 在每个地址空间内,明确地设置了共享内存段 优点 快速,方便地共享数据 不足 必须同步数据访问 最快的方法 一个进程写另一个进程立即可见 没有系统调用干预 没有数据复制 不提供同步 Socket 第十二章 第十二章的主要内容是：文件管理 基本概念文件系统和文件文件系统: 一种用于持久性存储的系统抽象 在存储上: 组织,控制,导航,访问和检索数据 在大多数计算机系统包含文件系统 个人电脑,服务器,笔记本电脑 ipod,tivo,机顶盒,手机,电脑 google可能也是由一个文件系统构成的 文件: 文件系统中的一个单元的相关数据在操作系统中的抽象 文件系统的功能: 分配文件磁盘空间 管理文件块(哪一块属于哪一个文件) 管理空闲空间(哪一块是空闲的) 分配算法(策略) 管理文件集合 定位文件及其内容 命名: 通过名字找到文件的接口 最常见: 分层文件系统 文件系统类型(组织文件的不同方式) 提供的便利及特征 保护: 分层来保护数据安全 可靠性,持久性: 保持文件的持久即使发生崩溃,媒体错误,攻击等 文件和块: 文件属性: 名称,类型,位置,大小,保护,创建者,创建时间,最久修改时间… 文件头: 在存储元数据中保存了每个文件的信息,保存文件的属性,跟踪哪一块存储块属于逻辑上文件结构的哪个偏移 文件描述符文件使用模式: 使用程序必须在使用前先”打开”文件 12345f = open(name, flag);...... = read(f, ...);...close(f); 内核跟踪每个进程打开的文件: 操作系统为每个进程维护一个打开文件表 一个打开文件描述符是这个表中的索引 需要元数据来管理打开文件: 文件指针: 指向最近的一次读写位置,每个打开了这个文件的进程都这个指针 文件打开计数: 记录文件打开的次数 - 当最后一个进程关闭了文件时,允许将其从打开文件表中移除 文件磁盘位置: 缓存数据访问信息 访问权限: 每个程序访问模式信息 用户视图: 持久的数据结构 系统访问接口: 字节的集合(UNIX) 系统不会关心你想存储在磁盘上的任何的数据结构 操作系统内部视角: 块的集合(块是逻辑转换单元,而扇区是物理转换单元) 块大小&lt;&gt; 扇区大小: 在UNIX中, 块的大小是 4KB 当用户说: 给我2-12字节空间时会发生什么? 获取字节所在的快 返回快内对应部分 如果要写2-12字节? 获取块 修改块内对应部分 写回块 在文件系统中的所有操作都是在整个块空间上进行的: getc() putc() 即使每次只访问1字节的数据,也会缓存目标数据4096字节(一个磁盘块) 用户怎么访问文件: 在系统层面需要知道用户的访问模式 顺序访问: 按字节依次读取(几乎所有的访问都是这种方式) 随机访问: 从中间读写(不常用,但是仍然重要,如: 虚拟内存支持文件,内存页存储在文件中;更加快速,不希望获取文件中间的内容的时候也必须先获取块内所有字节) 内容访问: 通过特征 文件内部结构: 无结构: 单词,比特的队列 简单记录结构: 列,固定长度,可变长度 复杂结构: 格式化的文档(word, PDF), 可执行文件, … 多用户系统中的文件共享是很必要的 访问控制: 谁能够获得哪些文件的哪些访问权限 访问模式: 读,写,执行,删除,列举等 文件访问控制列表(ACL): &lt;文件实体, 权限&gt; UNIX模式: &lt;用户|组|所有人,读|写|可执行&gt; 用户ID识别用户,表明每个用户所允许的权限及保护模式 组ID允许用户组成组,并指定了组访问权限 指定多用户,客户如何同时访问共享文件: 和过程同步算法相似 因磁盘IO和网络延迟而设计简单 UNIX文件系统(UFS)语义: 对打开文件的写入内容立即对其他打开同一文件的其他用户可见 共享文件指针允许多用户同时读取和写入文件 会话语义: 写入内容只有当文件关闭时可见 锁: 一些操作系统和文件系统提供该功能 目录文件以目录的方式组织起来 目录是一类特殊的文件: 每个目录都包含了一张表&lt;name, pointer to file header&gt; 目录和文件的树形结构: 早期的文件系统是扁平的(只有一层目录) 层次名称空间: /spell/mail/prt/first /programs/p/list 典型操作: 搜索文件 创建文件 删除文件 枚举目录 重命名文件 在文件系统中遍历一个路径 操作系统应该只允许内核模式修改目录: 确保映射的完整性,应用程序能够读目录(ls) 文件名的线性列表,包含了指向数据块的指针: 编程简单,执行耗时 Hash表 - hash数据结构的线性表: 减少目录搜索时间,碰撞,固定大小 名字解析: 逻辑名字转换成物理资源(如文件)的过程: 在文件系统中: 到实际文件的文件名(路径) 遍历文件目录直到找到目标文件 举例: 解析”/bin/ls”: 读取root的文件头(在磁盘固定位置) 读取root的数据块: 搜索bin项 读取bin的文件头 读取bin的数据块: 搜索ls项 读取ls的文件头 当前工作目录: 每个进程都会指向一个文件目录用于解析文件名 允许用户指定相对路径来代替绝对路径 一个文件系统需要先挂载才能被访问 一个未挂载的文件系统被挂载在挂载点上 文件别名两个或多个文件名关联同一个文件: 硬链接: 多个文件项指向一个文件 软链接: 以快捷方式指向其他文件 通过存储真实文件的逻辑名称来实现 如果删除一个有别名的文件会如何呢? : 这个别名将成为一个悬空指针 Backpointers 方案: 每个文件有一个包含多个backpointers的列表,所以删除所有的Backpointers backpointers使用菊花链管理 添加一个间接层: 目录项数据结构 链接: 已存在文件的另外一个名字(指针) 链接处理: 跟随指针来定位文件 我们如何保证没有循环呢? 只允许到文件的链接, 不允许在子目录的链接 每增加一个新的链接都用循环检测算法确定是否合理 限制路径可遍历文件目录的数量 文件系统种类磁盘文件系统: 文件存储在数据存储设备上,如磁盘; 例如: FAT,NTFS,ext2,3,ISO9660等 数据库文件系统: 文件根据其特征是可被寻址的; 例如: WinFS 日志文件系统: 记录文件系统的修改,事件; 例如: journaling file system 网络,分布式文件系统: 例如: NFS,SMB,AFS,GFS 特殊,虚拟文件系统 虚拟文件系统分层结构: 顶层: 文件,文件系统API 上层: 虚拟(逻辑)文件系统 (将所有设备IO,网络IO全抽象成为文件,使得接口一致) 底层: 特定文件系统模块 目的: 对所有不同文件系统的抽象 功能: 提供相同的文件和文件系统接口 管理所有文件和文件系统关联的数据结构 高效查询例程,遍历文件系统 与特定文件系统模块的交互 数据结构: 卷[第四声]控制块(UNIX: “superblock”) 每个文件系统一个 文件系统详细信息 块,块大小,空余块,计数,指针等 文件控制块(UNIX: “vnode” or “inode”) 每个文件一个 文件详细信息 许可,拥有者,大小,数据库位置等 目录节点(Linux: “dentry”) 每个目录项一个(目录和文件) 将目录项数据结构及树形布局编码成树形数据结构 指向文件控制块,父节点,项目列表等 其中: 卷控制块(每个文件系统一个),文件控制块(每个文件一个),目录节点(每个目录项一个) 持续存储在二级存储中: 在分配在存储设备中的数据块中 当需要时加载进内存: 卷控制块: 当文件系统挂载时进入内存 文件控制块: 当文件被访问时进入内存 目录节点: 在遍历一个文件路径时进入内存 数据块缓存数据块按需读入内存: 提供 read() 操作 预读: 预先读取后面的数据块 数据块使用后被缓存: 假设数据将会再次被使用 写操作可能被缓存和延迟写入 两种数据块缓存方式: 普通缓冲区缓存 页缓存: 同一缓存数据块和内存页 分页要求: 当需要一个页时才将其载入内存 支持存储: 一个页(在虚拟地址空间中)可以被映射到一个本地文件中(在二级存储中) 打开文件的数据结构打开文件描述: 每个被打开的文件一个 文件状态信息 目录项,当前文件指针,文件操作设置等 打开文件表: 一个进程一个 一个系统级的 每个卷控制块也会保存一个列表 所以如果有文件被打开将不能被卸载 一些操作系统和文件系统提供该功能 调节对文件的访问 强制和劝告: 强制 - 根据锁保持情况和需求拒绝访问 劝告 - 进程可以查找锁的状态来决定怎么做 文件分配大多数文件都很小: 需要对小文件提供强力的支持 块空间不能太小 一些文件非常大: 必须支持大文件(64-bit 文件偏移) 大文件访问需要相当高效 如何为一个文件分配数据块 分配方式: 连续分配 链式分配 索引分配 指标: 高效: 如存储利用(外部碎片) 表现: 如访问速度 连续分配: 文件头指定起始块和长度 位置,分配策略: 最先匹配,最佳匹配,… 优势: 文件读取表现好;高效的顺序和随机访问 劣势: 碎片;文件增长问题 链式分配: 文件以数据块链表方式存储 文件头包含了到第一块和最后一块的指针 优势: 创建,增大,缩小很容易;没有碎片 劣势: 不可能进行真正的随机访问;可靠性 索引分配: 为每个文件创建一个名为索引数据块的非数据数据块(到文件数据块的指针列表) 文件头包含了索引数据块 优势: 创建,增大,缩小很容易;没有碎片;支持直接访问 劣势: 当文件很小时,存储索引的开销大;处理大文件难 空闲空间列表跟踪在存储中的所有未分配的数据块 空闲空间列表存储在哪里? 空闲空间列表的最佳数据结构怎么样? 用位图代表空闲数据块列表: 11111101101110111 如果 i = 0表明数据块i是空闲的,反之是分配的 使用简单但是可能会是一个big vector: 160GB disk → 40M blocks → 5MB worth of bits 然而,如果空闲空间在磁盘中均匀分布,那么再找到”0”之前需要扫描 磁盘上数据块总数 / 空闲块的数目 需要保护: 指向空闲列表的指针 位图: 必须保存在磁盘上;在内存和磁盘拷贝可能有所不同;不允许block[i]在内存中的状态为bit[i]=1而在磁盘中bit[i]=0 解决: 在磁盘上设置bit[i] = 1; 分配block[i]; 在内存中设置bit[i] = 1 多磁盘管理 - RAID通常磁盘通过分区来最大限度减小寻道时间: 一个分区是一个柱面的集合 每个分区都是逻辑上独立的磁盘 分区: 硬件磁盘的一种适合操作系统指定格式的划分 卷: 一个拥有一个文件系统实例的可访问的存储空间(通常常驻在磁盘的单个分区上) 使用多个并行磁盘来增加: 吞吐量(通过并行),可靠性和可用性(通过冗余) RAID - 冗余磁盘阵列: 各种磁盘管理技术;RAID levels: 不同RAID分类,如RAID-0,RAID-1,RAID-5 实现: 在操作系统内核: 存储,卷管理; RAID硬件控制器(IO) RAID-0 数据块分成多个子块, 存储在独立的磁盘中: 和内存交叉相似 通过更大的有效块大小来提供更大的磁盘带宽 RAID-1 可靠性成倍增长 读取性能线性增加(向两个磁盘写入,从任何一个读取) RAID-4 数据块级磁带配有专用奇偶校验磁盘: 允许从任意一个故障磁盘中恢复 条带化和奇偶校验按byte-by-byte或者bit-by-bit: RAID-0,4,5: block-wise ;RAID-3: bit-wise RAID-5 每个条带快有一个奇偶校验块,允许有一个磁盘错误 RAID-6 两个冗余块,有一种特殊的编码方式,允许两个磁盘错误 磁盘调度读取或写入时,磁头必须被定位在期望的磁道,并从所期望的扇区开始 寻道时间: 定位到期望的磁道所花费的时间 旋转延迟: 从扇区的开始处到到达目的处花费的时间 平均旋转延迟时间 = 磁盘旋转一周时间的一半 寻道时间是性能上区别的原因 对单个磁盘,会有一个IO请求数目 如果请求是随机的,那么会表现很差 FIFO: 按顺序处理请求 公平对待所有进程 在有很多进程的情况下,接近随机调度的性能 最短服务优先: 选择从磁臂当前位置需要移动最少的IO请求 总是选择最短寻道时间 skan: 磁臂在一个方向上移动,满足所有为完成的请求,直到磁臂到达该方向上最后的磁道 调换方向 c-skan: 限制了仅在一个方向上扫描 当最后一个磁道也被访问过了后,磁臂返回到磁盘的另外一端再次进行扫描 c-loop(c-skan改进): 磁臂先到达该方向上最后一个请求处,然后立即反转","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"深入理解操作系统学习笔记","slug":"深入理解操作系统学习笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C++11新语法新特性使用剖析","slug":"C++/C++11","date":"2020-11-03T15:27:00.000Z","updated":"2020-11-24T14:13:22.675Z","comments":true,"path":"2020/11/03/C++/C++11/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/03/C++/C++11/","excerpt":"C++ 11 还记得自己在本科阶段学习的C++98的语法，那个时候觉得很有趣了。但是慢慢地接触到了C++11之后的新增语法，打开了新世界的大门，许多实现有了更有禅意/哲学的方法。 本文参考了侯捷老师 C++2.0 的课程以及CSDN上众多的博客，总结了C++11以来，新增的一些语法，比如：variadic templates、alias templates、uniform initialization等，新增的一些关键词，比如：explicit、override、final、decltype等。我认为，C++11以来新增的语法是C++发展中的新鲜血液，在STL的源码学习过程中，也看到了许多C++11以来的新语法，新关键词。所以说，学习C++11是十分有必要且有趣的。 C++版本发展 名称 版本 备注 C++ 98 1.0 C++ 03 TR1 technicasl report 1 C++ 11… 2.0","text":"C++ 11 还记得自己在本科阶段学习的C++98的语法，那个时候觉得很有趣了。但是慢慢地接触到了C++11之后的新增语法，打开了新世界的大门，许多实现有了更有禅意/哲学的方法。 本文参考了侯捷老师 C++2.0 的课程以及CSDN上众多的博客，总结了C++11以来，新增的一些语法，比如：variadic templates、alias templates、uniform initialization等，新增的一些关键词，比如：explicit、override、final、decltype等。我认为，C++11以来新增的语法是C++发展中的新鲜血液，在STL的源码学习过程中，也看到了许多C++11以来的新语法，新关键词。所以说，学习C++11是十分有必要且有趣的。 C++版本发展 名称 版本 备注 C++ 98 1.0 C++ 03 TR1 technicasl report 1 C++ 11… 2.0 新语法新语法包括但不限于以下介绍的：variadic templates(可变参数模板)、move(搬移)、range-base for loop(简写循环)、initializer list(新容器)、lambda(表达式)、type_traits(类型萃取器)、unordered_set/map(hashtable)、forward_list(单向链表)、tuple(元组)、con-currency、RegEx… variadic templatesnullptrnullptr 是C++11后安全的指针空值常量，是一个类型为 std::nullptr_t 的对象。 在C语言中，我们常用NULL来表示指针为空。那我们可以先看一下在C语言和在C++中 NULL 的定义。 1234567891011//C#define NULL ((void*)0)//C++#ifndef NULL#ifdef _cplusplus#define NULL 0 //可以看到,在C++中NULL就是0#else#define NULL ((void*)0)#endif#endif 如果沿用C语言中 NULL 的定义，在C++中有函数重载的机制，会出现二义性的问题，如下。 1234567891011//二义性实例#undef NULL#define NULL ((void*)0)void func(int n)&#123;&#125;void func(char* cp)&#123;&#125;int main()&#123; func(NULL); return 0;&#125; 可以得到二义性的报错，因为 NULL 的 ((void*)0) 既可以被 5: 接收，也可以被 6: 接收。 为避免二义性的错误，C++不支持void*转换为其他指针类型。因此有了 nullptr，定义在 &lt;cstddef&gt; 中的一个新类型 std::nullptr_t，可以隐式转换为任意指针类型，是一个”指针空值常量”。 nullptr的安全性 12345//安全性示例int n1 = nullptr;int n2 = (int)nullptr;int n3 = reinterpret_cast&lt;int&gt;(nullptr);//以上三行均报错 可以看到此时，nullptr 无法隐式显式强制类型转换为其他非指针类型。 POD type / =default &amp; =delete首先来了解一下 POD 类型。 POD( plain old data)：能够使用C标准库中的memcpy()函数操作的数据类型和结构体就是POD类型。可以通过中的 is_pod&lt;T&gt;::value 来判定。 C++相比C语言多了虚函数，继承，访问权限等机制，往往定义的类不是POD类型，无法使用memcpy()。那么成为 POD 类型有以下两个要求： 该类型必须是平凡的普通的 (平凡 : trival : &lt;type_traits&gt; 中常见的一个词了) 不自己定义构造函数，析构函数，拷贝构造函数，拷贝赋值函数，搬移构造函数和搬移赋值函数，而是由编译器默认生成，那么就是平凡的。 或者，在自己定义了构造函数(以上只有构造函数可以重载)后，再增加一行ClassName() = default;也可以算得上是平凡的。 不能够有虚函数或者继承虚基类。（不能携带虚表指针） 123456class base&#123;public: base(int a)&#123;&#125;; base() = default;&#125;;//is_pod(base)::value == true_type() 像C标准布局一样，布局有序 非静态成员变量的访问权限必须相同。 如果继承了父类，那么第一个成员变量必须是自己类的。 如果继承了父类，那么成员得集中在一个类中。 如果满足了以上两点，可以使用 memcpy() 函数。 1234567891011121314151617//POD类型进行memcpy()示例class A&#123;public: int a; int b;&#125;;int main()&#123; A a1; a1.a = 10; a1.b = 20; char* p = new char[sizeof(a1)]; memcpy(p,&amp;a1,sizeof(a1)); A* a2 = reinterpret_cast&lt;A*&gt;(p); cout &lt;&lt; a2-&gt;a &lt;&lt; &quot; &quot; &lt;&lt; a2-&gt;b &lt;&lt; endl; return 0;&#125; =default : 可以指定需要编译器自动生成 big five 的函数。可以在重载其他构造函数的情况下，仍然使得类可能成为 POD 类型。 =delete : 对于不希望使用的构造函数，析构函数，拷贝构造函数，拷贝赋值函数，搬移构造函数和搬移赋值函数，曾经的做法是定义在 private 域中并不给予实现使得无法调用。而现在可以写在 public 域中并在最后写上 =delete 意为不能使用。用户函数可以 =delete 而不可以使用 =default。 Rvalue references &amp; Move Semantics / Perfect Forwardingmove是一个C++11后的重要话题，它极大地节约了原本copy时，析构以及拷贝构造的时间成本。 要聊move首先得了解一下左值和右值的概念，以及左值引用和右值引用的区别。 左值 : 在堆区栈区常量区(.bss / .data)中有内存分配的变量/对象。特点 : 可以放在 operator= 左侧。 右值 : 不能够取地址或者是消亡值。如：运算式，除字符串以外的字面值，临时变量/对象，返回 void 的函数调用。 ​ 消亡值 : 即将销毁的变量/对象。 左值引用 : 引用本质上是取别名，使用引用语法，编译器会为引用动作进行一定的翻译以及在使用时会自动解引用。引用对象如果是一个左值，那么T &amp;ref = val;引用等效于T * const ref = val; ，如果引用对象是一个右值，那么需要在引用前加一个const修饰,如:const T &amp;ref = 16。 右值引用 : 通过”盗取”右值资源而不需要分配额外的资源，获得控制权。在确保之后不再使用该右值，可以避免内存空间的释放和分配，延迟变量名的生命周期，常用来完成移动构造 (move constructor) 和移动赋值 (move assignment) 的特殊任务。 std::move() : 可以把左值转换为右值，但是前提是程序员要确保后续不再使用传递的左值。 123//std::move() 示例vector&lt;int&gt; vec&#123;1,3,2,5,4,1,2,3,4,6,7,9&#125;;vector&lt;int&gt; target = std::move(vec); //省去了元素的拷贝,虽然int类型是微不足道的,但是如果是特别大的对象的话,很值得 搬移机制 如果把右值传递给需要move_ctor 或 move_assign 的时候，会触发搬移机制，首先指针浅拷贝，再断开右值的指针控制。 如果把左值传递给需要move_ctor 或 move_assign 的时候，可以使用 std::move() 可以把左值转换成右值。 万能引用 在模板编程的时候，有时候并不知道传进来的是左值还是右值，因此引入了万能引用和引用折叠的概念。万能引用：在类型推导中 &amp;&amp; 符号可以接收左值也可以接收右值。 引用折叠 12345//引用折叠示例template&lt;typename T&gt;void func(T&amp;)&#123;&#125;template&lt;typename T&gt;void func(T&amp;&amp;)&#123;&#125; 当传入的 T 类型本身就是一个左值引用或者右值引用类型时，形式参数类型会出现T&amp; &amp; T&amp; &amp;&amp; T&amp;&amp; &amp; T&amp;&amp; &amp;&amp; 其中，T&amp;&amp; &amp;&amp; 会被解析成为 T &amp;&amp; 其余，被解析成为 T &amp; 不完美转发 使用函数传递右值时，最终调用端接收到的是左值。 123456789//不完美转发 示例//重载的分别接收左值和右值的函数void process(int &amp; i) &#123; cout &lt;&lt; &quot;&amp;&quot; &lt;&lt; endl; &#125;void process(int&amp;&amp; i) &#123; cout &lt;&lt; &quot;&amp;&amp;&quot;&lt;&lt; endl; &#125;//转发函数void forward(int&amp;&amp; i)&#123; cout &lt;&lt; &quot;forward &amp;&amp;&quot; &lt;&lt; endl; process(i); //此处期望调用的是process(int&amp;&amp;),但是实际上调用的是process(int&amp;)&#125; 完美转发 123456//完美转发设计形式template&lt;typename T1, typename T2&gt;void functionA(T1&amp;&amp; t1, T2&amp;&amp; t2)&#123; functionB(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));&#125; 1234567891011121314151617181920212223//完美转发 forward&lt;T&gt;() 的源码// GCC/4.9.2/.../move.htemplate&lt;typename _Tp&gt;constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept&#123; return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#125;template&lt;typename _Tp&gt;constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept&#123; //编译期断言 static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value,&quot;template argument&quot; &quot; substituting _Tp is an lvalue reference type&quot;); return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#125;//std::move()template&lt;typename _Tp&gt;constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;move(_Tp&amp;&amp; __t) noexcept&#123; return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); &#125; range-based for statement语法用法如下。 123456789101112131415161718//语法for(decl : coll)&#123; statement&#125;编译器翻译-&gt;for(auto _pos = coll.begin(), _end = coll.end(); _pos != _end; ++_pos)&#123; decl = *_pos; statement&#125;//用法for(int i : &#123;1,2,3,4,5,6,7&#125;) std::cout &lt;&lt; i &lt;&lt; std::endl;vector&lt;double&gt; vecfor(auto &amp; elem : vec) //使用引用传递可以修改元素 elem *= 3; thread 线程库智能指针pragma once1#pragma once 确保头文件只会被包含一次。 extern “C”在C++的代码中运行C语言的代码 123456789#ifdef __cplusplusextern &quot;C&quot; &#123; //抑制C++对函数名、变量名等符号进行名称重整，因此编译出的C目标文件和C++目标文件中的变量名和函数名都一样的。#endif...#ifdef __cplusplus&#125;#endif 类初始化列表常量表达式enum classtupleuniform initialization / initializer_listsC++11前的初始化方式众多，容易记混且不美观不一致。C++11后有统一的推荐的初始化方式。 12345678910// C++11 前的初始化语法Rect r1 = &#123;3,5,8,20,&amp;area,&amp;print);Rect r1(3,7,20,25);int ia[6] = &#123;27,210,12,47,10,83&#125;;// C++11 后的初始化语法int values[]&#123;1,2,3&#125;;vector&lt;int&gt; v&#123;1,2,3,4,5,6&#125;; // vector 包含了一个 initializer_list&lt;value_type&gt; 的构造函数vector&lt;string&gt; cities&#123;&quot;berlin&quot;,&quot;london&quot;,&quot;new york&quot;&#125;;//编译器把&#123;t1,t2,...,tn&#125;制作成一个 initializer_list&lt;T&gt; 关联一个 array&lt;T,n&gt; 会调用构造函数 &#123;&#125; 创建了一个initializer_lists的容器。 接下来介绍 initializer_lists容器的用法和源码。 12345678910111213141516171819202122232425//用法//用于赋初值int i; //未知int j&#123;&#125;; //j == 0int *p; //未知int *q&#123;&#125;; //q == nullptr//initializer_lists 不能类型转换,更加安全int x1(5.3), x2 = 5.3; //传统的方式会把double隐式类型转换为intint x3&#123;5.0&#125;,x4&#123;5.3&#125;; //取决于编译器char c1&#123;7&#125;; //正确char c2&#123;999999&#125;; //错误vector&lt;int&gt; v1&#123;1,2,3,4&#125;; //正确vector&lt;int&gt; v2&#123;1,2.0,3.0,4&#125;; //错误//函数显式接收 initializer_lists 类型void print(std::initializer_list&lt;int&gt; vals)&#123; for(auto p = vals.begin();p!=vals.end();++p) cout&lt;&lt; *p &lt;&lt; endl;&#125;print(&#123;1,2,3,4,5&#125;);//利用临时对象筛选max(&#123;1,2,3,4,5,6&#125;);min(&#123;string(&quot;Ace&quot;),string(&quot;Bob&quot;),string(&quot;Coc&quot;)&#125;); 1234567891011121314151617//源码template&lt;class _E&gt;class initializer_list&#123;public: typedef _E value_type; ...private: iterator _M_array; //只管理指针,拷贝时是浅拷贝 size_type _M_len; //The compiler can call this constructfunction constexpr initializer_list(const iterator _a, size_type _l): _M_array(_a),_M_len(_l) &#123;&#125;public: //其他构造函数 lambda lambda 是希腊符号之一，第一次是在python中听到这个词，后在java中也接触到。现在来讲讲C++11/13中的lambda语法。 lambda 在C++中是一种匿名函数。我们通常来说，使用一个函数是为了提高代码的可复用性以及可读性，我们会在主函数外或者源文件外定义函数，最终通过链接生成可执行文件。那么对于一些我们只需要用到个别次数的代码，我们不需要为它命名并且写成函数的形式，我们只需要写一个 lambda 表达式即可。 lambda 属于函数式编程范式的范畴。 语法1[capture list](parameters) mutable -&gt; return type &#123; statement &#125; [capture list] : 捕获列表 [var] : 值传递的方式捕获 var [=] : 值传递的方式捕获所有变量 [&amp;var] : 引用传递的方式捕获var [&amp;] : 引用传递的方式捕获所有变量 [this] : 值传递的方式捕获this (parameters) : 参数传递列表，可以省略 mutable : 修饰符，取现 lambda 的常量性，但是必须携带参数传递列表，可以省略 (mutable 允许可以变化, 不加的话, 语句块中无法修改变量) [id] () mutable {} : 允许修改 id [&amp;id] () {} : 允许修改 id [id] () {} : 不允许修改 id -&gt;return type : 返回值类型，不需要返回或者返回值类型明确时可以省略 { statement } : lambda 语句块 示例1234567891011121314//示例1int a = 1, b =2, c = 3;auto func = [=,&amp;b](int d) -&gt; decltype(a+b+c+d)&#123; return a+b+c+d;&#125;std::cout &lt;&lt; func(4) &lt;&lt; std::endl;/* 说明** 以引用方式捕获变量 b, 使得 b 可以在语句块中被修改, 以值方式捕获变量 a,c 不可以在语句块中修改** 参数列表需要传入一个int类型变量** decltype() 做类型推导** func 是 lambda 表达式的名称 可以以 6: 方式调用** auto lambda 表达式的返回类型相当复杂,使用auto自动推导较为合适*/ 1234567//示例2[]&#123; std::cout &lt;&lt; &quot;success&quot; &lt;&lt; std::endl;&#125;(); //创建了一个lambda的临时对象auto L = []&#123;std::cout &lt;&lt; &quot;success&quot; &lt;&lt; std::endl;&#125;;L(); //lambda 表达式调用形式 12345678//示例3vector&lt;int&gt; vec&#123;1,2,3,3,4,5,8,5,4,3&#125;;sort(vec.begin(),vec.end(),[](int a,int b)-&gt;bool&#123; return a&gt;b;&#125;); //第三个参数需要一个bool的函数对象,可以是自定义函数也可以是仿函数也可以是lambda表达式for (const auto &amp;elem : vec) &#123; cout &lt;&lt; elem &lt;&lt; endl;&#125; //倒序输出vec的值 12345//注意事项int id = 0;auto f = [id]()&#123;&#125;; //此处捕获到的是0,即使后续变化也不会受影响auto g = [&amp;id]()&#123;&#125;;//此处捕获到的是0,但是后续id的变化会引起此处的变化id = 42; 123456789101112131415161718//lambda表达式需要编译器进行&quot;翻译&quot;//类似翻译情况如下auto f = [id]() mutable &#123; std::cout &lt;&lt; &quot;id:&quot; &lt;&lt; id &lt;&lt; std::endl; ++id; &#125;;-&gt; class Functor&#123;private: int id;public: Functor(int id):id(id)&#123;&#125; void operator()&#123; std::cout &lt;&lt; &quot;id:&quot; &lt;&lt; id &lt;&lt; std::endl; ++id; &#125;&#125;Functor f; 新关键词新关键词包括但不限于以下介绍的：using、auto、explicit、noexcept、override、final、decltype… using / Alias Template / Type Aliasusing 关键字并不是C++11以后才出现的，但是在C++11以后赋予了新的语法。 namespace using-指示 : using namespace std; 引入整个命名空间 会引发命名污染，使得较小作用域中定义的同名函数、变量会覆盖命名空间中的函数和变量。在较大的作用域中应当使用 using-声明 using-声明 : using std::cout, std::endl; 引入命名空间中的指定变量、对象、函数 class membersusing-声明 在类中声明基类的对象或方法后，可以省略基类作用域。 12345678910//使用using关键字对类成员变量成员函数的声明class base&#123;public: void based()&#123;&#125;&#125;;class derived : public base&#123; using base::based; void func()&#123; based(); &#125;// 不需要写成 base::based()&#125;; Alias TemplateAlias 熟悉配置 linux / Mac OS 系统环境的小伙伴都知道，是化名的意思。这是C++11新增的语法，能够提前绑定模板参数。用法如下： 12345//使用using关键字对类模板进行运行时绑定参数template&lt;typename T&gt;using MapString = map&lt;T,char*&gt;;MapString&lt;int&gt; numberString; //解析成 map&lt;int,char*&gt; numberString： 从以上代码可以看到，2:提前绑定了map容器的第二参数，此后模板参数只剩下一个了，在定义对象时只需要指定第一模板参数即可。有一种&lt;运行时&gt;偏特化的感觉。侯捷老师提供了一个案例，是对使用 alias template 的较好诠释。 1234567891011121314//侯捷老师的例子template&lt;typename T, template&lt;class&gt; class Container&gt;class XCLs&#123;private: Container&lt;T&gt; c;public: XCLs()&#123;&#125;&#125;;XCLs&lt;int,vector&gt; xcls; //报错,因为vector容器实际上需要两个参数,这样传入只能确认一个参数template&lt;T&gt;using vec = vector&lt;T,allocator&lt;T&gt;&gt;;XCLs&lt;int,vec&gt; xcls; //正确,提前绑定第二参数 因为 vector 模板类本身有两个模板参数 : _Tp 和 alloc，而 alloc 是有默认参数的。所以，平时使用时，我们往往缺省第二参数只指定第一个模板参数类型。而 5:Container&lt;T&gt; c 只指定了第一参数，因此在 2: 传入 Container 时就提前确定第二参数，因此有了 13: Alias Template 的操作。 Type Alias类似于 typedef 的语法。（结果看来和 typedef 一样） 123456789101112131415161718//using关键字定义新类型名typedef void(*func1)(int,int); //func1 绑定为 void x(int,int) 型函数指针using func2 = void(*)(int,int); //结果同 1://演示1void example(int a, int b);func1 fn1 = example;func2 fn2 = example;//演示2template&lt;typename T&gt;class vector&#123;public: using ValueType = T; using reference = T&amp;; using iterator = T*; using pointer = T*; //vector中的实现还是typedef&#125; autoexplicit常用于修饰构造函数，使得构造函数不支持其他变量隐式类型转换成该类型对象（禁止隐式类型转换） 123456789101112131415161718192021222324class base&#123;private: int a; int b;public: base(int a,int b = 0)&#123;&#125; // non-explicit one-argument ctor base&amp; operator=(const base&amp; ref)&#123; this-&gt;a = ref.a; this-&gt;b = ref.b; &#125; base operator+(const base&amp; ref)&#123; this-&gt;a += ref.a; this-&gt;b += ref.b; return *this; &#125;&#125;;int main()&#123; base obj1(1,0),obj2(2,0); obj2 = obj1 + 5; //如果6:不使用 explicit 修饰,首先看到了重载了operator+接收本类型. 此处 5 转换成为 base 类的临时对象 (5,0) 和 obj1 相加 //如果6:使用 explicit 修饰,不允许隐式类型转换,找不到operator+接收数值类型类别的重载,因此报错 &#125; C++11前，只支持 one-argument C++11后，支持 multi-argument noexcept异常是一门大学问。在程序中必须处理异常，如果不处理，异常会传递给调用端，直到 std::terminate() 然后调用 std::abort() 结束程序。 1234567//c++17void foo() noexcept; //等价于 void foo() noexcept(true);void swap(Type&amp; x, Type&amp; y) noexcept(noexcept(x.swap(y)))&#123; //如果 x.swap(y) 不产生异常,那么保证函数不产生异常 x.swap(y); ...&#125; 12345678910111213141516171819202122//在搬移构造和搬移赋值时的应用// you need to inform C++(specially std::vector) that your move constructor and destructor does not throw.// that the move constructor will be called when the vector grows.// if the constructor is not noexcept, std::vector can&#x27;t use it.// since then it can&#x27;t ensure the exception guarantees demanded by the standard.// 自定义的类型,必须告知vector,你这个类型的搬移构造和搬移赋值是不会抛出异常的,vector在成长过程中才敢使用class MyString&#123;private: char * _data; size_t _len;...public: // move constructor MyString(MyString&amp;&amp; str) noexcept : _data(str),_len(str._len) &#123;&#125; // move assignment MyString&amp; operator=(MyString&amp;&amp; str) noexcept &#123; ... return *this; &#125;&#125;;//只有对拷贝构造和拷贝赋值函数用 noexcept 修饰,vector&lt;MyString&gt; 的时候才会考虑 std::move overrideoverride 编译器会检查你是否是在重写父类的虚函数 12345678910111213141516struct Base&#123; virtual void vfunc(float)&#123;&#125;&#125;;struct Drived : Base&#123; virtual void vfunc(int)&#123;&#125; //C++11前的语法如此,一旦虚函数写错就会出现问题&#125;;/**************/struct Drived : Base&#123; //写错,报错 virtual void func(int) override &#123;&#125; //C++11后增加的 override 修饰词, 可以检查当前函数是否是基类的虚函数(检查:返回类型,函数名,参数列表) //写对 virtual void func(float) override &#123;&#125;&#125;; final后置修饰类名：说明该类在继承体系中无法被继承 : struct base final &#123;&#125;; 后置修饰虚函数：不允许该虚函数在子类中重写 123class CPoint2D final&#123; virtual void Draw() final;&#125; decltypedecltype(表达式) : 返回 表达式的类型 在编译期完成 : decltype(a*b) 相关内容 : typeid() 可以返回一个类型的id，可以用于判断两个类别是否相同，但是无法用于声明该类型的变量 : if(typeid(T::iterator) == typeid(forward_iterator) 12345map&lt;string, float&gt; coll;...//在你定义很久以后,忘记某个类型或者自己不知道它的类型的时候,使用类型推导十分方便decltype(coll)::value_type elem; // 编译器编译期内翻译成为 map&lt;string, float&gt;::value_type elem; 主要用法 函数返回类型时使用 decltype() 1234567template&lt;typename T1, typename T2&gt;decltype(x+y) add(T1&amp; x, T2&amp; y); //使用 decltype() 可以在写函数的时候不知道处理完之后到底要返回什么类型,要取决于 x+y 的返回类型’但是以上写法编译不会通过,因为 decltype 处不知道 x 和 y 是什么符号template&lt;typename T1, typename T2&gt;auto add(T1&amp; x, T2&amp; y) -&gt; decltype(x+y); lambda函数返回类型时使用 decltype() 12345678[...](...) mutable -&gt; decltype(...) &#123;...&#125;auto cmp = [](const Person&amp; p1, const Person&amp; p2) &#123; return p1.lastname() &lt; p2.lastname() || (p1.lastname() == p2.lastname() &amp;&amp; p1.firstname() &lt; p2.firstname());&#125;;//通过decltype(cmp) 传入比较的匿名函数std::set&lt;Person,decltype(cmp)&gt; coll(cmp); 用于确认一个对象的类型时使用 decltype() 1typedef typename decltype(obj)::iterator itype; //使用类作用域运算符 :: 时, 必修需要加 typename","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"C++11","slug":"C/C-11","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/C-11/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"C++11","slug":"C-11","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C-11/"}]},{"title":"理解 type_traits","slug":"STL/STL-type traits","date":"2020-10-31T09:42:00.000Z","updated":"2020-11-24T14:17:56.083Z","comments":true,"path":"2020/10/31/STL/STL-type traits/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/31/STL/STL-type%20traits/","excerpt":"__type_traits &lt;__type_traits.h&gt; 是 SGI 版本的 STL 的实现，其他版本的 STL 没有去调研过是否存在类型萃取。但是侯捷老师的源码剖析已经过去了那么多年，我相信比较好的一些实现，还是会被其他版本进行借鉴的。","text":"__type_traits &lt;__type_traits.h&gt; 是 SGI 版本的 STL 的实现，其他版本的 STL 没有去调研过是否存在类型萃取。但是侯捷老师的源码剖析已经过去了那么多年，我相信比较好的一些实现，还是会被其他版本进行借鉴的。 前一篇文章是 iterator_traits 迭代器萃取器，可以感受到，迭代器的萃取器会萃取出迭代器的元数据 : value_type difference_type pointer reference iterator_category。其中最重要的 iterator_category 元数据对一些算法进行选择有很大的帮助。 相同的，__type_traits 负责萃取类型的元数据，比如 : 某类型是否拥有不重要的默认构造函数 has_trivial_default_constructor 。在迭代器萃取器中的 iterator_category 会回答五种类型，在类型萃取器中只会回答两种类型：__true_type __false_type。 1234struct __true_type&#123;&#125;;struct __false_type&#123;&#125;;// 不需要实现,进行函数调用时,需要不同的类型才能够进行类型推导// 而不能是只回答同样bool类型的 : true / false _type_traits 源码1234567891011121314151617181920212223242526272829303132333435363738394041// __type_traits 的写法// 泛化__type_traitstemplate&lt;class type&gt;struct __type_traits&#123; typedef __true_type this_dummy_member_must_be_first; typedef __false_type has_trivial_default_constructor; typedef __false_type has_trivial_copy_constructor; typedef __false_type has_trivial_assignment_constructor; typedef __false_type has_trivial_destructor; typedef __false_type is_POD_type;&#125;;/* 原则:** trivial 是不重要的,回答 false. 即有重要的四种基本函数** 保守起见,为所有的类型都设定为重要的构造和拷贝和析构*///特别多的特化__type_traitstypedef template&lt;&gt; __STL_TEMPLATE_NULL;__STL_TEMPLATE_NULL struct __type_traits&lt;char&gt;&#123; //具体萃取 char 类型的元数据 //C语言内置类型 都是以下的回答 typedef __true_type has_trivial_default_constructor; typedef __true_type has_trivial_copy_constructor; typedef __true_type has_trivial_assignment_constructor; typedef __true_type has_trivial_destructor; typedef __true_type is_POD_type;&#125;;//... 许多其他类型的类型萃取特化版本//特别的,指针类型也可以进行萃取template&lt;typename T&gt;struct __type_traits&lt;T*&gt;&#123; typedef __true_type has_trivial_default_constructor; typedef __true_type has_trivial_copy_constructor; typedef __true_type has_trivial_assignment_constructor; typedef __true_type has_trivial_destructor; typedef __true_type is_POD_type;&#125;; __type_traits 实例来源于 侯捷老师 的例子 1234567891011121314151617181920212223242526272829303132333435363738//入口函数template&lt;class ForwardIterator, class Size, class T&gt;inline ForwardIteratoruninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x)&#123; return __uninitialized_fill_n(first, n, x, iterator_traits&lt;ForwardIterator&gt;::value_type);&#125;//萃取“工具人”template&lt;class ForwardIterator, class Size, class T, class T1&gt;inline ForwardIterator__uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x, T1*)&#123; typedef typename type_traits&lt;T1&gt;::is_POD_type is_POD; return __uninitialized_fill_n_aux(first, n, x, is_POD());&#125;//实际上根据 is_POD 属性进行类型推导选择执行以下两个函数中的一个//可以看到,这边如果是用true false来回答的话,这边就无法根据类型推导来选择不同函数了template&lt;class ForwardIterator, class Size, class T&gt;ForwardIterator__uninitialized_fill_n_aux(ForwardIterator first, Size n, const T&amp; x,__false_type)&#123; ForwardIterator cur = first; for( ; n &gt; 0; --n, ++cur) construct(&amp;*cur, x); return cur;&#125;template&lt;class ForwardIterator, class Size, class T&gt;inline ForwardIterator__uninitialized_fill_n_aux(ForwardIterator first, Size n, const T&amp; x,__true_type)&#123; return fill_n(first, n, x);&#125; 融入 STL如果不自己写一个特化版本的话，萃取该自定类型时，萃取结果会认为你的四种函数(构造、拷贝构造、拷贝赋值、析构)都是重要的，但是事实上如果不重要可以提高某一些算法的效率，因此如果真的不重要，就应该在特化版本中告诉编译器。 123456789//比如有一个自定义的 class shapetemplate&lt;&gt;__type_traits&lt;shape&gt;&#123; typedef __true_type has_trivial_default_constructor; typedef __false_type has_trivial_copy_constructor; typedef __false_type has_trivial_assignment_constructor; typedef __false_type has_trivial_destructor; typedef __false_type is_POD_type;&#125;; 学习自侯捷老师：《STL源码剖析》","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"迭代器","slug":"C/STL/迭代器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"iterator","slug":"iterator","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/iterator/"}]},{"title":"理解 iterator_traits","slug":"STL/STL-iterator traits","date":"2020-10-30T06:46:00.000Z","updated":"2020-11-24T14:17:39.448Z","comments":true,"path":"2020/10/30/STL/STL-iterator traits/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/30/STL/STL-iterator%20traits/","excerpt":"iteratoriterator 意为迭代器，是常见的23种设计模式中的一种。","text":"iteratoriterator 意为迭代器，是常见的23种设计模式中的一种。 iterator模式 使该对象能够依序遍历整个容器所含的各个元素，不需要暴露容器的底层实现。 在 STL 的框架里，有六个部分：容器、迭代器、算法、分配器、适配器、仿函数。 其中迭代器是一个有名有姓的重要的组成部分。可以说，迭代器是容器与算法的桥梁或者说是胶水。有了迭代器，使得算法可以不直接作用与特定的容器，使得算法更加地泛化。( OXygen : 算法只需要依据迭代器支持的操作不同而做不同的策略, 而不是针对数量众多的容器, 一一做出不同的操作) 可以看一个示例： 12345678template &lt;class InputIterator, class T&gt; InputIterator find(InputIterator first, InputIterator last, const T&amp; value)&#123; while(first != last &amp;&amp; *first != value) ++first; return first;&#125; 我们只需要提供一组迭代器以及一个代查找的数据就可以实现查找，而不需要让函数知道容器是什么样子。 iterator_traits介绍迭代器用五种类型分别是： Input Iterator (重载 ++) Output Iterator Forward Iterator (重载 ++) Bidirectional Iterator (重载 ++ --) Random Access Iterator (重载 ++ -- +n -n [] - &lt;) 其中有继承关系 : iterator_traits 的代码迭代器的萃取器要为所有迭代器都能够萃取出想要的属性，但是也得为指针和常量指针萃取出想要的属性。因为指针也是一种迭代器，并且是支持随机访问的迭代器(指针可以靠地址偏移随机访问)。 123456789101112131415161718192021222324252627template&lt;class Iterator&gt;struct iterator_traits&#123; typedef typename Iterator::iterator_category iterator_category; typedef typename Iterator::value_type value_type; typedef typename Iterator::difference_type difference_type; typedef typename Iterator::pointer pointer; typedef typename Iterator::reference reference;&#125;;//偏特化template&lt;class T&gt;struct iterator_traits&lt;T*&gt;&#123; typedef typename random_access_iterator_tag iterator_category; typedef typename T value_type; typedef typename ptrdiff_t difference_type; typedef typename T* pointer; typedef typename T&amp; reference; &#125;;template&lt;class T&gt;struct iterator_traits&lt;const T*&gt;&#123; typedef typename random_access_iterator_tag iterator_category; typedef typename T value_type; typedef typename ptrdiff_t difference_type; typedef typename T* pointer; typedef typename T&amp; reference; &#125;; 以上为 iterator_traits 的代码，主要包含一个泛化的版本和两个针对指针和常量指针的版本。 iterator_traits的利用与设计我们有一个针对于元素唯一且有序的容器，实现搜索，提供的是首尾迭代器，那么我们对于不同类型的迭代器就得有不同的实现 ： 针对于 vector queue 容器，迭代器类型为 Random Access Iterator，我们可以使用二分搜索； 针对于 list forward-list 容器，迭代器类型为 Forward Iterator 或 Bidirectional Iterator，我们只能使用迭代来搜索。 因此，我们可以设计两种函数，一种针对于 Random Access Iterator 实现，一种针对于 Input Iterator 实现。(因为继承关系，无法完美匹配 Random Access Iterator 的话，都会去调用 Input Iterator 的版本) 以下代码是自己完成，欢迎讨论，关于页面有我的微信，添加请备注。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//以上方案#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;list&gt;#include &lt;type_traits&gt;using namespace std;/******************************/// 用于判定迭代器的类型属性(iterator_category)template &lt;typename InputIterator&gt;bool is_random_access_iterator(InputIterator iterator)&#123; typedef typename iterator_traits&lt;InputIterator&gt;::iterator_category category; return (typeid(category()) == typeid(random_access_iterator_tag()));&#125;template &lt;typename InputIterator&gt;bool is_input_iterator(InputIterator iterator)&#123; typedef typename iterator_traits&lt;InputIterator&gt;::iterator_category category; return (typeid(category()) == typeid(input_iterator_tag()));&#125;/******************************//******************************/// 内部函数:实现了针对 Random_Access_Iterator 的版本 和 Input_Iterator 的版本template&lt;typename RandomAccessIterator, typename Value&gt;inline RandomAccessIterator mySearch_RI(RandomAccessIterator first, RandomAccessIterator last, Value n)&#123; // 返回找到的迭代器,否则返回 last if(first &gt; last) return last; while(first &lt; last)&#123; RandomAccessIterator mid = first + ((last - first) &gt;&gt; 1); if(*mid &lt; n)&#123; first = mid + 1; &#125;else if(*mid &gt; n)&#123; last = mid; //因为 [first,last) &#125;else&#123; return mid; &#125; &#125; return last;&#125;template&lt;typename InputIterator, typename Value&gt;inline InputIterator mySearch_II(InputIterator first, InputIterator last, Value n)&#123; // 返回找到的迭代器,否则返回 last while(first != last)&#123; if(*first == n) return first; first++; &#125; return last;&#125;/******************************/// 调用函数template&lt;typename InputIterator, typename Value&gt;inline InputIterator mySearch(InputIterator first, InputIterator last, Value n)&#123; if(is_input_iterator(first)) &#123; return mySearch_II(first, last, n); &#125; else if(is_random_access_iterator(first))&#123; return mySearch_RI(first,last,n); &#125;&#125;int main() &#123; //经过测试,链表的调用会出现错误,还不知道具体是什么原因,如果你知道的话,可以联系一下我 vector&lt;int&gt; vec(&#123;1,2,3,4,5,6,7&#125;); vector&lt;int&gt;::iterator it; if((it = mySearch(vec.begin(),vec.end(),5)) != vec.end()) cout &lt;&lt; &quot;找到了元素&quot; &lt;&lt; *it &lt;&lt; &quot;索引值为&quot; &lt;&lt; it - vec.begin() &lt;&lt; endl;// list&lt;int&gt; lst;// lst.push_back(20);// lst.push_back(30);// lst.push_back(15);// list&lt;int&gt;::iterator it2;// if((it2 = mySearch(lst.begin(),lst.end(),15)) != lst.end())// cout &lt;&lt; &quot;找到了元素&quot; &lt;&lt; *it &lt;&lt; endl; return 0;&#125; 但是，这样的代码通过调用函数来判断传入的迭代器是什么类型，无法在编译期内确认，效率不够。因此，采用 iterator_traits 就能提高效率。 123456//&lt;iterator&gt;头文件中包含了标签的继承关系struct input_iterator_tag&#123;&#125;;struct output_iterator_tag&#123;&#125;;struct forward_iterator_tag : public input_iterator_tag&#123;&#125;;struct bidirectional_iterator_tag : public forward_iterator_tag&#123;&#125;;struct random_access_iterator_tag : public bidirectional_iterator_tag&#123;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;list&gt;#include &lt;type_traits&gt;using namespace std;template&lt;typename InputIterator, typename Value&gt;inline InputIterator _mySearch( InputIterator first, InputIterator last, Value n, random_access_iterator_tag ) &#123; // 返回找到的迭代器,否则返回 last if(first &gt; last) return last; while(first &lt; last)&#123; InputIterator mid = first + ((last - first) &gt;&gt; 1); if(*mid &lt; n)&#123; first = mid + 1; &#125;else if(*mid &gt; n)&#123; last = mid; //因为 [first,last) &#125;else&#123; return mid; &#125; &#125; return last;&#125;template&lt;typename InputIterator, typename Value&gt;inline InputIterator _mySearch( InputIterator first, InputIterator last, Value n, input_iterator_tag ) &#123; // 返回找到的迭代器,否则返回 last while(first != last)&#123; if(*first == n) return first; first++; &#125; return last;&#125;// 调用函数template&lt;typename InputIterator, typename Value&gt;inline InputIterator mySearch(InputIterator first, InputIterator last, Value n)&#123; //在这里通过萃取器萃取得到 iterator_category 来选择调用的是哪一个重载函数 return _mySearch(first,last,n,typename iterator_traits&lt;InputIterator&gt;::iterator_category());&#125;int main() &#123; //改成这个版本后,链表的测试也能够通过了,看来还是有一定的机制没有摸透 vector&lt;int&gt; vec(&#123;1,2,3,4,5,6,7&#125;); vector&lt;int&gt;::iterator it; if((it = mySearch(vec.begin(),vec.end(),5)) != vec.end()) cout &lt;&lt; &quot;找到了元素&quot; &lt;&lt; *it &lt;&lt; &quot;索引值为&quot; &lt;&lt; it - vec.begin() &lt;&lt; endl; list&lt;int&gt; lst; lst.push_back(20); lst.push_back(30); lst.push_back(15); list&lt;int&gt;::iterator it2; if((it2 = mySearch(lst.begin(),lst.end(),15)) != lst.end()) cout &lt;&lt; &quot;找到了元素&quot; &lt;&lt; *it2 &lt;&lt; endl; return 0;&#125; 代码调用流程如下： 融入 STL如果想要设计一个迭代器融入到STL中，一定要指明五种类型。方便萃取器能够获得它们。STL提供了一个 iterator 的 class ，当自己设计时只需要继承该类即可： 123456789101112template&lt;class Category, class T, class Distance = ptrdiff_t, class Pointer = T*, class Reference = T&amp;&gt;struct iterator&#123; typedef Category iterator_category; typedef T value_type; typedef Distance difference_type; typedef Pointer pointer; typedef Reference reference;&#125;; 例如： 123template&lt;typename Item&gt;struct ListIter : public std::iterator&lt;std::forward_iterator_tag, Item&gt;&#123; //缺省三个参数,只需要提供前两者&#125; 除设计部分学习自侯捷老师：《STL源码剖析》 设计部分属于自行设计(仍有bug)","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"迭代器","slug":"C/STL/迭代器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"iterator","slug":"iterator","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/iterator/"}]},{"title":"装饰器模式","slug":"HugeFour/设计模式/4.单一职责模式_装饰器","date":"2020-10-29T06:50:00.000Z","updated":"2020-11-24T14:15:33.589Z","comments":true,"path":"2020/10/29/HugeFour/设计模式/4.单一职责模式_装饰器/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/29/HugeFour/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F_%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"装饰器模式 Decorator 动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式 比生成子类（继承）更为灵活（消除重复代码&amp;减少子类个数）—— GoF","text":"装饰器模式 Decorator 动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式 比生成子类（继承）更为灵活（消除重复代码&amp;减少子类个数）—— GoF 本次项目里，原本的代码的一个类的继承关系如下： 其中 Stream 是流的基类，在此之上创建了几个派生类，分别是：FileStream NetworkStream MemoryStream。到这里并没有问题，但是如果要对每一种派生的类做加密或者增加缓存或者其他以后可能会出现的需求时，继续继承派生会使得类的数量特别庞大。 12345678910111213classDiagram Stream &lt;|-- FileStream Stream &lt;|-- NetworkStream Stream &lt;|-- MemoryStream FileStream &lt;|-- CryptoFileStream FileStream &lt;|-- BufferedFileStream FileStream &lt;|-- CryptoBufferedFileStream NetworkStream &lt;|-- CryptoNetworkStream NetworkStream &lt;|-- BufferedNetworkStream NetworkStream &lt;|-- CryptoBufferedNetworkStream MemoryStream &lt;|-- CryptoMemoryStream MemoryStream &lt;|-- BufferedMemoryStream MemoryStream &lt;|-- CryptoBufferedMemoryStream 通过装饰器模式的改进，使得关系图如下： 使得功能扩展继承自一个DecoratorStream的类，该类中组合了一个Stream的类，通过多态性对不同类型的流进行特定的操作，在操作外层套上对应的功能（需求）。 1234567classDiagram Stream &lt;|-- FileStream Stream &lt;|-- NetworkStream Stream &lt;|-- MemoryStream Stream &lt;|-- DecoratorStream DecoratorStream &lt;|-- CyptroStream DecoratorStream &lt;|-- BufferedStream 不好的设计不好的设计原因主要是，在进行功能扩展时，生成了特别多的类和冗余的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//抽象类class Stream &#123;public: virtual char Read(int number) = 0; virtual void Seek(int position) = 0; virtual void Write(char data) = 0; virtual ~Stream() &#123;&#125;;&#125;;//主体类class FileStream : public Stream &#123;public: char Read(int number) override &#123; return 0; &#125; void Seek(int position) override &#123;&#125; void Write(char data) override &#123;&#125;&#125;;class NetworkStream : public Stream &#123;public: char Read(int number) override &#123; return 0; &#125; void Seek(int position) override &#123;&#125; void Write(char data) override &#123;&#125;&#125;;//...还有许多其他继承流抽象的子类//...但是如果涉及到要对子类进行加密增加缓存操作时,十分繁琐//扩展操作_加密class CryptoFileStream : public FileStream &#123;public: virtual char Read(int number) &#123; //额外的加密操作 FileStream::Read(number); //包裹函数 //额外的加密操作 &#125; virtual void Seek(int position) &#123; //额外的加密操作 FileStream::Seek(position); //额外的加密操作 &#125; virtual void Write(char data) &#123; //额外的加密操作 FileStream::Write(data); //额外的加密操作 &#125;&#125;;class CryptoNetworkStream : public NetworkStream &#123;&#125;;//...这里还要对其他流也要做加密操作//拓展操作_缓存class BufferedFileStream : public FileStream &#123;&#125;;class BufferedNetworkStream : public NetworkStream &#123;&#125;;//扩展操作_加密_缓存class CryptoBufferedFileStream : public FileStream &#123;&#125;;class CryptoBufferedNetworkStream : public FileStream &#123;&#125;;//其实,所有流的Read()的加密操作都是相同的,不需要写多份,缓存也是如此void Process()&#123; //编译时装配 CryptoFileStream *fs1 = new CryptoFileStream(); BufferedFileStream *fs2 = new BufferedFileStream(); CryptoBufferedFileStream *fs3 = new CryptoBufferedFileStream();&#125; 装饰器模式只需要为功能扩展组合一个基类，就可以利用多态性来减少大量冗余的代码和子类的数量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//抽象类class Stream &#123;public: virtual char Read(int number) = 0; virtual void Seek(int position) = 0; virtual void Write(char data) = 0; virtual ~Stream() &#123;&#125;;&#125;;//主体类class FileStream : public Stream &#123;public: char Read(int number) override &#123; return 0; &#125; void Seek(int position) override &#123;&#125; void Write(char data) override &#123;&#125;&#125;;class NetworkStream : public Stream &#123;public: char Read(int number) override &#123; return 0; &#125; void Seek(int position) override &#123;&#125; void Write(char data) override &#123;&#125;&#125;;//扩展class DecoratorStream : public Stream&#123; //继承为了完善接口规范protected: Stream *stream; // = new FileStream(); // = new NetworkStream(); // = new MemoryStream(); DecoratorStream(Stream * stream):stream(stream)&#123;&#125;&#125;;class CryptoStream : public DecoratorStream &#123; //加密操作抽象出来,通过多态来给不同的类型流加密 // public Stream 为了接口规范public: CryptoStream(Stream *stream) : DecoratorStream(stream) &#123;&#125; virtual char Read(int number) &#123; //额外的加密操作 stream-&gt;Read(number); //包裹函数 //额外的加密操作 &#125; virtual void Seek(int position) &#123; //额外的加密操作 stream-&gt;Seek(position); //额外的加密操作 &#125; virtual void Write(char data) &#123; //额外的加密操作 stream-&gt;Write(data); //额外的加密操作 &#125;&#125;;class BufferedStream : public DecoratorStream &#123;public: BufferedStream(Stream *stream) : DecoratorStream(stream) &#123;&#125; virtual char Read(int number) &#123; //缓存 stream-&gt;Read(number); &#125; virtual void Seek(int position) &#123; //缓存 stream-&gt;Seek(position); &#125; virtual void Write(char data) &#123; //缓存 stream-&gt;Write(data); &#125;&#125;;void Process() &#123; //运行时装配 FileStream *s1 = new FileStream(); CryptoStream *s2 = new CryptoStream(s1); //加密 BufferedStream *s3 = new BufferedStream(s1); //缓存 BufferedStream *s4 = new BufferedStream(s2); //加密 &amp; 缓存&#125; 要点总结 通过采用组合而非继承的手法，Decorator模式实现了在运行时多态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了所有继承带来的灵活性差和多子类衍生问题。 Decorator类在接口上表现为 is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在是线上又表现为 has-a Component的组合关系，即Decorator类又使用了另外一个Component类。 Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”含义。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《设计模式》","slug":"读书笔记/《设计模式》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"},{"name":"单一职责模式","slug":"读书笔记/《设计模式》/单一职责模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"策略模式","slug":"HugeFour/设计模式/2.组件协作模式_策略模式","date":"2020-10-28T06:38:00.000Z","updated":"2020-11-24T14:15:20.263Z","comments":true,"path":"2020/10/28/HugeFour/设计模式/2.组件协作模式_策略模式/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/28/HugeFour/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F_%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"模板模式 Strategy 在许多 if-else 写完以后，如果以后还需要在源码上进行扩写条件分支，那么最好可以使用策略模式，以实现运行时多态。","text":"模板模式 Strategy 在许多 if-else 写完以后，如果以后还需要在源码上进行扩写条件分支，那么最好可以使用策略模式，以实现运行时多态。 12345678910111213141516171819202122232425classDiagram Context o--|&gt; Strategy Strategy &lt;|-- ConcreteStrategyA Strategy &lt;|-- ConcreteStrategyB Strategy &lt;|-- ConcreteStrategyC class Context&#123; ContextInterface() &#125; class Strategy&#123; AlgorithmInterface() &#125; class ConcreteStrategyA&#123; AlgorithmInterface() &#125; class ConcreteStrategyB&#123; AlgorithmInterface() &#125; class ConcreteStrategyC&#123; AlgorithmInterface() &#125; 定义定义一系列算法，把他们一个个封装起来，并且使他们可互相替换（变化）。该模式使得算法可以独立于使用他们的客户程序（稳定）而变化（扩展，子类化）。 动机在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。 如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？ 不好的设计一旦增加业务，会修改源代码，违反了开闭原则（扩展开放，修改关闭） 12345678910111213141516enum TaxBase&#123; CN_Tax, US_Tax, DE_Tax, FR_Tax //新增&#125;;class SalesOrder&#123; TaxBase tax;public: double CalculateTax()&#123; if( tax == CN_Tax )&#123;...&#125; else if( tax == US_Tax ) &#123;...&#125; else if( tax == DE_Tax ) &#123;...&#125; else if( tax == FR_Tax ) &#123;...&#125; //新增&#125;; 模板模式只需要新增一个子类来继承基类，实现多态调用 1234567891011121314151617181920212223242526272829303132333435363738394041//class TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context) = 0; virtual ~TaxStrategy()&#123;&#125;&#125;;class CNTax : public Taxstrategy &#123;public: virtual double Calculate(const Context&amp; context) &#123;&#125;&#125;;class USTax : public Taxstrategy &#123;public: virtual double Calculate(const Context&amp; context) &#123;&#125;&#125;;class DETax : public Taxstrategy &#123;public: virtual double Calculate(const Context&amp; context) &#123;&#125;&#125;;class FRTax : public Taxstrategy &#123; //新增public: virtual double Calculate(const Context&amp; context) &#123;&#125;&#125;;class SalesOrder&#123;private: TaxStrategy * strategy;public: SalesOrder(StrategyFactory* strategyfactory)&#123; this-&gt;strategy = strategyfactory-&gt;NewStrategy(); //工厂模式 &#125; ~SalesOrder()&#123; delete this-&gt;strategy; &#125; double CalculateTex()&#123; Context context(); double val = strategy-&gt;Calculate(context); //多态调用&#125;;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《设计模式》","slug":"读书笔记/《设计模式》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"},{"name":"组件协作模式","slug":"读书笔记/《设计模式》/组件协作模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"模板模式","slug":"HugeFour/设计模式/1.组件协作模式_模板模式","date":"2020-10-27T14:30:00.000Z","updated":"2020-11-24T14:15:46.023Z","comments":true,"path":"2020/10/27/HugeFour/设计模式/1.组件协作模式_模板模式/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/27/HugeFour/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F_%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/","excerpt":"组件协作模式介绍现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。","text":"组件协作模式介绍现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。 动机在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但是各个子步骤却又很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？ 模板模式 Template Method不好的设计12345678910111213141516171819202122232425262728293031//程序库开发class Library&#123;public: void step1()&#123;...&#125; void step3()&#123;...&#125; void step5()&#123;...&#125;&#125;;//应用开发class Application&#123;public: bool step2()&#123;...&#125; bool step5()&#123;...&#125;&#125;;int main()&#123; Library lib; Application app; //逻辑部分 lib.step1(); if(app.step2())&#123; lib.step3(); &#125; for(int i=0;i&lt;4;++i)&#123; app.step4(); &#125; lib.step5(); return 0;&#125; 如此编码的话，做应用开发的程序员压力会很大，还需要完成逻辑部分。 模板模式12345678910111213141516171819202122232425262728293031323334//程序库开发class Library&#123;public: void run()&#123; //稳定 step1(); if(step2())&#123; step3(); &#125; for(int i=0;i&lt;4;++i)&#123; step4(); &#125; step5(); &#125; virtual ~Library()&#123;&#125;protected: void step1()&#123;...&#125; //稳定 void step3()&#123;...&#125; //稳定 void step5()&#123;...&#125; //稳定 virtual bool step2() = 0; //变化 virtual bool step4() = 0; //变化&#125;;//应用开发class Application : public Library&#123;protected: virtual bool step2()&#123;&#125; //重写 virtual bool step4()&#123;&#125; //重写 &#125;;int main()&#123; Library * plib = new Application(); plib-&gt;run(); delete plib;&#125; 如此编码，通过继承实现运行时多态，把逻辑部分封装在父类中。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《设计模式》","slug":"读书笔记/《设计模式》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"},{"name":"组件协作模式","slug":"读书笔记/《设计模式》/组件协作模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式初探","slug":"HugeFour/设计模式/0.设计模式","date":"2020-10-27T13:00:00.000Z","updated":"2020-11-24T14:15:58.240Z","comments":true,"path":"2020/10/27/HugeFour/设计模式/0.设计模式/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/27/HugeFour/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"设计模式课程 base 李建忠 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。—- Christopher Alexand","text":"设计模式课程 base 李建忠 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。—- Christopher Alexand 课程目标 理解松耦合设计思想 掌握面向对象设计原则 掌握重构技巧法改善设计 掌握GOF核心设计模式 书籍推荐《设计模式：可复用面向对象软件的基础》 程序编码属于底层思维 设计属于抽象思维 如何解决复杂性 分解 抽象 哲学层面 面向对象设计原则对象是什么？语言层面：对象封装了代码和数据 规格层面：对象是一系列可被使用的公共接口 概念层面：对象是某种拥有责任的抽象 八大设计原则 依赖倒置原则(DIP) 高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。 例如： 1234567mainForm -&gt; Line / Rect绘画类是高层的模块，但是线条或者矩形类是低层的模块，可能会有修改或者增加。因此不够稳定---&gt;mainForm -&gt; Shape(Abstruct) &lt;- [ Line / Rect ] // [] 隔离变化Shape是抽象类, mainForm 和 Shape 都不需要变化, 只需要修改增加对Shape的依赖类 开放封闭原则(OCP) 对扩展开放，对更改关闭。 类模块应该是可扩展的，但是不可修改。 1增加新的功能时，考虑增加而不是修改 单一职责原则(SRP) 一个类应该仅有一个引起它变化的原因。 变化的方向隐含着类的责任。 Liskov 替换原则(LSP) 子类必须能够替换他们的基类(IS-A)。 继承表达类型抽象。 接口隔离原则(ISP) 不应该强迫客户程序依赖它们不用的方法。 接口应该小而完备。 优先使用对象组合，而不是类继承 类继承通常为”白箱复用”，对象组合通常为“黑箱复用”。 继承在某种程度上破坏了封装线，子类父类耦合度高。 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。 封装变化点 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。 针对接口编程，而不是针对实现编程 不将变量类型声明为某个特定的具体类，而是声明为某个接口。 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。 减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案。 将设计原则提升为设计经验 设计习语 Design Idioms 描述与特定编程语言相关的低层模式，技巧惯用法。 设计模式 Design Patterns 描述的是“类与相互通信的对象之间的组织关系”，包括他们的角色，职责，协作方式等方面。 架构模式 Architectural Patterns 描述系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们之间的关系规则。 GOF-23模式 按照范围分类 类模式处理类与子类的静态关系 对象模式处理对象间的动态关系 按照目的分类 创建型 结构型 行为型 老师提出的分类方式 组件协作 Template Method Strategy Observer / Event 单一职责 Decorator Bridge 对象创建 Factory Method Abstract Factory Prototype Builder 对象性能 Singleton Flyweight 接口隔离 Facade Proxy Mediator Adapter 状态变化 Memento State 数据结构 Composite Iterator Chain of Resposibility 行为变化 Command Visitor 领域问题 Interpreter 重构静态 → 动态 早绑定 → 晚绑定 继承 → 组合 编译时依赖 → 运行时依赖 紧耦合 → 松耦合","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《设计模式》","slug":"读书笔记/《设计模式》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"chapter 8 异常控制流","slug":"HugeFour/OperatingSystem/深入理解计算机系统/第八章 异常控制流","date":"2020-10-27T12:40:00.000Z","updated":"2020-11-24T14:15:00.904Z","comments":true,"path":"2020/10/27/HugeFour/OperatingSystem/深入理解计算机系统/第八章 异常控制流/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/27/HugeFour/OperatingSystem/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/","excerpt":"异常控制流异常控制流(ECF : Exceptional Control Flow) ，是操作系统实现 I/O、进程、并发和虚拟内存的基本机制。","text":"异常控制流异常控制流(ECF : Exceptional Control Flow) ，是操作系统实现 I/O、进程、并发和虚拟内存的基本机制。 异常异常的知识异常 是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。 在处理器中，状态被编码为不同的位和信号，状态变化称为 事件(event) 。 在任何情况下，当处理器检测到事件的发生，它会通过一张叫做 异常表(exception table) 的跳转表，进行一个间接过程的调用(异常)，到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序)。 发生异常后，会发生以下三种情况中的一种： 处理程序将控制返回给当前指令 I_curr 处理程序将控制返回给下个指令 I_next 处理程序终止被中断的程序 系统为每一种异常都分配了唯一的非负整数的异常号。 一部分由处理器的设计者分配(x86-64 : 0-31)：被零除、缺页、内存访问违例、断点、算术运算溢出 一部分由操作系统内核的设计者分配(x86-64 : 32-255)：系统调用和来自外部的 IO 设备的信号 异常的分类 中断 收到中断信号→先执行完当前指令→执行中断处理程序→执行下一条指令 陷阱 系统调用，有一些指令只有内核模式才能调用。需要程序从用户模式陷入内核，才能进行调用。陷入内核的唯一方式：通过中断、故障或者陷入系统调用这样的异常 故障 经典示例：缺页异常。当指令引用了一个虚拟地址，与该地址相对应的物理页面不在内存中时，因此必须从磁盘中取出，所以发生了故障。因此，解决故障之后，返回到原来的指令重新执行。 终止 通常是硬件错误。 异常类型 原因 异步/同步 返回行为 中断 来自IO设备的信号 异步 总是返回下一条指令 陷阱 有意的异常 同步 总是返回下一条指令 故障 潜在可恢复的错误 同步 总是返回当前指令 终止 不可恢复的错误 同步 不会返回 进程 异常是允许操作系统内核提供进程概念的基本构造块。 进程 是一个执行中的程序的实例。系统中的每个程序都运行在某一个进程的上下文中。 上下文 由程序正确运行所需的状态组成。包括：内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 一个逻辑流的执行在时间上与另一个流重叠，称为并行流。多个流并发地执行，称为 并发 。 两个流并发地运行在 不同的处理器核或计算机上 ，称为 并行 流。并行是并发的真子集。 一个进程和其他进程轮流运行，称为 多任务 。一个进程执行它的控制流的一部分的每一时间段叫做 时间片 。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，称为 调度 。由内核的调度器的代码处理。 上下文切换 保存当前进程的上下文； 恢复某个先前被抢占的进程被保存的上下文； 将控制权传递给这个新恢复的进程。 函数fork()waitpid()execve()execve() 函数的目的是在一个程序中打开另一个程序，如果成功就不再返回，如果失败返回 -1。 以下为一个示例： 1234567891011121314151617181920212223//file : main.cppint main()&#123;char filename[] = &quot;test&quot;; char *argv[] = &#123;&quot;./&quot;,NULL&#125;; if(execve(filename, argv,NULL) == -1)&#123; cout &lt;&lt; &quot;execve error&quot; &lt;&lt;endl; exit(EXIT_FAILURE); &#125; puts(&quot;shouldn&#x27;t get here&quot;); exit(EXIT_SUCCESS); return 0;&#125;//file : test.cpp#include &lt;iostream&gt;using namespace std;int main()&#123; std::cout &lt;&lt; &quot;调用成功&quot; &lt;&lt; std::endl; return 0;&#125; 1234&gt; g++ -o test.cpp test&gt; g++ -o amin.cpp main&gt; ./main&gt; 调用成功 信号函数signal()singal() 函数可以修改进程接收信号的行为，但是无法修改接收到 SIGSTOP 和 SIGKILL 的行为。 以下是具体用法： 123456789101112#include&lt;signal&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler);/*** 如果 handler 是 SIG_IGN, 忽略 signum 信号** 如果 handler 是 SIG_DFL, 恢复 signum 信号为默认行为** 否则,handler 指向用户自定程序: 改变了默认行为 设置信号处理程序 调用信号处理程序 捕获信号 执行信号处理程序 处理信号*/","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《深入理解计算机系统》","slug":"读书笔记/《深入理解计算机系统》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"},{"name":"第八章 异常控制流","slug":"读书笔记/《深入理解计算机系统》/第八章-异常控制流","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"类似于vector的数据结构实现","slug":"STL/STL-vector 的实现","date":"2020-10-26T11:30:00.000Z","updated":"2020-11-24T14:18:08.069Z","comments":true,"path":"2020/10/26/STL/STL-vector 的实现/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/26/STL/STL-vector%20%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"类似于vector的数据结构实现","text":"类似于vector的数据结构实现 预期实现的功能 可以对内置类型以及自定义数据类型进行存储 将数组中的数据存储到堆区 构造函数 空构造 传入容量 传入容量和初始化值 提供对应的拷贝构造函数和拷贝赋值函数防止浅拷贝 提供尾插法核尾删法 可以通过下标访问数组元素 可以获取当前的容量和大小 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110template &lt;typename _Tp&gt;class MyArray&#123; typedef _Tp ValueType; private: int _size; //大小 int _capacity; //容量 ValueType *address; //管理地址 //实际上vector是管理的三个迭代器public: // 构造函数 MyArray()&#123; //全部初始化为0 _size = 0; _capacity = 0; address = nullptr; &#125; MyArray(int capacity)&#123; //容量设置好以及分配好对应的堆内存 _size = 0; _capacity = capacity; address = new ValueType[capacity]; &#125; MyArray(int capacity,ValueType val)&#123; //容量和大小都设置好,以及分配对应的堆内存并进行初始化 _size = capacity; _capacity = capacity; address = new ValueType[capacity]; for (int i = 0; i &lt; capacity; ++i) &#123; *(address + i) = val; &#125; &#125; //拷贝构造 MyArray(const MyArray &amp;arr) &#123; this-&gt;_size = arr._size; this-&gt;_capacity = arr._capacity; this-&gt;address = new ValueType[this-&gt;_capacity]; //深拷贝 &#125; //拷贝赋值 MyArray &amp; operator=(const MyArray &amp; arr)&#123; //检查原本是否存在管理的内存 if(this-&gt;address != nullptr)&#123; this-&gt;_capacity = 0; this-&gt;_size = 0; delete [] this-&gt;address; this-&gt;address = nullptr; &#125; this-&gt;_size = arr._size; this-&gt;_capacity = arr._capacity; this-&gt;address = new ValueType[this-&gt;_capacity]; //深拷贝 for (int i = 0; i &lt; this-&gt;_size; ++i) &#123; this-&gt;address[i] = arr.address[i]; &#125; &#125; //析构函数 ~MyArray() &#123; if(address != nullptr) &#123; delete[] address; this-&gt;address = nullptr; &#125; &#125; //取值 int size()&#123; return _size; &#125; int capacity()&#123; return _capacity; &#125; //[]重载 ValueType &amp; operator[](int n)&#123; //可以作为左值 return this-&gt;address[n]; &#125; void adjust_capacity(const ValueType &amp; obj)&#123; //内存扩容 if(_capacity == _size)&#123; //申请2倍内存释放原本内存进行拷贝 std::cout &lt;&lt; &quot;调整&quot; &lt;&lt; std::endl; _capacity = _capacity == 0 ? 1 : 2 * _capacity; ValueType * new_address = new ValueType[_capacity]; // 放入当前尾部插入的元素 还没有考虑 vector.insert() new_address[_size] = obj; _size ++; delete [] address; address = new_address; &#125; return; &#125; //尾插尾删 void push_back(const ValueType &amp; obj)&#123; if(_capacity == _size)&#123; adjust_capacity(obj); return; &#125; this-&gt;address[_size] = obj; this-&gt;_size++; &#125; void pop_back()&#123; if(_size == 0)&#123; return; &#125; this-&gt;_size --; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"容器","slug":"C/STL/容器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"vector","slug":"vector","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/vector/"}]},{"title":"TCP通信[未完成]","slug":"HugeFour/Network/TCP","date":"2020-10-26T05:25:00.000Z","updated":"2020-11-24T14:14:29.032Z","comments":true,"path":"2020/10/26/HugeFour/Network/TCP/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/26/HugeFour/Network/TCP/","excerpt":"简介传输控制协议( TCP : Transmission Control Protocol )，是一种面向连接的，可靠的传输层控制协议。","text":"简介传输控制协议( TCP : Transmission Control Protocol )，是一种面向连接的，可靠的传输层控制协议。 面向连接一般，客户端发送给服务端的一个数据包携带的数据最大为1460字节。是因为，以太网帧结构数据长度是1500字节，其中包含20字节的IP头部以及20字节的TCP头部，所以数据能够携带1460字节。 三次握手三次握手，由内核完成。反应在程序中，是由客户端程序的 connect() 开始，由 服务端程序的 accept() 返回结束。 示例 123456789客户端发送：SYN 1000(0) win 4096 &lt;mss 1460&gt;服务端发送：SYN 8000(0) win 6144 ACK 1001 &lt;mss 1024&gt; //ACK 1001 是接收到的序号+数据字节(SYN标志位也得占1字节)客户端发送：ACK 8001 win 4096 /*** (0) : 表示携带数据为0字节** win 4096 : 发送端滑动窗口缓存4096字节** &lt;mss 1460&gt; : 表示携带数据最大字节数为1460字节*/ 总结 123主动发起连接请求端：发送SYN标志位，请求建立连接。携带数据包包号，数据字节数(0)，滑动窗口大小被动接受连接请求端：发送ACK标志位，同时携带SYN请求标志位。携带序号，确认序号，数据字节数(0)，滑动窗口大小主动发起连接请求段：发送ACK标志位，应答服务器连接请求。携带确认序号。 要点 为什么不是二次握手？ 彼此确定收发能力 第一次客户端发送请求，服务端接收请求：服务端知道了客户端有发送的能力。 第二次服务端发送请求，客户端接收请求：客户端知道了服务端有收发的能力。 此时，服务端不知道客户端是不是有接收的能力。因此需要客户端再次告知服务端。 避免两次连接 客户端发送的连接请求如果滞留在网络中，等到超时重传，会再次发起连接请求，而服务器接收到两个连接请求会打开两个连接。因此，需要三次握手。 第三次客户端发送ACK时，可以携带数据 因为此时，客户端服务端都知道双方都有收发数据的能力，所以可以开始通信。 四次挥手四次挥手，目的是断开客户端到服务端的全双工链路。断开一端称为半关闭，会关闭一端的套接字的一个缓存区。 示例 1234客户端发送：FIN 501(0) ACK 701 服务端发送：ACK 502 ---- 半关闭服务端发送：FIN 701(0) ACK 502客户端发送：ACK 702 ---- 完全断开 总结 1234主动关闭连接请求端：发送FIN标志位。被动关闭连接请求端：应答ACK标志位。 ———— 半关闭完成被动关闭连接请求端：发送FIN标志位。主动关闭连接请求端：应答ACK标志位。 —————连接全部关闭 客户端接收到服务器的应答之后，进入半关闭状态，不能发送数据给服务器，而服务器会在发送完剩余数据后，发起关闭请求，客户端应答服务器后需要等待 2MSL(最大报文存活时间)后释放连接。原因如下： 如果客户端的应答数据包丢失，那么服务器会再次发送断开请求。 等待一段时间，使本次连接过程中产生的数据包在网络中消失。 可靠传输超时重传TCP使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送到接收到确定所经历的时间称为往返时间RTT(加权平均RTTs)。超时时间 RTO 应该略大于 RTTs 。TCP使用的超时时间计算是 : RTO = RTTs + 4 * RTTd 。RTTd : 偏差的加权平均值。 滑动窗口滑动窗口是一个缓存区，用于暂时存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其他信息来设置自己的窗口大小。 对于发送方来说，当窗口靠左侧的数据包已经成功发送并被确认后，窗口向右滑动直到某一个未发送或者未确认的字节位置。 对于接收方来说，当窗口靠左侧的数据包已经收到，窗口向右滑动直到某一个未接收到的字节。 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 拥塞控制如果网络出现拥塞，发送方发送的数据包丢失，发送方重传导致网络难以恢复。因此要进行一定的拥塞控制使得发送方降低发送速率。发送方需要维护一个拥塞窗口（cwnd）状态变量：决定发送方能发送多少数据。 慢开始与拥塞避免 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 快速重传与快速恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。","categories":[{"name":"网络通信","slug":"网络通信","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"传输层","slug":"网络通信/传输层","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"name":"TCP","slug":"网络通信/传输层/TCP","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP/"}],"tags":[{"name":"tcp","slug":"tcp","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/tcp/"}]},{"title":"剑指 Offer 09. 用两个栈实现队列","slug":"leetcode/offer/剑指Offer 09","date":"2020-10-19T10:09:00.000Z","updated":"2020-11-24T14:19:22.998Z","comments":true,"path":"2020/10/19/leetcode/offer/剑指Offer 09/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/19/leetcode/offer/%E5%89%91%E6%8C%87Offer%2009/","excerpt":"","text":"剑指 Offer 09. 用两个栈实现队列题目描述剑指 Offer 09. 用两个栈实现队列 难度:中等 描述 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1234567891011121314输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1]输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 限制：1 &lt;= values &lt;= 10000最多会对 appendTail、deleteHead 进行 10000 次调用 1234567API设计 :class CQueue &#123;public: CQueue() &#123;&#125; void appendTail(int value) &#123;&#125; int deleteHead() &#123;&#125;&#125;; 解法因为栈这一种线性结构的特性是后进先出，而队列这一种线性结构的特性是先进先出，它使用两个栈就可以通过两次后进先出实现我们想要的先进先出的特性。 123456789101112131415161718192021222324252627class CQueue &#123;private: stack&lt;int&gt; s_in; // 数据先经过 s_in 栈 stack&lt;int&gt; s_out; // 再经过 s_out 出栈public: CQueue() &#123;&#125; void appendTail(int value) &#123; s_in.push(value); &#125; int deleteHead() &#123; if(s_in.empty() &amp;&amp; s_out.empty()) //都空说明没有元素 return -1; else if(s_out.empty())&#123; // s_out 空 s_in 不空 while(!s_in.empty())&#123; //全部转移 s_out.push(s_in.top()); s_in.pop(); &#125; &#125; // 经过 s_out 出栈 int ans = s_out.top(); s_out.pop(); return ans; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%A0%88/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"队列","slug":"队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"前缀/中缀/后缀表达式的转换/计算/构建二叉树[未完成]","slug":"CodingSkills/前缀中缀后缀表达式转换求值","date":"2020-10-18T14:51:00.000Z","updated":"2020-11-24T14:13:54.463Z","comments":true,"path":"2020/10/18/CodingSkills/前缀中缀后缀表达式转换求值/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/18/CodingSkills/%E5%89%8D%E7%BC%80%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%B1%82%E5%80%BC/","excerpt":"简介 我们从小学至今，接触到最多的表达式就是中缀表达式，形如 : (5+(3*2)-6/2) 作用的运算符落在数字两边。但是这一个表达式作为字符串输入到计算机中，计算机可不太喜欢这样的表达式，它顺序遍历的时候，由于运算符优先级不同，难以计算。因此，出现了前缀表达式和后缀表达式，他们两者的特点是不携带括号，顺序遍历时，明确了运算的优先级。前缀和后缀表达式都可以由中缀表达式转换而来。 本篇文章会带你学习如何把中缀表达式转换成前缀 / 后缀表达式，如果根据前缀 / 后缀表达式计算表达式的值，最后由表达式来构建出一棵表达式二叉树。","text":"简介 我们从小学至今，接触到最多的表达式就是中缀表达式，形如 : (5+(3*2)-6/2) 作用的运算符落在数字两边。但是这一个表达式作为字符串输入到计算机中，计算机可不太喜欢这样的表达式，它顺序遍历的时候，由于运算符优先级不同，难以计算。因此，出现了前缀表达式和后缀表达式，他们两者的特点是不携带括号，顺序遍历时，明确了运算的优先级。前缀和后缀表达式都可以由中缀表达式转换而来。 本篇文章会带你学习如何把中缀表达式转换成前缀 / 后缀表达式，如果根据前缀 / 后缀表达式计算表达式的值，最后由表达式来构建出一棵表达式二叉树。 概念前缀表达式前缀表达式是一种没有括号的算术表达式，与中缀表达式不同的是，其将运算符写在前面，操作数写在后面。 为纪念其发明者波兰数学家Jan Lukasiewicz，前缀表达式也称为“波兰式”。 例如，- 1 + 2 3，它等价于1 - (2 + 3)。 中缀表达式中缀表达式是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间。 例如：3 + 4。 后缀表达式后缀表达式与前缀表达式类似的是一种没有括号的算术表达式，不同的是运算符写在后面，操作数写在前面。 后缀表达式也称为“逆波兰式”。 例如+ 2 3，它等价于 2 + 3。 表达式二叉树算数表达式是分层的递归结构，一个运算符作用于相应的运算对象，其运算对象又可以是任意复杂的表达式。树的递归结构正好用来表示这种表达式。下面只讨论二元表达式。二元表达式可以很自然的联系到二叉树：以基本运算对象作为叶节点中的数据；以运算符作为非叶节点中的数据，其两棵子树是它的运算对象，子树可以是基本运算对象，也可以是复杂表达式。如图是一个表达式树。 留意一下颜色和遍历顺序和表达式类型的对应关系。 表达式树的先序遍历：前缀表达式 表达式树的中序遍历：中缀表达式 表达式树的后序遍历：后缀表达式 运算数 ：是二叉树的叶子节点 运算符：是二叉树的非叶子节点 转换中缀表达式转前缀表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vector&lt;string&gt; prefix(const vector&lt;string&gt; &amp; mid_str)&#123; /* * 中缀表达式转换成前缀表达式 * 采用 vector &lt; string &gt; 的存储方式存储 * 运算符占用一字符串, 多位整数占用一字符串 */ vector&lt;string&gt; pre; stack&lt;string&gt; op; stack&lt;string&gt; tmp; // 用于最后转置所有字符串顺序 map&lt;string,int&gt; priority; priority[&quot;+&quot;] = 0; priority[&quot;-&quot;] = 0; priority[&quot;*&quot;] = 1; priority[&quot;/&quot;] = 1; for(int i = mid_str.size() - 1 ; i &gt;= 0 ; i -- )&#123; if(isdigit(mid_str[i][0]) || isalpha(mid_str[i][0]))&#123; tmp.push(mid_str[i]); &#125; else if (mid_str[i] == &quot;)&quot;)&#123; op.push(&quot;)&quot;); &#125; else if(mid_str[i] == &quot;(&quot;)&#123; while(op.top() != &quot;)&quot;)&#123; tmp.push(op.top()); op.pop(); &#125; op.pop(); //弹出 &quot;)&quot; &#125; else if (mid_str[i] == &quot;+&quot; || mid_str[i] == &quot;-&quot; || mid_str[i] == &quot;*&quot; || mid_str[i] == &quot;/&quot;) &#123; while(!op.empty() &amp;&amp; op.top() != &quot;)&quot; &amp;&amp; priority[mid_str[i]] &lt;= priority[op.top()])&#123; tmp.push(op.top()); op.pop(); &#125; op.push(mid_str[i]); &#125; &#125; while(!op.empty())&#123; tmp.push(op.top()); op.pop(); &#125; while(!tmp.empty())&#123; pre.push_back(tmp.top()); tmp.pop(); &#125; return pre;&#125; 中缀表达式转后缀表达式1234567891011121314151617181920212223242526272829303132333435363738394041vector&lt;string&gt; postfix(const vector&lt;string&gt; &amp;mid_str) &#123; /* * 中缀表达式转换成后缀表达式 * 采用 vector &lt; string &gt; 的存储方式存储 * 运算符占用一字符串, 多位整数占用一字符串 */ vector&lt;string&gt;post; stack&lt;string&gt; op; map&lt;string,int&gt; priority; priority[&quot;+&quot;] = 0; priority[&quot;-&quot;] = 0; priority[&quot;*&quot;] = 1; priority[&quot;/&quot;] = 1; for (int i = 0; i &lt; mid_str.size(); ++i) &#123; if(isdigit(mid_str[i][0]) || isalpha(mid_str[i][0]))&#123; post.push_back(mid_str[i]); &#125; else if (mid_str[i] == &quot;(&quot;)&#123; op.push(&quot;(&quot;); &#125; else if(mid_str[i] == &quot;)&quot;)&#123; while(op.top() != &quot;(&quot;)&#123; post.push_back(op.top()); op.pop(); &#125; op.pop(); //弹出 &quot;(&quot; &#125; else if (mid_str[i] == &quot;+&quot; || mid_str[i] == &quot;-&quot; || mid_str[i] == &quot;*&quot; || mid_str[i] == &quot;/&quot;) &#123; while(!op.empty() &amp;&amp; op.top() != &quot;(&quot; &amp;&amp; priority[mid_str[i]] &lt;= priority[op.top()])&#123; post.push_back(op.top()); op.pop(); &#125; op.push(mid_str[i]); &#125; &#125; while(!op.empty())&#123; post.push_back(op.top()); op.pop(); &#125; return post;&#125; 测试部分1234567// vector&lt;string&gt; mid(&#123;&quot;2&quot;,&quot;+&quot;,&quot;9&quot;,&quot;/&quot;,&quot;3&quot;,&quot;-&quot;,&quot;5&quot;&#125;); // 2 + 9 / 3 - 5// vector&lt;string&gt; mid(&#123;&quot;a&quot;,&quot;*&quot;,&quot;(&quot;,&quot;b&quot;,&quot;+&quot;,&quot;c&quot;,&quot;)&quot;,&quot;/&quot;,&quot;d&quot;&#125;); // a * (b + c) / d// vector&lt;string&gt; mid(&#123;&quot;2&quot;,&quot;*&quot;,&quot;(&quot;,&quot;9&quot;,&quot;+&quot;,&quot;6&quot;,&quot;/&quot;,&quot;3&quot;,&quot;-&quot;,&quot;5&quot;,&quot;)&quot;,&quot;+&quot;,&quot;4&quot;&#125;); // 2 * (9 + 6 / 3 - 5) + 4// vector&lt;string&gt; mid(&#123;&quot;a&quot;,&quot;+&quot;,&quot;b&quot;,&quot;*&quot;,&quot;c&quot;,&quot;-&quot;,&quot;(&quot;,&quot;d&quot;,&quot;+&quot;,&quot;e&quot;,&quot;)&quot;&#125;); // a + b * c - (d + e) vector&lt;string&gt; mid(&#123;&quot;(&quot;,&quot;3&quot;,&quot;+&quot;,&quot;4&quot;,&quot;)&quot;,&quot;*&quot;,&quot;5&quot;,&quot;-&quot;,&quot;6&quot;&#125;); //(3 + 4) * 5 - 6 vector&lt;string&gt; post = postfix(mid); vector&lt;string&gt; pre = prefix(mid); 计算前缀表达式计算后缀表达式计算后缀表达式求值 构建二叉树前缀和中缀表达式构建二叉树后缀和中缀表达式构建二叉树","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"数据结构/栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%A0%88/"},{"name":"二叉树","slug":"二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指 Offer 07. 重建二叉树","slug":"leetcode/offer/剑指Offer 07","date":"2020-10-16T08:24:31.000Z","updated":"2020-11-24T14:19:17.382Z","comments":true,"path":"2020/10/16/leetcode/offer/剑指Offer 07/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/16/leetcode/offer/%E5%89%91%E6%8C%87Offer%2007/","excerpt":"","text":"剑指 Offer 07. 重建二叉树题目描述剑指 Offer 07. 重建二叉树 难度:中等 描述 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 示例 123456例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 限制：0 &lt;= 节点个数 &lt;= 5000 返回如下的二叉树： 12函数签名:TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder); 思路事实上，我们通过遍历顺序还原二叉树，必须知道中序遍历以及前序后序中的一种，就可以还原出唯一的一棵二叉树。这一道题目是前序和中序还原二叉树，leetcode中也有中序和后序还原二叉树，解法其实是类似的。 106. 从中序与后序遍历序列构造二叉树 还原思路主要是依据前序和中序顺序的特点。 前序的第一个节点一定是树的根节点； 中序中根节点的左侧为左子树节点，右侧为右子树节点； 前序中除去根节点以外，左子树的节点集中在左边，右子树的节点集中在右边； 对于每一颗子树来说，也满足以上两个特点。 解法1234567891011121314151617181920TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; //函数签名不支持我们方便的书写递归,因此再构建一个函数 return build(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);&#125;TreeNode* build(vector&lt;int&gt;&amp; preorder, int pbegin, int pend, vector&lt;int&gt;&amp; inorder, int ibegin, int iend)&#123; if(pbegin &gt; pend) //剪枝条件 return nullptr; int midnum = preorder[pbegin]; //特点1:前序第一个节点是根节点 int index = 0; for(int i=ibegin;i&lt;=iend;++i) if(inorder[i] == midnum) //利用特点2之前需要找到中序中的根节点 index = i; int leftsize = index - ibegin; // 找到左子树的节点数 TreeNode * node = new TreeNode(midnum); node-&gt;left = build(preorder,pbegin+1,pbegin+leftsize,inorder,ibegin,index-1); //构建左子树 node-&gt;right = build(preorder,pbegin+leftsize+1,pend,inorder,index+1,iend); //构建右子树 return node;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"中等","slug":"中等","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%B8%AD%E7%AD%89/"}]},{"title":"剑指 Offer 06. 从尾到头打印链表","slug":"leetcode/offer/剑指Offer 06","date":"2020-10-14T07:47:31.000Z","updated":"2020-11-24T14:19:11.785Z","comments":true,"path":"2020/10/14/leetcode/offer/剑指Offer 06/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/14/leetcode/offer/%E5%89%91%E6%8C%87Offer%2006/","excerpt":"","text":"剑指 Offer 06. 从尾到头打印链表题目描述剑指 Offer 06. 从尾到头打印链表 难度:简单 描述 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 12345678输入： head = [1,3,2]输出： [2,3,1]限制:0 &lt;= 链表长度 &lt;= 10000函数签名:vector&lt;int&gt; reversePrint(ListNode* head); 解法一第一种思路栈。 我们看到了 反过来 这几个字眼，心里应该要知道这个地方可以借助一个辅助栈来完成。栈这一种数据结构的特性是先进后出，那么原本是1-2-3-4-5 的序列，经过 入栈 和 出栈 的操作之后，就变成了 5-4-3-2-1 的序列。 那么来看这一个题目，一个链表遍历的方法是迭代遍历而不是地址偏移的随机访问遍历，因此我们在遍历过程中把节点的值放入一个辅助栈中，当链表遍历完成后，再将辅助栈的数值给赋值到一个数组中返回。 1234567891011121314151617vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; res; //结果 stack&lt;int&gt; s; //辅助栈 if(!head) return res; ListNode* cur = head; //尽量不破坏传入的指针 while(cur)&#123; //正序遍历链表,将值入栈 s.push(cur-&gt;val); cur = cur-&gt;next; &#125; while(!s.empty())&#123; //将值出栈 res.push_back(s.top()); s.pop(); &#125; return res;&#125; 因为我们只需要遍历一次链表和访问N次栈，而空间需要一个返回的vector&lt;int&gt;的结果和一个辅助栈。 因此，时间复杂度 : O(N) 空间复杂度 : O(N) 。 解法一·改进仍然是解法一的思路。 我们可以不需要一个栈，而是反转数组。 123456789101112vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; res; //结果 if(!head) return res; ListNode* cur = head; while(cur)&#123; //正序遍历链表,直接加入到数组中 res.push_back(cur-&gt;val); cur = cur-&gt;next; &#125; //用反向迭代器创建一个vector&lt;int&gt;对象 return vector&lt;int&gt;(res.rbegin(),res.rend());&#125; 12345678910//这里偷懒使用了反向迭代器//也可以使用双指针原地反转数组int left = 0, right = res.size() - 1;while(left &lt; right)&#123; int tmp = res[left]; res[left] = res[right]; res[right] = tmp; left ++; right --;&#125; 时间复杂度 : O(N) 空间复杂度 : O(N) 。 解法二第二种思路是利用链表和数组的迭代次数与索引的关系。 我们可以想到，链表的迭代次数和数组的索引值是有一定关系的：迭代次数 + 索引值 = 链表长度 - 1 1234567891011121314151617181920vector&lt;int&gt; reversePrint(ListNode* head) &#123; if(!head) return &#123;&#125;; int count = 0; ListNode* cur = head; while(cur)&#123; //遍历计数链表长度 count ++; cur = cur-&gt;next; &#125; vector&lt;int&gt; res(count); //创建链表长度的数组 int index = count - 1; cur = head; while(cur)&#123; //利用关系 res[index--] = cur-&gt;val; cur = cur-&gt;next; &#125; return res;&#125; 这里第11行，vector&lt;int&gt; res(count); 是必须的。如果没有使用传入一个整型值来确定res的构造函数来构造对象的话，res.size() 和 res.capacity() 都会是0，因此无法使用例如res[8]这样的方式去存取数值。如果没有了解过这一方面的知识，可以看我之前的一篇文章：浅析STL中vector容器的用法/特性/实现。 时间复杂度 : O(N) , 空间复杂度 : O(N)。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"简单","slug":"简单","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"链表","slug":"链表","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指 Offer 05. 替换空格","slug":"leetcode/offer/剑指 Offer 05. 替换空格","date":"2020-10-12T12:56:00.000Z","updated":"2020-11-24T14:18:55.391Z","comments":true,"path":"2020/10/12/leetcode/offer/剑指 Offer 05. 替换空格/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/12/leetcode/offer/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","excerpt":"","text":"剑指 Offer 05. 替换空格题目描述剑指 Offer 05. 替换空格 难度:简单 描述 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 现有矩阵 matrix 如下： 12345678输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 限制：0 &lt;= s 的长度 &lt;= 10000函数签名:string replaceSpace(string s) 解法一第一种思路是创建一个新的空字符串，遍历原字符串，判断当前字符是否是空格，如果是空格，新串 += &quot;%20&quot; 如果不是空格，新串加 += 当前字符 代码过于简单，就不展示啦。 时间复杂度 : O(N) 空间复杂度 : O(N) 。 解法二第二种思路是原地调整字符串大小，直接将&quot;%20&quot;加入到原字符串中。 我们需要遍历一次数组，统计空格字符出现的次数，那么调整后的字符串大小应该等于old_size + 2*space_num 。 123456789101112131415161718192021222324252627string replaceSpace(string s) &#123; int space_num = 0; int size_old = s.size(); //旧串大小 for(char c:s) if(isspace(c)) space_num++; int size_new = size_old + 2 * space_num; //新串大小 s.resize(size_new); int i = size_new-1; int j = size_old-1; while(i != j)&#123; //如果 i==j,说明再前面的字符串子串里不存在空格字符,剪枝操作 if(isspace(s[j]))&#123; s[i] = &#x27;0&#x27;; s[i-1] = &#x27;2&#x27;; s[i-2] = &#x27;%&#x27;; i -= 3; j -= 1; &#125; else&#123; s[i] = s[j]; j--; i--; &#125; &#125; return s; &#125; 时间复杂度 : O(N) , 空间复杂度 : O(N)。 这里的空间复杂度明显要比前一种小很多，尤其是字符串很长而空格字符很少的情况。如果形式参数是传引用的形式传递，应该采用解法一，尽量不改变传入的字符串。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"简单","slug":"简单","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"字符串","slug":"字符串","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"剑指 Offer 04. 二维数组中的查找","slug":"leetcode/offer/剑指Offer 04. 二维数组中的查找","date":"2020-10-12T12:56:00.000Z","updated":"2020-11-24T14:19:06.990Z","comments":true,"path":"2020/10/12/leetcode/offer/剑指Offer 04. 二维数组中的查找/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/12/leetcode/offer/%E5%89%91%E6%8C%87Offer%2004.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"","text":"剑指 Offer 04. 二维数组中的查找题目描述剑指 Offer 04. 二维数组中的查找 难度:简单 描述 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例 现有矩阵 matrix 如下： 1234567891011121314[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。函数签名:bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) 解法一第一种思路是类似暴力法，因为二维数组每一个维度都是从 index = 0 到 index = size()-1 升序，因此我们可以找到两个边界，缩小遍历的空间大小。 我们只需要两次循环找到边界，再用找到的边界二层循环去寻找 target。 1234567891011121314151617181920212223bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size() == 0 || matrix[0].size() == 0) return false; //边界 int s_m,s_n; //每一个维度的边界 int size_0 = matrix.size(); int size_1 = matrix[0].size(); for(int i =0;i&lt;size_0;++i) //找到纵向的边界 if(matrix[i][0] &gt; target)&#123; s_m = i; break;&#125; for(int j = 0; j &lt; size_1; ++ j) //找到横向的边界 if(matrix[0][j] &gt; target)&#123; s_n = j; break;&#125; for(int i=0;i&lt;s_m;++i) //缩小遍历空间大小 for(int j=0;j&lt;s_n;++j) if(matrix[i][j] == target) return true; return false;&#125; 时间复杂度 : O(N*M) 空间复杂度 : O(1) 。但是，如果二维数组特别大，这么做应该还是能够有效减少遍历次数的。 解法二第二种思路是类似于二叉搜索树。 我们只需要遍历一次数组，每一次先判定当前元素是否出现过(在集合中)，如果没有出现过加入到集合中，如果出现过就直接返回这个元素值即可。 1234567891011121314151617bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size() == 0 || matrix[0].size() == 0) return false; int i = 0; int j = matrix[0].size() - 1; while( i &lt; matrix.size() &amp;&amp; j &gt;= 0 )&#123; // 站在右上角,把数组看成二叉搜索树 if(matrix[i][j] == target) return true; else if(matrix[i][j] &gt; target) j--;// 1 else i++; &#125; return false; &#125; 12// 1 : 这里不需要给i置零// 比如我们要找14,我们11的时候要i++,12的时候i++,16的时候j--,但是target已经大于12了，必不需要从7开始重新判断 可以发现这一种解法一步到位，但是也类似于第一种方法，只是我们的起点设计的比较巧妙，能够通过索引 i j 的一定规律的移动就能找到 target 是否存在。 时间复杂度 : O(N+M) , 空间复杂度 : O(1)。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"简单","slug":"简单","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"数组","slug":"数组","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer 03. 数组中重复的数字","slug":"leetcode/offer/剑指Offer 03. 数组中重复的数字","date":"2020-10-11T14:20:31.000Z","updated":"2020-11-24T14:19:02.383Z","comments":true,"path":"2020/10/11/leetcode/offer/剑指Offer 03. 数组中重复的数字/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/11/leetcode/offer/%E5%89%91%E6%8C%87Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"剑指Offer 03. 数组中重复的数字题目描述剑指 Offer 03. 数组中重复的数字 难度:简单 描述 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 12345678输入:[2, 3, 1, 0, 2, 5, 3]输出:2 或 3限制:2 &lt;= n &lt;= 100000函数签名:int findRepeatNumber(vector&lt;int&gt;&amp; nums) 解法一第一种思路是采用暴力法。 我们只需要两层循环遍历数组，当内外层索引对应的元素值相等时，返回这个元素值即可。 时间复杂度 : O(N^2) 空间复杂度 : O(1) 。 解法二第二种思路是采用哈希集合。 我们只需要遍历一次数组，每一次先判定当前元素是否出现过(在集合中)，如果没有出现过加入到集合中，如果出现过就直接返回这个元素值即可。 123456789int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; record; //存出现过的数 for(int num : nums)&#123; if(record.find(num) != record.end()) // 找到了 return num; record.insert(num); &#125; return -1;&#125; 因为我们在 hashset 中查找的时间复杂度是 O(1) 。 因此，时间复杂度 : O(N) , 空间复杂度 : O(N)。 解法三第三种思路是一个萝卜一个坑。剑指Offer书中解答。 因为数组中的编号是 [0, n-1]，因此每一个索引应该对应的是它的值，即i == nums[i] ，所以我们如果现在 i != nums[i] 就把当前的 nums[i] 放到合适的位置，进行两数交换。 12345678910111213int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; for(int i=0;i&lt;nums.size();++i)&#123; while(nums[i] != i)&#123; if(nums[i] == nums[nums[i]]) //如果交换位置的元素相等就直接找到了 return nums[i]; //两数交换 int tmp = nums[i]; nums[i] = nums[tmp]; nums[tmp] = tmp; &#125; &#125; return -1;&#125; 因为有题目的限制： 一定有重复； 最大元素值是 size()-1。 所以题目中的 while 循环一定能够退出。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"哈希集合","slug":"哈希集合","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/"},{"name":"简单","slug":"简单","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/"}]},{"title":"浅析list用法/特性/实现","slug":"STL/STL-list 分析","date":"2020-10-11T10:52:16.000Z","updated":"2020-11-24T14:18:32.720Z","comments":true,"path":"2020/10/11/STL/STL-list 分析/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/11/STL/STL-list%20%E5%88%86%E6%9E%90/","excerpt":"list 容器list 在 C++ 中是一种用起来像链表的模板类。侯捷老师主要介绍的是G2.9和G4.9两个版本。我将阅读一下 clang 中的源码。","text":"list 容器list 在 C++ 中是一种用起来像链表的模板类。侯捷老师主要介绍的是G2.9和G4.9两个版本。我将阅读一下 clang 中的源码。 list . 结构G2.9 下，list 只有一个成员变量，list_node * node ，是list_node类的指针，在32位机中占用4个字节，在64位机中占用8个字节。 而 list_node 类中，又有三个成员变量 : void * prev : 指向当前节点的前驱 void * next : 指向当前节点的后继 void * data : 指向当前节点 数据结构课程里的双向链表就是这样的一个结构，每一个节点拥有前驱后继节点且有一个数据。因此，list 容器是一个双向链表，与之对应的还有一个单向链表容器 forward_list。 侯捷老师提到此处设计有一个不合理的点 : list_node 已经接收到了模板参数，但是其内部的指针和数据的类型都是 void 。 双向链表底层逻辑是一个环状链表结构，也就是说最后一个节点 next 的 next 是头结点。尾结点后还有一个节点，是为了考虑所有迭代器的区间是前闭后开。 G4.9 下，list 中有两个成员变量。 list . iterator除了 array 和 vector 之外的所有容器的 iterator 必须得是一个类。因为需要重载许多运算符。 list 相较于 vector 的迭代器中的 ++ 操作，就不能是简单的在内存中做偏移了，而是得去寻找 list 的下一个节点，也就是迭代器 iterator 所指节点的 next。 运算符重载中的 i++ 和 ++i 的声明方式 Self&amp; operator++() 重载的是 ++i 操作 Self&amp; operator++(int) 重载的是 i++ 操作，其中 int 是占位符 list . 继承关系待补充","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"容器","slug":"C/STL/容器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"list","slug":"list","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/list/"}]},{"title":"浅析vector用法/特性/实现","slug":"STL/STL-vector分析","date":"2020-10-10T13:00:16.000Z","updated":"2020-11-24T14:18:20.447Z","comments":true,"path":"2020/10/10/STL/STL-vector分析/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/10/STL/STL-vector%E5%88%86%E6%9E%90/","excerpt":"vector 容器vector 原意是向量。在C++中，是一种用起来像动态数组的模板类。在不同的编译器中，vector 的实现都不尽相同，侯捷老师主要介绍的是G2.9和G4.9两个版本。","text":"vector 容器vector 原意是向量。在C++中，是一种用起来像动态数组的模板类。在不同的编译器中，vector 的实现都不尽相同，侯捷老师主要介绍的是G2.9和G4.9两个版本。 123456789//G2.9中 vector类的声明template&lt;class _Tp, class _alloc&gt;class vector&#123;...protected: iterator start; iterator finish; iterator end_of_storage;&#125;; vector . sizeof()曾经有同学试图使用 sizeof() 来计算 vector 对象有多少个元素，可是得到的结果都是意料之外的 ( 因为他数组可能有十多个整形变量，但是sizeof()得到的结果居然是 12 或者 24)。 从源码中可以看到vector的成员变量只有三个类型为 iterator 的迭代器对象，分别名为start , finish , end_of_storage : start : 指向所有内存空间开始的地址 finish : 指向所有内存空间使用的尾地址 end_of_storage : 指向所有内存空间结束的尾地址 vector 对象通过三个指针管理使用的内存空间，而实际的数据并不存储在 vector 对象中。这也就是 sizeof() 得不到想要的数组内存大小的原因。 vector . 内存成长vector 我们在使用的时候都知道它是一个动态数组，那么这个动态就体现在了可以动态地插入，动态地删除。那么 vector 对象控制的内存空间应该分配多少大小才能满足动态地插入呢？ 答案是未知。因为我们并不知道会动态插入多少数组，因此最好的方法是 : 内存空间动态增长。 规则 : 1vector&lt;int&gt; res; //默认构造 start == finish == end_of_storage 不分配内存空间 12345// 成长方式else&#123; const size_type old_size = size(); const size_type len = old_size != 0 ? 2 * old_size : 1; //下方第三点规则&#125; 在 res.size() == 0 时，插入一个元素会使得 res.size() == 1 以及 res.capacity() == 1 如果初始化的时候，赋予了它一定的内存空间，那么res.size() == res.capacity() == 赋值的长度 在 res.size() != 0 时，如果res.size() == res.capacity() ，那么 res.capacity() 呈2倍增长 需要注意的是，我们在最初为 vector 的某一个对象分配了一块内存之后，内存中紧接着之后的内存可能会被其他变量使用，因此 vector 的内存成长并不会发生在原地。它的实做是 : 在另一个位置申请好 capicity() 两倍大小的内存之后，进行逐一拷贝(copy或move)。那么如果 vector&lt;_Tp&gt; 这里的模板参数 typename _Tp 如果是一个类的话，会涉及到 _Tp 的析构函数和拷贝构造函数或移动构造函数。 vector . iterator迭代器 iterator 实际上是一种用起来像指针的类，本质上还是类，每一个迭代器都是类实例化的对象。并且，由于 vector queue list map/set 不同容器底层实现不完全相同或者有几种完全不同，因此并不能设计一种迭代器类同时满足所有容器的操作。 由于 vector 底层是内存连续的空间，因此迭代器也是最简单的。 123456//G2.9template &lt;class T, class Alloc = alloc&gt;class vector&#123; typedef T value_type; typedef value_type* iterator; //T*&#125;; 可以从源码中看到，**vector ** 的迭代器就是元素类型的指针，类型为 T* 。 12345678910111213141516171819//xcode : clangtemplate &lt;class _Tp, class _Allocator&gt;class __vector_base : protected __vector_base_common&lt;true&gt;&#123; public: typedef _Allocator allocator_type; typedef allocator_traits&lt;allocator_type&gt; __alloc_traits; typedef typename __alloc_traits::size_type size_type; protected: typedef _Tp value_type; typedef value_type&amp; reference; typedef const value_type&amp; const_reference; typedef typename __alloc_traits::difference_type difference_type; typedef typename __alloc_traits::pointer pointer; typedef typename __alloc_traits::const_pointer const_pointer; typedef pointer iterator; typedef const_pointer const_iterator; ...&#125; 123456789// 从上面提取template &lt;class _Tp, class _Allocator&gt;typedef _Allocator allocator_type;typedef allocator_traits&lt;allocator_type&gt; __alloc_traits;typedef typename __alloc_traits::pointer pointer;typedef pointer iterator;//因此,vector中的iterator 实际上是 allocator_traits&lt;_Allocator&gt;::pointer 类型//而默认的 allocator 中 pointer 的定义就是 T* (T通过模板参数传递) 从现在的 clang 中，都难以看出 iterator 实际的类型了，侯捷老师在STL源码剖析课程中多次吐槽版本迭代之后，标准库设计的越来越复杂了，也可能是我的功底仍然不够深厚，只能解析到这一步了。之后，在看完侯老师的《源码剖析》书之后，再来详细填补各种留下的坑。 迭代器的使用，迭代器类的继承，以及迭代器的操作符重载，在后续迭代器专题中整理。 vector . 继承关系12345678/*class __vector_base_common*/template &lt;bool&gt;class __vector_base_common&#123;protected: _LIBCPP_NORETURN void __throw_length_error() const; //模板传递在函数中使用 _LIBCPP_NORETURN void __throw_out_of_range() const; //模板传递在函数中使用&#125;; 12345678910111213141516171819/*class __vector_base*/template &lt;class _Tp, class _Allocator&gt;class __vector_base : public __vector_base_common&lt;true&gt;&#123;public: typedef _Allocator allocator_type; typedef allocator_traits&lt;allocator_type&gt; __alloc_traits; typedef ...protected: typedef typename __alloc_traits::pointer pointer; typedef ... //成员变量定义处,注意这里的类名不是vector,是vector私有继承了这个类 //sizeof() = 24 （= 8 * 3） pointer __begin_; pointer __end_; __compressed_pair&lt;pointer,allocator_type &gt; __end_cap_; //命名和G++不同,但是可以看得出说的是end_capacity&#125;; 12345/*struct __compressed_pair_elem*/template &lt;class _Tp, int _Idx&gt;struct __compressed_pair_elem&lt;_Tp, _Idx, true&gt; : private _Tp&#123;&#125; 123456/*class __compressed_pair*/template &lt;class _T1, class _T2&gt;class __compressed_pair : private __compressed_pair_elem&lt;_T1, 0&gt;, private __compressed_pair_elem&lt;_T2, 1&gt; &#123;&#125; 12345/*class vector*/template &lt;class _Tp, class _Allocator /* = allocator&lt;_Tp&gt; */&gt;class _LIBCPP_TEMPLATE_VIS vector : private __vector_base&lt;_Tp, _Allocator&gt;&#123;&#125; 以上是从 xcode : clang 中的 vector 和 memory 头文件中找到的源码，粘贴了部分我想展示的。 并且绘制了继承关系图，如下： 1234567891011121314151617classDiagram class _Tp class __compressed_pair_elem class __compressed_pair class __vector_base_common&#123; - pointer __begin__ - pointer __end__ - __compressed_pair&lt;pointer,allocator_type&gt; __end_cap_ &#125; class __vector_base class vector __vector_base &lt;|-- vector : Inheritance __vector_base_common &lt;|-- __vector_base : Inheritance __vector_base_common *-- __compressed_pair : Composition __compressed_pair_elem &lt;|-- __compressed_pair : Inheritance _Tp &lt;|-- __compressed_pair_elem : Inheritance 可以看到，我们使用的是 vector 模板类，它的 sizeof() = 24 ，也就是 class __vector_base_common 中定义的三根指针，在64位机中，指针为8字节。","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"容器","slug":"C/STL/容器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"vector","slug":"vector","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/vector/"}]},{"title":"两数之和","slug":"leetcode/others/两数之和","date":"2020-10-09T14:09:31.000Z","updated":"2020-11-24T14:16:50.380Z","comments":true,"path":"2020/10/09/leetcode/others/两数之和/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/09/leetcode/others/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"两数之和问题","text":"两数之和问题 两数之和题目描述Leetcode 1.两数之和 难度:简单 描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 * 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例 12给定 nums = [2, 7, 11, 15], target = 9函数签名 vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) 解法一第一种思路是采用暴力法(虽然说暴力法是无法通过leetcode的,但确实是首先想到的方法)。 我们只需要两层循环遍历数组，在循环索引不相等但是之和为 target 的时候，返回两个索引组成的数组即可。 1234567891011121314vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target)&#123; vector&lt;int&gt; res; // 结果 if(nums.empty()) return res; for(int i=0;i&lt;nums.size()-1;++i)&#123; //为减少内存循环次数,i只循环到最大值-1 for(int j=i+1;j&lt;nums.size();++j)&#123; if(nums.at(i) + nums.at(j) == target)&#123; res.push_back(i); res.push_back(j); return res; &#125; &#125; &#125; return res;&#125; 因为数组中同一元素不能使用两遍，因此内层循环索引 j 只需要从 i+1 开始，但是注意的是 i 不能到达 nums.size()-1 ，否则 j 会越界。所以外层判断条件得是 i&lt;nums.size()-1 。 时间复杂度 : O(N^2) 空间复杂度 : O(1) 。 解法二第二种思路是采用哈希表。 我们需要遍历一次数组，存下每一个&lt;num,index&gt;对，再逐一判断 key:target-num[i] 是否出现在哈希表中。 123456789101112131415vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target)&#123; vector&lt;int&gt; res; // 结果 unordered_map&lt;int,int&gt; record; //&lt;数值,索引&gt; for(int i=0;i&lt;nums.size();++i) record[nums.at(i)] = i; // 等同于 record.insert(pair&lt;int,int&gt;(nums.at(i),i)); for(int i=0;i&lt;nums.size();++i) if(record.find(target-nums.at(i)) != record.end()) &#123; //找到 res.push_back(i); res.push_back(record[target - nums.at(i)]); return res; &#125; return res;&#125; 因为我们在 hashmap 中查找的时间复杂度是 O(1) 。 因此，时间复杂度 : O(N) , 空间复杂度 : O(N)。 解法三第三种思路是采用排序+双指针。 因为形式参数的nums是传引用，所以我们需要对传入的nums进行一次拷贝，在拷贝上进行排序。排序后采用双指针法，找到两个加数的索引。 12345678910111213141516171819vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target)&#123; vector&lt;int&gt; res; // 结果 vector&lt;int&gt; nums_cp(nums); // 不让排序操作改变原数组 sort(nums_cp.begin(),nums_cp.end()); int left = 0, right = nums_cp.size() - 1; while(left &lt; right)&#123; // 1 int sum = nums_cp.at(left) + nums_cp.at(right); if( sum == target)&#123; res.push_back(left); res.push_back(right); return res; &#125; else if( sum &gt; target) right --; else if( sum &lt; target) left ++; &#125; return res;&#125; 注释:1 不能有等号，虽然我们定义的left right 是左闭右闭区间，但是题目要求一个数不能使用两次。因此不能取相等的情况。 时间复杂度 : O(NlogN+N) = O(NlogN) 空间复杂度 : O(N) 主要是多了一份拷贝。 两数之和数据结构设计设计API1234567class TwoSum&#123;public: // 向数组中添加一个新的数 number void add(int number); // 查找当前数组中是否有两数之和为 value bool find(int value);&#125;; 实现12345678910111213141516171819202122232425262728class TwoSum&#123;private: map&lt;int,int&gt; record; //&lt;数值,索引&gt; static int index; public: void add(int number)&#123; record[number] = index++; &#125; bool find(int value)&#123; //采用双指针法在红黑树的map auto left = record.begin(); auto right = record.end(); right --; while(left != right)&#123; int sum = (*left).first + (*right).first; //每一个节点是一个pair if(sum == value) return true; else if(sum &lt; value) left ++; else if(sum &gt; value) right --; &#125; return false; &#125;&#125;;int TwoSum::index = 0; 实现find的时候，和我们做题的时候方法略有不同。因为我们做题的时候，是有vector作为数据的支撑，我们能够在一个随机访问的内存结构里存取数据，而现在我们整个类只有record这一个map&lt;int,int&gt;类的数据和一个静态索引值，而且红黑树的迭代器遍历顺序是按照key升序的，因此我们可以采用双指针的方式来遍历。 class TwoSum 空间复杂度 : O(N) add(int) 时间复杂度 : O(1) find(int) 时间复杂度 : O(N) 改进如果是一个查询次数明显对于插入次数的场景，那么我们的 find() 函数的效率就有点过于低下，我们会重复查询许多次。于是，我们可以把查询的结果也给存下来，记录下每一种可能的和的数值。 12345678910111213141516class TwoSum&#123;private: vector&lt;int&gt; nums; //记录现有数组 unordered_set&lt;int&gt; sums; //记录可能的和 public: void add(int number)&#123; for(int n:nums) //每一次插入都把所有和给记录下来 sums.insert(n+number); nums.push_back(number); &#125; bool find(int value)&#123; return (sums.find(value) != sums.end()); //查找到value返回true &#125;&#125;; class TwoSum 空间复杂度 : O(N) add(int) 时间复杂度 : O(N) find(int) 时间复杂度 : O(1) 学习自 labuladong 三数之和N数之和","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"双指针","slug":"双指针","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"初识STL","slug":"STL/第一篇 认识STL","date":"2020-10-07T13:53:23.000Z","updated":"2020-11-24T14:18:42.292Z","comments":true,"path":"2020/10/07/STL/第一篇 认识STL/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/07/STL/%E7%AC%AC%E4%B8%80%E7%AF%87%20%E8%AE%A4%E8%AF%86STL/","excerpt":"","text":"STL什么是STL？STL : standard Template Library 标准模板库，STL是C++的一个重要组成部分。 STL包含了众多头文件 : 头文件名称 类型 &lt;algorithm&gt; 算法 &lt;deque&gt; 容器 &lt;functional&gt; 仿函数 &lt;iterator&gt; 迭代器 &lt;vector&gt; 容器 &lt;list&gt; 容器 &lt;map&gt; 容器 &lt;memory.h&gt; 智能指针 &lt;numeric&gt; 数值算法 &lt;queue&gt; 容器 &lt;set&gt; 容器 &lt;stack&gt; 容器 &lt;utility&gt; 比较符 + pair 浏览完以上这一个表格，可以简单了解到STL的组成。 六大部件STL主要包含六个部件： 容器 containers 是一个class template 分配器 allocators 是一个 class template 算法 algorithms 是一个 function template(用起来像函数) 迭代器 iterators 是一个 class template 适配器 adapters 是一个 class template 仿函数 functors 是一个 class template 简单介绍容器容器是数据的承载，容器的设计使得我们”看不到”内存 分配器分配器为容器分配内存回收内存，使得我们不需要插手容器的内存管理 算法算法是模板函数，独立于容器，更加泛化。(有一些容器里有同名重新处理过的函数) 迭代器算法作用于容器的中介，存取数据的一种泛化指针，本质是一种用起来像指针的对象 适配器容器 / 仿函数 / 迭代器的转换，设计思想：适配器设计模式 仿函数作用于容器元素的一种用起来像函数的类 设计思想GP模板编程思想：容器与算法分开。 相对的，OO编程思想：把成员变量和成员函数封装起来。 简单代码演示123vector&lt;int,allocator&lt;int&gt;&gt; vi(ia,ia+6); //容器 分配器cout&lt;&lt;count_if(vi.begin(),vi.end(),not1(bind2nd(less&lt;int&gt;(),40)));//less&lt;int&gt;()原本是a和b比较，bind2nd适配器绑定第二参数,用a和40比,not1适配是变成了大于等于条件 学习自 : 侯捷 STL","categories":[{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"}]},{"title":"单调队列","slug":"leetcode/others/单调队列","date":"2020-10-07T06:33:43.000Z","updated":"2020-11-24T14:17:18.600Z","comments":true,"path":"2020/10/07/leetcode/others/单调队列/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/07/leetcode/others/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","excerpt":"单调队列","text":"单调队列 介绍单调队列是一种特殊的数据结构。用来保持一个有序的队列。(无序的数据出队列) 通过适配 deque 而来。 API123456789template&lt; class Type &gt;class monotonous_queue&#123;private: deque&lt;Type&gt; data; //或者使用queuepublic: void push(Type); //尾部插入到单调队列中 void pop(Type); //从头部离开单调队列 Type max(); //返回单调队列中的最大元素&#125;; 实现12345678910111213141516171819template &lt; class Type &gt;void monotonous_queue&lt;Type&gt;::push(Type n)&#123; while(!data.empty() &amp;&amp; n &gt; data.back()) //保持单调队列特性，尾部比输入小的数值全部舍弃 data.pop_back(); data.push_back(n); return;&#125;template &lt; class Type &gt;void monotonous_queue&lt;Type&gt;::pop(Type n)&#123; if(!data.empty() &amp;&amp; data.front() == n) //有可能在pop之前，就因为push()中的步骤pop掉 data.pop_front(); return;&#125;template &lt; class Type &gt;Type monotonous_queue&lt;Type&gt;::max()&#123; return data.front();&#125; 实际上单调队列这一种数据结构使用的是队列中的pop_back() push_back() pop_front() back() front() 方法，queue容器中不提供 pop_back() 方法，因此不可以通过适配 queue 而来。 Leetcode 239 滑动窗口最大值难度:hard 链接:https://leetcode-cn.com/problems/sliding-window-maximum/ 源码: 1234567891011121314vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; monotonous_queue&lt;int&gt; mq; vector&lt;int&gt; res; for(int i=0;i&lt;nums.size();++i)&#123; if(i&lt;k-1) //当前滑动窗口中的元素小于k个时,直接入队 mq.push(nums[i]); else&#123; //入队后,输出窗口中的最大值给res,再弹出最前端为 nums[i-k+1] 的值,没有就不弹出 mq.push(nums[i]); res.push_back(mq.max()); mq.pop(nums[i-k+1]); &#125; &#125; return res;&#125; 时间复杂度：O(N) 空间复杂度：O(k) 学习自labuladong","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"数据结构/队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"单调队列","slug":"单调队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"单调栈","slug":"leetcode/others/单调栈","date":"2020-10-06T06:33:43.000Z","updated":"2020-11-24T14:17:03.840Z","comments":true,"path":"2020/10/06/leetcode/others/单调栈/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/06/leetcode/others/%E5%8D%95%E8%B0%83%E6%A0%88/","excerpt":"单调栈","text":"单调栈 介绍单调栈是一种特殊的数据结构。专门用于解决一类问题叫做 Next Greater Number的问题。 性质：单调栈本身还是栈，只是每一次入栈，都会使得栈的排列有序。(其实也就是不满足有序的元素都不要) 通过适配 stack 而来。 Next Greater Number问题描述找到数组中每一个数之后最近的一个比该数大的数字(两种情况，返回索引或返回数值) 1234567891011vector&lt;int&gt; next_greater_elem(const vector&lt;int&gt; &amp; nums)&#123; vector&lt;int&gt; res(nums.size()); //为了倒序访问,提前确定大小方便索引 stack&lt;pair&lt;int,int&gt;&gt; s; //单调栈 : pair&lt;数字,索引&gt; for(int i=nums.size()-1;i&gt;=0;i--)&#123; while(!s.empty() &amp;&amp; s.top().first &lt;= nums[i]) //如果栈顶端的数无法满足有序性,就全弹出 s.pop(); res[i] = (s.empty() == true ) ? 0 : s.top().second-i; //这里返回的是距离,也可返回索引或数值 s.push(pair&lt;int,int&gt;(nums[i],i)); //插入pair&lt;数字,索引&gt; &#125; return res;&#125; 时间复杂度：O(N) 空间复杂度：O(N) Leetcode 相关题目496. 下一个更大元素I 503.下一个更大元素II 1118.一月有多少天 学习自labuladong","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"数据结构/栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"二叉树的遍历","slug":"CodingSkills/二叉树遍历","date":"2020-09-25T10:58:19.000Z","updated":"2020-11-24T14:13:39.949Z","comments":true,"path":"2020/09/25/CodingSkills/二叉树遍历/","link":"","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/2020/09/25/CodingSkills/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/","excerpt":"二叉树遍历 博客文章主要目的是分享和记录。 分享给需要学习的同学，记录自己学习路上的点滴。 相信大家对于二叉树的定义以及结构，在本科《数据结构与算法》课程中或者在其他同学的博客中有所了解。在此，不在过多地回顾课本理论知识。","text":"二叉树遍历 博客文章主要目的是分享和记录。 分享给需要学习的同学，记录自己学习路上的点滴。 相信大家对于二叉树的定义以及结构，在本科《数据结构与算法》课程中或者在其他同学的博客中有所了解。在此，不在过多地回顾课本理论知识。 我们编码语言主要为C++，如下是二叉树在C++中类的表现形式，这边使用的是 struct 结构体，在C++中类和结构体的区别在于不标志 public , private 以及 protected 时, 成员变量和成员函数是 public 还是 private 以及默认的继承方式是 public 还是 private。使用 struct 的原因在于，结构体更想表达的是一种数据的组织形式，而不是ADT。 123456struct TreeNode &#123; int val; TreeNode* left; TreeNode* right; TreeNode*(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;&#125;; 并且配图可以更好地理解二叉树的结构。 二叉树的遍历方式在线性结构中，例如，在数组中我们采用索引值（即，地址偏移）的方式去遍历整个数组；在链表中我们采用迭代的方式去遍历整个链表。而二叉树和线性的数组和链表的最大区别在于，二叉树的每一个节点并非只有一个后继节点。因此就有了许多有趣的遍历方式。 分类按照遍历顺序可以分为三种: 前序 中序 后序 层序 按照遍历算法的写法可以分为： DFS（对应前中后的递归） BFS（对应层序） 还可以根据是否采用迭代写法分为： 迭代 递归 框架递归框架（前序中序后序框架）首先是递归，也是最简单书写的一种，其代码框架如下： 12345678void order(TreeNode * root)&#123; if(root == nullptr) return; // 前序 order(root-&gt;left); // 中序 order(root-&gt;right); // 后序&#125; 优缺点优点：递归很简单，我们只需要记住这一个代码框架就可以完成前中后序遍历； 缺点：递归过程中，从根节点出发不断递归左右节点，这一些函数调用的开销发生在栈空间，使得栈空间消耗巨大，甚至可能会导致栈溢出。 理解\u001c那么，为什么这样就可以实现遍历呢？ 递归写法必须有一个递归出口，也就是我们框架函数体内第一个语句，也就是我们递归到了叶子节点的时候，会调用 order(叶子节点的左孩子) 和 order(叶子节点的右孩子) 。那么这两个调用我们就应该停止递归了，也就是遇到了 root==nullptr 这个条件为 true ，递归返回。 那么对于任意一个非空节点来说我们需要做什么？我们无非是要做 : 访问它，访问它的左孩子，访问它的右孩子这三件事。那么既然有三件事，一定会涉及到顺序问题。这三者的顺序不同，就分出了三种访问顺序： 前序：根-左-右 中序：左-根-右 后序：左-右-根 比如，我们要按照中序的顺序输出二叉树的节点值： 12345678void order(TreeNode* root)&#123; if(root == nullptr) return; order(root-&gt;left); /*中序 begin */ cout &lt;&lt; root-&gt;val &lt;&lt; &#x27; &#x27;; //中序位置写执行语句,这一个区域写的root就是中序的节点 /*中序 end */ order(root-&gt;right);&#125;; 迭代框架（前序框架 与 中序框架）迭代框架没有递归框架那么简单，既没有对前中后序以及层序的通用模板，也没有递归那么语句短小，接下来主要介绍：前序，中序，后序，层序的迭代框架（模板）。 123456789101112131415161718vector&lt;int&gt; PreOrder(TreeNode *root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode *&gt; s; while (root || !s.empty()) &#123; if (root) &#123; s.push(root); // res.push_back(root-&gt;val); // PreOrder root = root-&gt;left; &#125; else &#123; root = s.top(); s.pop(); // res.push_back(root-&gt;val); // InOrder root = root-&gt;right; &#125; &#125; return res;&#125; 代码在上方，可以看到前序和中序的框架比较相似，在不同的位置执行操作，那么它的遍历顺序就可以不同。 理解前序遍历，我们总是先读根节点（或者对根节点做一系列操作），如果左孩子存在，再去访问当前根节点的左孩子，那么我们要访问当前节点的左孩子，如果我们需要之后再访问右孩子，我们岂不是无法回到那个根节点了？（树的结构不支持子节点到父节点的指针）。所以，我们需要借助一个辅助栈来存放没有访问过右节点的根节点，等我们把左子树访问完毕之后，再提出之前的根节点，来访问他的右子树。 如图，我们访问了节点1，去访问了节点2，那么我们访问完节点5之后需要回到节点1，再去访问节点3，因此必须把1给保留下来，但是我们不能用单个变量来保存节点1，因为在访问过程中，访问了节点2之后，访问节点4，再之后需要通过节点2，再去访问节点5，这样又需要一个变量来保存节点2，因此再迭代过程中，这个节点记录是一个变长的，所以需要一个辅助栈。 迭代框架（后序框架）前序和中序遍历的迭代框架是类似的，但是后序遍历的框架截然不同。后序遍历顺序：左-右-根。我们可以看到，后序的遍历顺序和前序遍历顺序（根-左-右）类似。我们可以稍微修改前序遍历的框架，再对数组进行反转，获得后序遍历顺序。 1234567891011121314151617181920212223vector&lt;int&gt; PostOrder(TreeNode *root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode *&gt; visit; TreeNode *cur = root; TreeNode *pre = nullptr; while (cur != nullptr || !visit.empty()) &#123; while (cur != nullptr) &#123; visit.push(cur); cur = cur-&gt;left; &#125; cur = visit.top(); if (cur-&gt;right == nullptr || cur-&gt;right == pre) &#123; visit.pop(); res.push_back(cur-&gt;val); pre = cur; cur = nullptr; &#125; else &#123; cur = cur-&gt;right; &#125; &#125; return res;&#125; 1234567891011121314151617181920vector&lt;int&gt; PostOrder_2(TreeNode *root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode *&gt; s; TreeNode *p = root; while (p != nullptr || !s.empty()) &#123; if (p != nullptr) &#123; res.push_back(p-&gt;val); //前序的位置 s.push(p); p = p-&gt;right; //区别在于遍历顺序是 根-右-左 &#125; else if(!s.empty())&#123; p = s.top(); s.pop(); p = p-&gt;left; &#125; &#125; reverse(res.begin(),res.end()); //得到 根-右-左, 反转之后得到 左-右-根 return res;&#125; 理解可以看一下以上的代码：PostOrder(TreeNode* root) 是正常思路的后序遍历迭代写法，而 PostOrder_2(TreeNode* root) 是前序遍历反转的写法。个人感觉前序遍历反转的模板和前序中序模板类似，思想方式较为统一。 迭代框架（层序遍历）层序遍历其实就是BFS的思想，遍历的顺序是按层从低到高来遍历。 1234567891011121314151617vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; deque&lt;TreeNode*&gt; q; q.push_back(root); while(!q.empty())&#123; int size = q.size(); res.push_back(vector&lt;int&gt;()); for(int i = 1;i &lt;= size;++i)&#123; TreeNode* node = q.front();q.pop_front(); res.back().push_back(node-&gt;val); if(node-&gt;left) q.push_back(node-&gt;left); if(node-&gt;right) q.push_back(node-&gt;right); &#125; &#125; return res;&#125; 理解 层序遍历相较于前中后序来说，它访问到了当前节点的兄弟节点以后，我们无法访问前节点的孩子节点。因此，这里不同的是，需要一个辅助的队列来存放同层的节点。 总结那么，二叉树的常见遍历写法都在这边啦。 递归写法因为每一个节点访问一次，所以时间复杂度为:O(N)，而递归需要在栈空间里开辟许多空间，平均递归的深度是logN，因此空间复杂度也是:O(logN)。 迭代写法因为每一个节点访问一次，所以时间复杂度为:O(N)，而迭代需要一个辅助栈或者辅助队列，平均的情况是把logN的节点放入栈或队列，最差的情况是把大多数节点全部放入栈或队列，因此空间复杂度也是：O(logN)。 而还有一个遍历写法叫做morris遍历，它能够实现空间复杂度为O(1)。但是写法较为复杂，准备另外再写一篇关于morris遍历的模板。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"数据结构/二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Linux/"},{"name":"tree","slug":"tree","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/tree/"},{"name":"排序算法","slug":"排序算法","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"},{"name":"剑指 Offer 专题","slug":"Leetcode/剑指-Offer-专题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"},{"name":"vector","slug":"vector","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/vector/"},{"name":"每日一题","slug":"Leetcode/每日一题","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"github","slug":"github","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/github/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"C++11","slug":"C/C-11","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/C-11/"},{"name":"STL","slug":"C/STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/"},{"name":"迭代器","slug":"C/STL/迭代器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《设计模式》","slug":"读书笔记/《设计模式》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"},{"name":"单一职责模式","slug":"读书笔记/《设计模式》/单一职责模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/"},{"name":"组件协作模式","slug":"读书笔记/《设计模式》/组件协作模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/"},{"name":"《深入理解计算机系统》","slug":"读书笔记/《深入理解计算机系统》","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"},{"name":"第八章 异常控制流","slug":"读书笔记/《深入理解计算机系统》/第八章-异常控制流","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"},{"name":"容器","slug":"C/STL/容器","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/STL/%E5%AE%B9%E5%99%A8/"},{"name":"网络通信","slug":"网络通信","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"传输层","slug":"网络通信/传输层","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"name":"TCP","slug":"网络通信/传输层/TCP","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"数据结构/栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"},{"name":"队列","slug":"数据结构/队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"},{"name":"二叉树","slug":"数据结构/二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Linux/"},{"name":"数据结构","slug":"数据结构","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"},{"name":"内存管理","slug":"内存管理","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"github","slug":"github","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/github/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"DFS","slug":"DFS","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/DFS/"},{"name":"动态规划","slug":"动态规划","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"C++11","slug":"C-11","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C-11/"},{"name":"智能指针","slug":"智能指针","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"name":"深入理解操作系统学习笔记","slug":"深入理解操作系统学习笔记","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"STL","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/STL/"},{"name":"iterator","slug":"iterator","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/iterator/"},{"name":"设计模式","slug":"设计模式","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"操作系统","slug":"操作系统","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"vector","slug":"vector","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/vector/"},{"name":"tcp","slug":"tcp","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/tcp/"},{"name":"栈","slug":"栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"二叉树","slug":"二叉树","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"中等","slug":"中等","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E4%B8%AD%E7%AD%89/"},{"name":"简单","slug":"简单","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"链表","slug":"链表","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"字符串","slug":"字符串","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希集合","slug":"哈希集合","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/"},{"name":"list","slug":"list","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/list/"},{"name":"双指针","slug":"双指针","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"单调队列","slug":"单调队列","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"单调栈","slug":"单调栈","permalink":"https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]}