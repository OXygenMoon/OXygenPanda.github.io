<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>深入理解操作系统学习笔记 | 劳振煜的知識倉儲</title>
  <meta name="description" content="第一章   第一章的主要内容是 : 操作系统的一些知识  操作系统是什么？用户角度：操作系统是一个控制软件  管理应用程序 为应用程序提供服务 杀死应用程序  程序角度：操作系统是资源管理器  管理外设、分配资源 抽象 将CPU抽象成进程 将磁盘抽象成文件 将内存抽象成地址空间    操作系统层次位于硬件之上，应用程序之下。 操作系统的界面和内核Linux Windows Andro">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解操作系统学习笔记">
<meta property="og:url" content="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/08/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/index.html">
<meta property="og:site_name" content="劳振煜的博客">
<meta property="og:description" content="第一章   第一章的主要内容是 : 操作系统的一些知识  操作系统是什么？用户角度：操作系统是一个控制软件  管理应用程序 为应用程序提供服务 杀死应用程序  程序角度：操作系统是资源管理器  管理外设、分配资源 抽象 将CPU抽象成进程 将磁盘抽象成文件 将内存抽象成地址空间    操作系统层次位于硬件之上，应用程序之下。 操作系统的界面和内核Linux Windows Andro">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger">
<meta property="og:image" content="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub">
<meta property="og:image" content="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat">
<meta property="og:image" content="https://camo.githubusercontent.com/9db208b68e844759210535e7ec1929186e60dae2153ac930d2e662a782ca7bd1/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31312f31312f4e416e7a484b6a3574454d343136682e6a7067">
<meta property="article:published_time" content="2020-11-08T12:07:00.000Z">
<meta property="article:modified_time" content="2020-11-14T13:45:18.189Z">
<meta property="article:author" content="劳振煜">
<meta property="article:tag" content="深入理解操作系统学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger">
  <!-- Canonical links -->
  <link rel="canonical" href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/08/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/index.html">
  
    <link rel="alternate" href="/atom.xml" title="劳振煜的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/OXygenPanda.github.io/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.2.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img class="img-circle img-rotate" src="/OXygenPanda.github.io/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">劳振煜</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">致力于技术开发</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 浙江嘉兴</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/OXygenPanda.github.io/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/OXygenPanda.github.io/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/OXygenPanda.github.io/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/OXygenPanda.github.io/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/OXygenPanda.github.io/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/OXygenPanda.github.io/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/OXygenPanda.github.io/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/OXygenPanda.github.io/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/OXygenPanda" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/OXygenPanda.github.io/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>交流编码以及分享乐趣.</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/C/">C++</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/C/C-11/">C++11</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/C/STL/">STL</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/C/STL/%E5%AE%B9%E5%99%A8/">容器</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/C/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/">迭代器</a><span class="category-list-count">2</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/Leetcode/">Leetcode</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/">剑指 Offer 专题</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/">栈</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/">队列</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP/">TCP</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/">《深入理解计算机系统》</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/">第八章 异常控制流</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/">《设计模式》</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/">单一职责模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/OXygenPanda.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/">组件协作模式</a><span class="category-list-count">2</span></li></ul></li></ul></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/C/" rel="tag">C++</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/C-11/" rel="tag">C++11</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/Leetcode/" rel="tag">Leetcode</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/STL/" rel="tag">STL</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/iterator/" rel="tag">iterator</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/list/" rel="tag">list</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/tcp/" rel="tag">tcp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/vector/" rel="tag">vector</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E4%B8%AD%E7%AD%89/" rel="tag">中等</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">单调栈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" rel="tag">单调队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="tag">哈希表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/" rel="tag">哈希集合</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="tag">智能指针</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E6%A0%88/" rel="tag">栈</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">深入理解操作系统学习笔记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/" rel="tag">简单</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/OXygenPanda.github.io/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/OXygenPanda.github.io/tags/C/" style="font-size: 13.8px;">C++</a> <a href="/OXygenPanda.github.io/tags/C-11/" style="font-size: 13.2px;">C++11</a> <a href="/OXygenPanda.github.io/tags/Leetcode/" style="font-size: 14px;">Leetcode</a> <a href="/OXygenPanda.github.io/tags/STL/" style="font-size: 13.8px;">STL</a> <a href="/OXygenPanda.github.io/tags/iterator/" style="font-size: 13.2px;">iterator</a> <a href="/OXygenPanda.github.io/tags/list/" style="font-size: 13px;">list</a> <a href="/OXygenPanda.github.io/tags/tcp/" style="font-size: 13px;">tcp</a> <a href="/OXygenPanda.github.io/tags/vector/" style="font-size: 13.2px;">vector</a> <a href="/OXygenPanda.github.io/tags/%E4%B8%AD%E7%AD%89/" style="font-size: 13px;">中等</a> <a href="/OXygenPanda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 13.4px;">二叉树</a> <a href="/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 13px;">单调栈</a> <a href="/OXygenPanda.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" style="font-size: 13px;">单调队列</a> <a href="/OXygenPanda.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 13px;">双指针</a> <a href="/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" style="font-size: 13px;">哈希表</a> <a href="/OXygenPanda.github.io/tags/%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/" style="font-size: 13px;">哈希集合</a> <a href="/OXygenPanda.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 13px;">字符串</a> <a href="/OXygenPanda.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 13px;">操作系统</a> <a href="/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.4px;">数据结构</a> <a href="/OXygenPanda.github.io/tags/%E6%95%B0%E7%BB%84/" style="font-size: 13px;">数组</a> <a href="/OXygenPanda.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" style="font-size: 13px;">智能指针</a> <a href="/OXygenPanda.github.io/tags/%E6%A0%88/" style="font-size: 13.4px;">栈</a> <a href="/OXygenPanda.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 13px;">深入理解操作系统学习笔记</a> <a href="/OXygenPanda.github.io/tags/%E7%AE%80%E5%8D%95/" style="font-size: 13.6px;">简单</a> <a href="/OXygenPanda.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.6px;">设计模式</a> <a href="/OXygenPanda.github.io/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 13px;">链表</a> <a href="/OXygenPanda.github.io/tags/%E9%98%9F%E5%88%97/" style="font-size: 13.2px;">队列</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/OXygenPanda.github.io/archives/2020/11/">十一月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/OXygenPanda.github.io/archives/2020/10/">十月 2020</a><span class="archive-list-count">22</span></li><li class="archive-list-item"><a class="archive-list-link" href="/OXygenPanda.github.io/archives/2020/09/">九月 2020</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/OXygenPanda.github.io/2020/11/12/C++11/smart_ptr/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/OXygenPanda.github.io/categories/C/">C++</a>
              </p>
              <p class="item-title">
                <a href="/OXygenPanda.github.io/2020/11/12/C++11/smart_ptr/" class="title">shared_ptr的简单实现</a>
              </p>
              <p class="item-date">
                <time datetime="2020-11-12T11:23:00.000Z" itemprop="datePublished">2020-11-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/OXygenPanda.github.io/2020/11/08/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/OXygenPanda.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
              </p>
              <p class="item-title">
                <a href="/OXygenPanda.github.io/2020/11/08/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/" class="title">深入理解操作系统学习笔记</a>
              </p>
              <p class="item-date">
                <time datetime="2020-11-08T12:07:00.000Z" itemprop="datePublished">2020-11-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/OXygenPanda.github.io/2020/11/03/C++11/C++11/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/OXygenPanda.github.io/categories/C/">C++</a><i class="icon icon-angle-right"></i><a class="category-link" href="/OXygenPanda.github.io/categories/C/C-11/">C++11</a>
              </p>
              <p class="item-title">
                <a href="/OXygenPanda.github.io/2020/11/03/C++11/C++11/" class="title">C++11新语法新特性使用剖析</a>
              </p>
              <p class="item-date">
                <time datetime="2020-11-03T15:27:00.000Z" itemprop="datePublished">2020-11-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/OXygenPanda.github.io/2020/10/31/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/STL-type%20traits/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/OXygenPanda.github.io/categories/C/">C++</a><i class="icon icon-angle-right"></i><a class="category-link" href="/OXygenPanda.github.io/categories/C/STL/">STL</a>
              </p>
              <p class="item-title">
                <a href="/OXygenPanda.github.io/2020/10/31/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/STL-type%20traits/" class="title">理解 type_traits</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-31T09:42:00.000Z" itemprop="datePublished">2020-10-31</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/OXygenPanda.github.io/2020/10/30/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/STL-iterator%20traits/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/OXygenPanda.github.io/categories/C/">C++</a><i class="icon icon-angle-right"></i><a class="category-link" href="/OXygenPanda.github.io/categories/C/STL/">STL</a>
              </p>
              <p class="item-title">
                <a href="/OXygenPanda.github.io/2020/10/30/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/STL-iterator%20traits/" class="title">理解 iterator_traits</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-30T06:46:00.000Z" itemprop="datePublished">2020-10-30</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-OperatingSystem/QingHua/Deep_into_OperatingSystem_all" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      深入理解操作系统学习笔记
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/OXygenPanda.github.io/2020/11/08/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/" class="article-date">
	  <time datetime="2020-11-08T12:07:00.000Z" itemprop="datePublished">2020-11-08</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/OXygenPanda.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/OXygenPanda.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">深入理解操作系统学习笔记</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/OXygenPanda.github.io/2020/11/08/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 10.2k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 35(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p align="center">
<a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a>
<a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a>
<a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a>



</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><blockquote>
<p>  第一章的主要内容是 : 操作系统的一些知识</p>
</blockquote>
<h3 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h3><p>用户角度：操作系统是一个控制软件</p>
<ul>
<li>管理应用程序</li>
<li>为应用程序提供服务</li>
<li>杀死应用程序</li>
</ul>
<p>程序角度：操作系统是资源管理器</p>
<ul>
<li>管理外设、分配资源</li>
<li>抽象<ul>
<li>将CPU抽象成进程</li>
<li>将磁盘抽象成文件</li>
<li>将内存抽象成地址空间</li>
</ul>
</li>
</ul>
<h3 id="操作系统层次"><a href="#操作系统层次" class="headerlink" title="操作系统层次"></a>操作系统层次</h3><p>位于硬件之上，应用程序之下。</p>
<h3 id="操作系统的界面和内核"><a href="#操作系统的界面和内核" class="headerlink" title="操作系统的界面和内核"></a>操作系统的界面和内核</h3><p>Linux Windows Android 的界面属于外壳(Shell) ，而不是内核(kernel)。操作系统研究的是内核，处于Shell之下。</p>
<h3 id="操作系统内部组件"><a href="#操作系统内部组件" class="headerlink" title="操作系统内部组件"></a>操作系统内部组件</h3><ul>
<li>CPU调度器</li>
<li>物理内存管理</li>
<li>虚拟内存管理</li>
<li>文件系统管理</li>
<li>中断处理与设备驱动</li>
</ul>
<h3 id="操作系统特征"><a href="#操作系统特征" class="headerlink" title="操作系统特征"></a>操作系统特征</h3><ul>
<li>并发<ul>
<li>一段时间内运行多个进程（并行 : 一个时间点运行多个进程，一般要求有多个CPU)</li>
<li>需要OS管理和调度</li>
</ul>
</li>
<li>共享<ul>
<li>“同时”共享</li>
<li>互斥共享</li>
</ul>
</li>
<li>虚拟<ul>
<li>让每一个用户觉得的有一个计算机专门为他服务</li>
</ul>
</li>
<li>异步<ul>
<li>程序是走走停停，而不是一直运行</li>
</ul>
</li>
</ul>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><blockquote>
<p>  第二章的主要内容是 : 操作系统的异常/中断/系统调用</p>
</blockquote>
<h2 id="探究计算机启动过程"><a href="#探究计算机启动过程" class="headerlink" title="探究计算机启动过程"></a>探究计算机启动过程</h2><p><strong>作用解析</strong></p>
<p>Disk : 存放OS和Bootloader</p>
<p>BOIS : 基于I/O处理系统</p>
<p>Bootloader : 加载OS，将OS放入内存</p>
<p><strong>结构</strong></p>
<p>Disk</p>
<p>   |___ OS</p>
<p>   |___ Bootloader</p>
<p><strong>开机流程</strong></p>
<ol>
<li><p>BIOS</p>
<ul>
<li>开机后，寻找显卡和执行BIOS (此时, <code>CS : IP = 0xF000 : 0xFFF0</code>,  CS/IP 两个寄存器) </li>
<li>将Bootloader从磁盘的引导扇区加载到0x7C00 (Bootloader一共占用512M字节的内存)</li>
<li>跳转到 <code>CS : IP = 0x0000 : 0x7C00</code></li>
</ul>
</li>
<li><p>Bootloader</p>
<ul>
<li>将操作系统的代码和数据从硬盘加载到内存中</li>
<li>跳转到操作系统的起始地址</li>
</ul>
</li>
</ol>
<h2 id="中断、异常、系统调用"><a href="#中断、异常、系统调用" class="headerlink" title="中断、异常、系统调用"></a>中断、异常、系统调用</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断来源于外设，来自不同的硬件设备的计时器和网络的中断。</p>
<p><strong>中断流程</strong></p>
<p>硬件：设置中断标记（CPU初始化）</p>
<ol>
<li>将内部、外部事件设置中断标记</li>
<li>中断事件的ID</li>
</ol>
<p>软件</p>
<ol>
<li>保存当前处理状态（寄存器之类的一些数据）</li>
<li>根据中断事件的ID跳转到中断服务程序，中断服务程序处理</li>
<li>清楚中断标记</li>
</ol>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常来源于不良的应用程序，非法指令或者其他坏的处理状态（如：内存出错）。</p>
<p><strong>异常处理流程</strong></p>
<ol>
<li>保存现场</li>
<li>异常处理<ol>
<li>杀死了产生异常的程序</li>
<li>重新执行异常指令</li>
</ol>
</li>
<li>恢复现场</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用来源于应用程序，应用程序主动向操作系统发出服务请求。程序访问主要是通过高层次的API，而不是直接调用系统调用函数。</p>
<p><strong>APIs</strong></p>
<ul>
<li>Win32 API 用于Windows</li>
<li>POSIX API 用于 POSIX-based systems（包括UNIX，LINUX，Mac OS X）</li>
<li>Java API 用于JAVA虚拟机</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>通常情况下，每个系统调用有对应的序号<ul>
<li>系统调用接口根据这些序号来维护表的索引</li>
</ul>
</li>
<li>系统调用接口调用内核态中预期的系统调用<ul>
<li>并返回系统调用的状态和其他任何返回值</li>
</ul>
</li>
<li>用户不需要知道系统调用是如何实现的<ul>
<li>只需要获取API和了解操作系统将什么作为返回结果</li>
<li>操作系统接口的细节大部分都隐藏在API中</li>
</ul>
</li>
</ul>
<p><strong>用户态</strong>：操作系统运行中，CPU处于的特权级别，不能直接执行特权指令</p>
<p><strong>内核态</strong>：操作系统运行中，CPU处于的特权级别，可以执行任何一条指令</p>
<p><strong>系统调用</strong>：触发CPU从用户态到内核态的转换，切换程序和内核的堆栈，需要一定的开销</p>
<p><strong>跨越操作系统边界的开销（值得的且必须的，保证了操作系统的安全性）</strong></p>
<ul>
<li>在执行时间上的开销超过程序调用</li>
<li>开销：<ul>
<li>建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销</li>
<li>建立内核堆栈</li>
<li>验证参数</li>
<li>内核态映射到用户态的地址空间（更新页面映射权限）</li>
<li>内核态独立地址空间（TLB）</li>
</ul>
</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table>
<thead>
<tr>
<th>类型</th>
<th>源头</th>
<th>处理时间</th>
<th>响应</th>
</tr>
</thead>
<tbody><tr>
<td>中断</td>
<td>外设</td>
<td>异步</td>
<td>持续，对应用程序透明</td>
</tr>
<tr>
<td>异常</td>
<td>应用程序意向不到的行为</td>
<td>同步</td>
<td>杀死或重新执行指令</td>
</tr>
<tr>
<td>系统调用</td>
<td>应用程序请求系统提供服务</td>
<td>同步或异步</td>
<td>等待和持续</td>
</tr>
</tbody></table>
<blockquote>
<p>  异步：应用程序不知道什么时候会发生中断</p>
</blockquote>
<blockquote>
<p>  同步：执行到某一条指令一定会发生该事件</p>
</blockquote>
<h3 id="为什么应用程序不能直接访问硬件？"><a href="#为什么应用程序不能直接访问硬件？" class="headerlink" title="为什么应用程序不能直接访问硬件？"></a>为什么应用程序不能直接访问硬件？</h3><ul>
<li>在计算机运行时，内核是被信任的第三方</li>
<li>只有内核可以执行特权指令</li>
<li>为了方便应用程序</li>
</ul>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><blockquote>
<p>  第三章的主要内容是 : 操作系统的物理内存管理</p>
</blockquote>
<h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><ol>
<li>CPU</li>
<li>内存</li>
<li>I/O</li>
</ol>
<h2 id="内存分层体系"><a href="#内存分层体系" class="headerlink" title="内存分层体系"></a>内存分层体系</h2><h3 id="内存分层体系-1"><a href="#内存分层体系-1" class="headerlink" title="内存分层体系"></a>内存分层体系</h3><p>运行内存(主存) / 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.</p>
<p>CPU可以访问的内存包括两大类 : 寄存器 / cache(L1缓存 / L2缓存)</p>
<p><strong>层次</strong></p>
<p>微处理器(CPU访问)</p>
<p>|___CPU寄存器 / L1缓存</p>
<p>|___L2缓存</p>
<p>主存(程序访问)</p>
<p>磁盘(程序访问)</p>
<blockquote>
<p>  从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。</p>
</blockquote>
<h3 id="内存管理目标"><a href="#内存管理目标" class="headerlink" title="内存管理目标"></a>内存管理目标</h3><ul>
<li><p>抽象：逻辑地址空间</p>
</li>
<li><p>保护：独立地址空间</p>
</li>
<li><p>共享：访问相同内存</p>
</li>
<li><p>虚拟：更多的地址空间</p>
</li>
</ul>
<h3 id="内存管理方法"><a href="#内存管理方法" class="headerlink" title="内存管理方法"></a>内存管理方法</h3><ul>
<li>程序重定位</li>
<li>分段</li>
<li>分页</li>
<li>虚拟内存</li>
<li>按需分页虚拟内存</li>
</ul>
<blockquote>
<p>  实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求</p>
</blockquote>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>地址空间的定义</p>
<ul>
<li>物理地址空间 —— 硬件支持的地址空间( address : [0, Max_sys] )</li>
<li>逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] )</li>
</ul>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p>内存碎片问题指的是空闲的内存无法被利用</p>
<ul>
<li>外部碎片 : 分配单元间的未使用内存</li>
<li>内部碎片 : 分配单元内的未使用内存</li>
</ul>
<h3 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h3><p>分区的动态分配方式有以下三种 :</p>
<ol>
<li>第一匹配分配 : 在内存中找到第一个比需求大的空闲块, 分配给应用程序</li>
<li>最优适配分配 : 在内存中找到最小的空闲块, 分配给应用程序</li>
<li>最差适配分配 : 在内存中找到最大的空闲块, 分配给应用程序</li>
</ol>
<p>分配方式的区别</p>
<table>
<thead>
<tr>
<th>分配方式</th>
<th>第一匹配分配</th>
<th>最优适配分配</th>
<th>最差适配分配</th>
</tr>
</thead>
<tbody><tr>
<td>分配方式实现需求</td>
<td>1. 按地址排序的空闲块列表<br>2. 分配需要寻找一个合适的分区<br>3. 重分配需要检查是否可以合并相邻空闲分区</td>
<td>1. 按尺寸排序的空闲块列表<br>2. 分配需要寻找一个合适的分区<br>3. 重分配需要检查是否可以合并相邻空闲分区</td>
<td>1. 按尺寸排序的空闲块列表<br>2. 分配最大的分区<br>3. 重分配需要检查是否可以合并相邻空闲分区</td>
</tr>
<tr>
<td>优势</td>
<td>简单 / 易于产生更大空闲块</td>
<td>比较简单 / 大部分分配是小尺寸时高效</td>
<td>分配很快 / 大部分分配是中尺寸时高效</td>
</tr>
<tr>
<td>劣势</td>
<td>产生外部碎片 / 不确定性</td>
<td>产生外部碎片 / 重分配慢 / 产生很多没用的微小碎片</td>
<td>产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配</td>
</tr>
</tbody></table>
<blockquote>
<p>  三种分配方式并无优劣之分，因为我们无法判断内存请求的大小</p>
</blockquote>
<h2 id="碎片整理方法"><a href="#碎片整理方法" class="headerlink" title="碎片整理方法"></a>碎片整理方法</h2><p>可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。</p>
<ol>
<li><p>压缩式碎片整理</p>
<ul>
<li>重置程序以合并碎片</li>
<li>要求所有程序是动态可重置的</li>
<li>问题 : <ul>
<li>何时重置 ? (在程序处于等待状态时才可以重置)</li>
<li>需要考虑内存拷贝的开销</li>
</ul>
</li>
</ul>
</li>
<li><p>交换式碎片整理</p>
<ul>
<li><p>运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存</p>
</li>
<li><p>问题 :</p>
<ul>
<li>哪些程序应该被回收 ?</li>
</ul>
</li>
<li><p>情况 :</p>
<p>运行中 : P3</p>
<p>等待中 : P1 P2 P4</p>
<p>内存分布 -&gt; 主存 : OS / P1 / P3 / P2 / P4 磁盘 : 空</p>
<p>当P3程序需要更大的内存时 -&gt;</p>
<p>内存分布 -&gt; 主存 : OS / P1 / P3 / P2         磁盘 : P4</p>
</li>
</ul>
</li>
</ol>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><blockquote>
<p>  第四章的主要内容是：操作系统的非连续内存分配</p>
</blockquote>
<p>第三章介绍的是连续内存管理, 即 : 操作系统加载到内存以及程序加载到内存中时, 分配一块连续的空闲(内存)块. 但是容易出现碎片问题, 这一章介绍的非连续内存分配可以有效的减少碎片的出现.</p>
<h2 id="非连续内存分配的必要性"><a href="#非连续内存分配的必要性" class="headerlink" title="非连续内存分配的必要性"></a>非连续内存分配的必要性</h2><h3 id="连续内存分配的缺点"><a href="#连续内存分配的缺点" class="headerlink" title="连续内存分配的缺点"></a>连续内存分配的缺点</h3><ol>
<li>分配给一个程序的物理内存是连续的</li>
<li>内存利用率低</li>
<li>有外碎片 / 内碎片的问题</li>
</ol>
<h3 id="非连续内存分配的优点"><a href="#非连续内存分配的优点" class="headerlink" title="非连续内存分配的优点"></a>非连续内存分配的优点</h3><ol>
<li><p>一个程序的物理地址空间是非连续的</p>
</li>
<li><p>更好的内存利用和管理</p>
</li>
<li><p>允许共享代码与数据(共享库等…)</p>
</li>
<li><p>支持动态加载和动态链接</p>
</li>
</ol>
<h3 id="非连续内存分配的缺点"><a href="#非连续内存分配的缺点" class="headerlink" title="非连续内存分配的缺点"></a>非连续内存分配的缺点</h3><ol>
<li><p>建立虚拟地址和物理地址的转换难度大</p>
<ul>
<li><p>软件方案</p>
</li>
<li><p>硬件方案(采用硬件方案) : 分段 / 分页</p>
</li>
</ul>
</li>
</ol>
<h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="分段-Segmentation"><a href="#分段-Segmentation" class="headerlink" title="分段(Segmentation)"></a>分段(Segmentation)</h3><p><strong>段 :</strong> 在程序中会有来自不同文件的函数 ; 在程序执行时, 不同的数据也有不同的字段, 比如 : 堆 / 栈 / .bss / .data 等</p>
<p>**分段 : ** 更好的分离和共享</p>
<p>程序的分段地址空间如下图所示 : </p>
<img src="https://camo.githubusercontent.com/9db208b68e844759210535e7ec1929186e60dae2153ac930d2e662a782ca7bd1/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31312f31312f4e416e7a484b6a3574454d343136682e6a7067">

<p><strong>分段寻址方案</strong></p>
<p>逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联.</p>
<p>一个段 : 一个内存”块”</p>
<p>程序访问内存地址需要 : 一个二维的二元组(s, addr) → (段号, 地址)</p>
<p>操作系统维护一张段表, 存储(段号, 物理地址中的起始地址, 长度限制)</p>
<p>物理地址 : 段表中的起始地址 + 二元组中的偏移地址</p>
<h3 id="分页-Paging"><a href="#分页-Paging" class="headerlink" title="分页(Paging)"></a>分页(Paging)</h3><h4 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h4><p>划分物理内存至固定大小的帧(Frame)</p>
<ul>
<li>大小是2的幂, 512 / 4096 / 8192</li>
</ul>
<p>划分逻辑地址空间至相同大小的页(Page)</p>
<ul>
<li>大小是2的幂, 512 / 4096 / 8192</li>
</ul>
<p>建立方案 → 转换逻辑地址为物理地址(pages to frames)</p>
<ul>
<li>页表</li>
<li>MMU / TLB</li>
</ul>
<p><strong>帧(Frame)</strong></p>
<p>物理内存被分割为大小相等的帧. 一个内存物理地址是一个二元组(f, o) → (帧号, 帧内偏移)</p>
<p>帧号 : F位, 共有2^F个帧</p>
<p>帧内偏移 : S位, 每帧有2^S个字节</p>
<p>物理地址 = 2^S * f + o</p>
<p>(例子 : 16-bit地址空间, 9-bit(512 byte) 大小的页帧 物理地址 = (3,6) 物理地址 = 2^9 * 3 + 6 = 1542)</p>
<blockquote>
<p>  分页和分段的最大区别 : 这里的 S 是一个固定的数, 而分段中的长度限制不定</p>
</blockquote>
<p><strong>页(Page)</strong></p>
<p>一个程序的逻辑地址空间被划分为大小相等的页. 页内偏移的大小 = 帧内偏移的大小 页号大小 &lt;&gt; 帧号大小</p>
<p>一个逻辑地址是一个二元组(p, o) → (页号, 页内偏移)</p>
<p>页号 : P位, 共有2^P个页</p>
<p>页内偏移 : S位, 每页有2^S个字节</p>
<p>虚拟地址  = 2^S * p + o</p>
<h4 id="页寻址方案"><a href="#页寻址方案" class="headerlink" title="页寻址方案"></a>页寻址方案</h4><p>操作系统维护一张页表, 页表保存了逻辑地址——物理地址之间的映射关系</p>
<p>存储 : (页号, 帧号)</p>
<ul>
<li>逻辑地址空间应当大于物理内存空间</li>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存(有助于减少碎片的产生)</li>
<li>不是所有的页都有对应的帧</li>
</ul>
<h3 id="页表-Page-Table"><a href="#页表-Page-Table" class="headerlink" title="页表(Page Table)"></a>页表(Page Table)</h3><h4 id="页表概述"><a href="#页表概述" class="headerlink" title="页表概述"></a>页表概述</h4><p>每一个运行的程序都有一个页表</p>
<ul>
<li>属于程序运行状态, 会动态变化</li>
<li>PTBR : 页表基址寄存器</li>
</ul>
<p><strong>转换流程</strong></p>
<p>CPU根据程序的page的页号的若干位, 计算出索引值index, 在页表中搜索这个index, 得到的是帧号, 帧号和原本的offset组成物理地址.</p>
<p>页表中还有一些特殊标志位</p>
<ul>
<li>dirty bit,</li>
<li>resident bit, (0 : 对应的物理页帧在内存中不存在 ; 1 : 存在)</li>
<li>clock / reference bit</li>
</ul>
<p><strong>转换实例</strong></p>
<p>16位地址的系统</p>
<ul>
<li>32KB的物理内存</li>
<li>每页的 1024 byte</li>
</ul>
<p>逻辑地址空间 : (4, 0) … (3, 1023)</p>
<p>页表 :</p>
<p>Flags |  Frame nums</p>
<p>1 0 1    0 0 0 0 0          → 内存访问异常(可能要杀死程序)</p>
<p>0 1 1    0 0 1 0 0           → 页帧是4 偏移是 1023 → 物理地址 (4, 1023)</p>
<h4 id="分页机制的性能问题"><a href="#分页机制的性能问题" class="headerlink" title="分页机制的性能问题"></a>分页机制的性能问题</h4><p>访问一个内存单元需要2次内存访问</p>
<ul>
<li>一次用于获取页表项</li>
<li>一次用于访问数据</li>
</ul>
<p>页表可能非常大</p>
<ul>
<li>64位机器如果每页1024字节, 那么一个页表的大小会是多少？(2^64 / 2^10 = 2^54 存放不下)</li>
<li>每一个运行的程序都需要有一个页表</li>
</ul>
<p>如何处理？</p>
<ul>
<li>缓存(Caching)</li>
<li>间接(Indirection)访问</li>
</ul>
<h4 id="转换后备缓冲区-TLB"><a href="#转换后备缓冲区-TLB" class="headerlink" title="转换后备缓冲区(TLB)"></a>转换后备缓冲区(TLB)</h4><p>缓解时间问题</p>
<p>Translation Look-aside Buffer(TLB) 是一个缓冲区. CPU中有快表TLB(可以将经常访问的页表存放在这边)</p>
<p>缓存近期访问的页帧转换表项</p>
<ul>
<li>TLB使用关联内存实现, 具备快速访问性能</li>
<li>如果TLB命中, 物理页号可以很快被获取</li>
<li>如果TLB未命中, 对应的表项被更新到TLB中(x86的CPU由硬件实现, 其他的可能是由操作系统实现)</li>
</ul>
<h4 id="二级-多级页表"><a href="#二级-多级页表" class="headerlink" title="二级/多级页表"></a>二级/多级页表</h4><p>时间换空间</p>
<p>二级页表</p>
<ul>
<li>将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表.</li>
<li>一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号</li>
<li>节约了一定的空间, 在一级页表中如果resident bit = 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留</li>
</ul>
<p>多级页表</p>
<ul>
<li>通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树”</li>
</ul>
<h4 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h4><p>解决大地址空间问题</p>
<p>目的 : 根据帧号获得页号</p>
<p>反向页表只需要存在一张即可</p>
<ul>
<li>有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表</li>
<li>不是让页表与逻辑地址空间的大小相对应, 而是当页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间</li>
</ul>
<h5 id="基于页寄存器-Page-Registers-的方案"><a href="#基于页寄存器-Page-Registers-的方案" class="headerlink" title="基于页寄存器(Page Registers)的方案"></a>基于页寄存器(Page Registers)的方案</h5><p>存储 (帧号, 页号) 使得表大小与物理内存大小相关, 而与逻辑内存关联减小.</p>
<p>每一个帧和一个寄存器关联, 寄存器内容包括 :</p>
<ul>
<li>resident bit : 此帧是否被占用</li>
<li>occupier : 对应的页号 p</li>
<li>protection bits : 保护位</li>
</ul>
<p>实例 :</p>
<ul>
<li>物理内存大小是 : 4096 * 4096 = 4K * 4KB = 16 MB</li>
<li>页面大小是 : 4096 bytes = 4 KB</li>
<li>页帧数 : 4096 = 4 K</li>
<li>页寄存器使用的空间(假设8 bytes / register) : 8 * 4096 = 32 Kbytes</li>
<li>页寄存器带来的额外开销 : 32K / 16M = 0.2%</li>
<li>虚拟内存大小 : 任意</li>
</ul>
<p>优势 :</p>
<ul>
<li>转换表的大小相对于物理内存来说很小</li>
<li>转换表的大小跟逻辑地址空间的大小无关</li>
</ul>
<p>劣势 :</p>
<ul>
<li>需要的信息对调了, 即根据帧号可以找到页号</li>
<li>如何转换回来? (如何根据页号找到帧号)</li>
<li>在需要在反向页表中搜索想要的页号</li>
</ul>
<h5 id="基于关联内存-associative-memory-的方案"><a href="#基于关联内存-associative-memory-的方案" class="headerlink" title="基于关联内存(associative memory)的方案"></a>基于关联内存(associative memory)的方案</h5><p>硬件设计复杂, 容量不大, 需要放置在CPU中</p>
<ul>
<li>如果帧数较少, 页寄存器可以被放置在关联内存中</li>
<li>在关联内存中查找逻辑页号<ul>
<li>成功 : 帧号被提取</li>
<li>失败 : 页错误异常 (page fault)</li>
</ul>
</li>
<li>限制因素:<ul>
<li>大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电)</li>
</ul>
</li>
</ul>
<h5 id="基于哈希-hash-的方案"><a href="#基于哈希-hash-的方案" class="headerlink" title="基于哈希(hash)的方案"></a>基于哈希(hash)的方案</h5><p>哈希函数 : h(PID, p) 从 PID 标号获得页号</p>
<p>在反向页表中通过哈希算法来搜索一个页对应的帧号</p>
<ul>
<li>对页号做哈希计算, 为了在帧表中获取对应的帧号</li>
<li>页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数</li>
<li>为了查找页 i , 执行下列操作 :<ul>
<li>计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器</li>
<li>检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败</li>
</ul>
</li>
</ul>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><blockquote>
<p>  第五章的主要内容是：操作系统的虚拟内存管理技术</p>
</blockquote>
<h2 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h2><p>使用硬盘/磁盘使更多的程序在有限的内存中运行</p>
<p>理想的存储器 : 更大更快更便宜和非易失性的存储区</p>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>如果是程序太大, 超出了内存的容量, 可以采用手动的概率(overlay)技术, 只把需要的指令和数据保存在内存当中</p>
<p>目的 : 是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用.</p>
<p>原理 :</p>
<p>把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行.</p>
<ul>
<li>必要部分(常用功能)的代码和数据常驻内存;</li>
<li>可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存;</li>
<li>不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区.</li>
</ul>
<blockquote>
<p>  也就是说,程序松耦合的部分可以按需装入内存,不需要的时候放在外存中,多个不常用部分共用一个分区.</p>
</blockquote>
<p>实例 :</p>
<p>A(20k) <strong>__B(50k) __</strong> D(30k)<br>        | <strong>__ C(30k) __</strong> E(20k)<br>                             |____ F(40k)</p>
<p>因此不需要将整个程序190k的数据全部放入内存中, 而是划分为 常驻区(20k) 覆盖区0(50k) 覆盖区1(40k) 压缩至了110k的内存空间使用</p>
<p>缺点 :</p>
<ul>
<li>由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度;</li>
<li>覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省.</li>
</ul>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中</p>
<p>目的 : 多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源</p>
<p>原理 :</p>
<p>可将暂时不能运行的程序送到外存, 从而获得空闲内存空间. 操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间.</p>
<p>存在问题 :</p>
<ul>
<li>交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出;</li>
<li>交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取</li>
<li>程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法</li>
</ul>
<h2 id="覆盖技术和交换技术的对比"><a href="#覆盖技术和交换技术的对比" class="headerlink" title="覆盖技术和交换技术的对比"></a>覆盖技术和交换技术的对比</h2><p>特点 :</p>
<ul>
<li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构.</li>
<li>交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构.</li>
<li>换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部.</li>
</ul>
<p>在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 :</p>
<ul>
<li>覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担.</li>
<li>交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销.</li>
</ul>
<h2 id="虚拟内存管理技术"><a href="#虚拟内存管理技术" class="headerlink" title="虚拟内存管理技术"></a>虚拟内存管理技术</h2><p>如果想要在有限容量的内存中, 以更小的页粒度为单位装入更多更大的程序, 可以采用自动的虚拟存储技术</p>
<ul>
<li><p>目标</p>
<p>像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉.</p>
<p>像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换.</p>
</li>
<li><p>程序局部性原理</p>
<p>程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域.</p>
<ul>
<li>时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内 ;</li>
<li>空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内.</li>
</ul>
<p>程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果.</p>
<p>实例 :</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目描述 :</span><br><span class="line">页面大小为<span class="number">4</span>k, 分配给每个进程的物理页面是<span class="number">1.</span> </span><br><span class="line">在一个进程中, 定义了如下的二维数组 <span class="keyword">int</span> A[<span class="number">1024</span>][<span class="number">1024</span>]. 该数组按行存放在内存, 每一行放在一个页面中.</span><br><span class="line">考虑一下程序的编写方法对缺页率的影响?</span><br><span class="line"></span><br><span class="line">程序编写方法<span class="number">1</span> : (发生了<span class="number">1024</span>*<span class="number">1024</span>次缺页中断)</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">				A[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">程序编写方法<span class="number">2</span> : (发生了<span class="number">1024</span>次缺页中断)</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)</span><br><span class="line">				A[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本概念</p>
<p>可以在页式或段式内存管理的基础上实现</p>
<ul>
<li>在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行;</li>
<li>在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序;</li>
<li>另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段.</li>
</ul>
</li>
<li><p>基本特征</p>
<ul>
<li>大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如32位的虚拟地址理论上可以访问4GB, 而可能计算机上仅有256M的物理内存, 但硬盘容量大于4GB.</li>
<li>部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的;</li>
<li>不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性.</li>
</ul>
</li>
<li><p>虚拟页式内存管理</p>
<p>页式内存管理</p>
<p>页表 : 完成逻辑页到物理页帧的映射</p>
<p>根据页号去页表中寻找索引, 先查看 resident bit 是否为0, 0表示不存在, 1表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址.</p>
<p>虚拟页式内存管理</p>
<ul>
<li><p>大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能.</p>
</li>
<li><p>基本思路</p>
<ul>
<li>当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行.</li>
<li>在运行的过程中, 如果发现要运行的程序或要访问的数据不再内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行.</li>
</ul>
</li>
<li><p>页表表项</p>
<p>逻辑页号 | 访问位 | 修改位 | 保护位 | 驻留位 | 物理页帧号</p>
<p>驻留位 : 表示该页是在内存中还是在外存.</p>
<p>保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等</p>
<p>修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存</p>
<p>访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法.</p>
</li>
<li><p>缺页中断处理过程 :</p>
<ol>
<li>如果在内存中有空闲的物理页面, 则分配一物理页帧f, 然后转第4步; 否则转到第2步;</li>
<li>采用某种页面置换算法, 选择一个将被替换的物理页帧f, 它所对应的逻辑页为q, 如果该页在内存期间被修改过, 则需要把它写回外存;</li>
<li>对q所对应的页表项修改, 把驻留位置为0;</li>
<li>将需要访问的页p装入到物理页面f当中;</li>
<li>修改p所对应的页表项的内容, 把驻留位置为1, 把物理页帧号置为f;</li>
<li>重新运行被中断是指令.</li>
</ol>
<blockquote>
<p>  在何处保存未被映射的页?</p>
<ul>
<li>能够简单地识别在二级存储器中的页</li>
<li>交换空间(磁盘或者文件) : 特殊格式, 用于存储未被映射的页面</li>
</ul>
</blockquote>
<p>后备存储(二级存储) :</p>
<ul>
<li>一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)的某个位置</li>
<li>代码段 : 映射到可执行二进制文件</li>
<li>动态加载的共享库程序段 : 映射到动态调用的库文件</li>
<li>其他段 : 可能被映射到交换文件(swap file)</li>
</ul>
</li>
<li><p>虚拟内存性能</p>
<p>为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT)</p>
<p>EAT = 访存时间 * 页表命中几率 + page fault处理时间 * page fault几率</p>
<p>实例 :</p>
<p>访存时间 : 10 ns</p>
<p>磁盘访问时间 : 5 ms</p>
<p>参数 p  = page fault 几率</p>
<p>参数 q = dirty page 几率(对页面写操作)</p>
<p>EAT = 10*(1-p) + 5000000*p*(1+q)</p>
</li>
</ul>
</li>
</ul>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><blockquote>
<p>  第六章的主要内容是：操作系统的虚拟内存管理技术中的页面置换算法</p>
</blockquote>
<h2 id="功能与目标"><a href="#功能与目标" class="headerlink" title="功能与目标"></a>功能与目标</h2><p>功能 : 当缺页中断发生, 需要调入新的页面而内存已满时, 选择内存当中哪个物理页面被置换.</p>
<p>目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数). 具体来说, 把未来不再使用的或短期内较少使用的页面换出, 通常只能在局部性原理指导下依据过去的统计数据来进行预测.</p>
<p>页面锁定 : 用于描述必须常驻内存的操作系统的关键部分或时间关键的应用进程. 实现的方式是 : 在页表中添加锁定标记位(lock bit).</p>
<h2 id="实验设置与评价方法"><a href="#实验设置与评价方法" class="headerlink" title="实验设置与评价方法"></a>实验设置与评价方法</h2><p>实例 :</p>
<p>记录一个进程对页访问的一个轨迹</p>
<ul>
<li>举例 : 虚拟地址跟踪(页号, 偏移)…<ul>
<li>(3,0) (1,9) (4,1) (2,1) (5,3) (2,0) …</li>
</ul>
</li>
<li>生成的页面轨迹<ul>
<li>3, 1, 4, 2, 5, 2, 1, …</li>
</ul>
</li>
</ul>
<p>模拟一个页面置换的行为并且记录产生页缺失数的数量</p>
<ul>
<li>更少的缺失, 更好的性能</li>
</ul>
<h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>基本思路 : 当一个缺页中断发生时, 对于保存在内存当中的每一个逻辑页面, 计算在它的下一次访问之前, 还需等待多长时间, 从中选择等待时间最长的那个, 作为被置换的页面.</p>
<p>这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.</p>
<p>可用作其他算法的性能评价的依据.(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况, 在第二遍运行时即可使用最优算法)</p>
<h3 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h3><p>基本思路 : 选择在内存中驻留时间最长的页面淘汰. 具体来说, 系统维护着一个链表, 记录了所有位于内存当中的逻辑页面. 从链表的排列顺序来看, 链首页面的驻留时间最长, 链尾页面的驻留时间最短. 当发生一个缺页中断时, 把链首页面淘汰出去, 并把新的页面添加到链表的末尾.</p>
<p>性能较差, 调出的页面有可能是经常要访问的页面. 并且有 belady现象. FIFO算法很少单独使用.</p>
<h3 id="最近最久未使用算法"><a href="#最近最久未使用算法" class="headerlink" title="最近最久未使用算法"></a>最近最久未使用算法</h3><p>LRU(Least Recently Used)</p>
<p>基本思路 : 当一个缺页中断发生时, 选择最久未使用的那个页面, 并淘汰.</p>
<p>它是对最优页面置换算法的一个近似, 其依据是程序的局部性原理, 即在最近一小段时间(最近几条指令)内, 如果某些页面被频繁地访问, 那么再将来的一小段时间内, 他们还可能会再一次被频繁地访问. 反过来说, 如果过去某些页面长时间未被访问, 那么在将来它们还可能会长时间地得不到访问.</p>
<p>LRU算法需要记录各个页面使用时间的先后顺序, 开销比较大.</p>
<p>两种可能的实现方法是 :</p>
<ul>
<li>系统维护一个页面链表, 最近刚刚使用过的页面作为首节点, 最久未使用的作为尾结点. 再一次访问内存时, 找出相应的页面, 把它从链表中摘下来, 再移动到链表首. 每次缺页中断发生时, 淘汰链表末尾的页面.</li>
<li>设置一个活动页面栈, 当访问某页时, 将此页号压入栈顶, 然后, 考察栈内是否有与此页面相同的页号, 若有则抽出. 当需要淘汰一个页面时, 总是选择栈底的页面, 它就是最久未使用的.</li>
</ul>
<h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>基本思路 :</p>
<p>需要用到页表项的访问位, 当一个页面被装入内存时, 把该位初始化为0. 然后如果这个页面被访问, 则把该位置设为1;</p>
<p>把各个页面组织成环形链表(类似钟表面), 把指针指向最老的页面(最先进来);</p>
<p>当发生一个缺页中断时, 考察指针所指向的最老页面, 若它的访问位为0, 立即淘汰; 若访问位为0, 然后指针往下移动一格. 如此下去, 直到找到被淘汰的页面, 然后把指针移动到下一格.</p>
<p>流程 :</p>
<p>如果访问页在物理内存中, 访问位置1.</p>
<p>如果不在物理页, 从指针当前指向的物理页开始, 如果访问位0, 替换当前页, 指针指向下一个物理页; 如果访问位为1, 置零以后访问下一个物理页再进行判断. 如果所有物理页的访问位都被清零了, 又回到了第一次指针所指向的物理页进行替换.</p>
<h3 id="二次机会算法"><a href="#二次机会算法" class="headerlink" title="二次机会算法"></a>二次机会算法</h3><p>因为考虑到时钟页面置换算法, 有时候会把一些 dirty bit 为1(有过写操作)的页面进行置换, 这样的话, 代价会比较大. 因此, 可以结合访问位和脏位一起来决定应该置换哪一页.</p>
<p>used   dirty     →  used   dirty</p>
<p> 0         0                  replace</p>
<p> 0         1                  0         0</p>
<p> 1          0                 0         0 </p>
<p> 1          1                 0         1 </p>
<p>相当于说, 替换的优先级, 没有读写也没写过, 那么直接走, 如果写过或者访问过, 那么给你一次机会, 如果又写过, 又访问过, 那么久给你两次机会.</p>
<h3 id="最不常用算法"><a href="#最不常用算法" class="headerlink" title="最不常用算法"></a>最不常用算法</h3><p>Least Frequently used, LFU</p>
<p>基本思路 : 当一个缺页中断发生时, 选择访问次数最少的那个页面, 并淘汰.</p>
<p>实现方法 : 对每一个页面设置一个访问计数器, 每当一个页面被访问时, 该页面的访问计数器加1. 当发生缺页中断时, 淘汰计数值最小的那个页面.</p>
<p>LRU和LFU的对比 : LRU考察的是多久未访问, 时间越短越好. 而LFU考察的是访问的次数和频度, 访问次数越多越好.</p>
<h3 id="Belady现象-科学家名字"><a href="#Belady现象-科学家名字" class="headerlink" title="Belady现象(科学家名字)"></a>Belady现象(科学家名字)</h3><p>在采用FIFO算法时, 有时会出现分配的物理页面数增加, 缺页率反而提高的异常现象;</p>
<p>出现原因 : FIFO算法的置换特征与进程访问内存的动态特征是矛盾的, 与置换算法的目标是不一致的(即替换较少使用的页面), 因此, 被他置换出去的页面不一定是进程不会访问的.</p>
<h3 id="LRU-FIFO-和-Clock-的比较"><a href="#LRU-FIFO-和-Clock-的比较" class="headerlink" title="LRU / FIFO 和 Clock 的比较"></a>LRU / FIFO 和 Clock 的比较</h3><p>LRU和FIFO都是先进先出的思路, 只不过LRU是针对页面最近访问时间来进行排序, 所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了). 而FIFO是针对页面进入内存的时间来进行排序, 这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的. 如果一个页面在进入内存后没有被访问, 那么它的最近访问时间就是它进入内存的时间. 换句话说, 如果内存当中的所有页面都未曾访问过, 那么LRU算法就退化为了FIFO算法.</p>
<p>例如 : 给进程分配3个物理页面, 逻辑页面的访问顺序是 : 1,2,3,4,5,6,1,2,3 …</p>
<h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h2><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>前面介绍的各种页面置换算法, 都是基于一个前提, 即程序的局部性原理. 但是此原理是否成立?</p>
<ul>
<li>如果局部性原理不成立, 那么各种页面置换算法就没有说明分别, 也没有什么意义. 例如 : 假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,6,7,8,9…, 即单调递增, 那么在物理页面数有限的前提下, 不管采用何种置换算法, 每次的页面访问都必然导致缺页中断.</li>
<li>如果局部性原理是成立的, 那么如何来证明它的存在, 如何来对它进行定量地分析? 这就是工作集模型.</li>
</ul>
<h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>工作集 : 一个进程当前正在使用的逻辑页面集合.</p>
<p>可以使用一个二元函数 W(t, delta) 来表示 :</p>
<p>t 是当前的执行时刻;</p>
<p>delta 称为工作集窗口, 即一个定长的页面访问的时间窗口;</p>
<p>W(t, delta) = 在当前时刻 t 之前的 delta 时间窗口当中的所有页面所组成的集合(随着 t 的变化, 该集合也在不断的变化)</p>
<p>|W(t, delta)| 是工作集的大小, 即逻辑页的数量.</p>
<p>工作集大小的变化 : 进程开始执行后, 随着访问新页面逐步建立较稳定的工作集. 当内存访问的局部性区域的位置大致稳定时, 工作集大小也大致稳定; 局部性区域的位置改变时, 工作集快速扩张和收缩过渡到下一个稳定值.</p>
<h3 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h3><p>常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合.</p>
<ul>
<li>工作集是进程在运行过程中固有的性质, 而常驻集取决于系统分配给进程的物理页面数目, 以及所采用的页面置换算法;</li>
<li>如果一个进程的整个工作集都在内存当中, 即常驻集 包含 工作集, 那么进程将很顺利地运行, 而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态);</li>
<li>当进程常驻集的大小达到某个数目之后, 再给它分配更多的物理页面, 缺页率也不会明显下降.</li>
</ul>
<h3 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h3><p>当工作集窗口在滑动过程中, 如果页面不在集合中, 那么就会直接丢失这个不在窗口中页面, 而不会等待缺页中断再丢弃.</p>
<h3 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h3><p>可变分配策略 : 常驻集大小可变. 例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小.</p>
<ul>
<li>可采用全局页面置换的方式, 当发生一个缺页中断时, 被置换的页面可以是在其他进程当中, 各个并发进程竞争地使用物理页面.</li>
<li>优缺点 : 性能较好, 但增加了系统开销.</li>
<li>具体实现 : 可以使用缺页率算法来动态调整常驻集的大小.</li>
</ul>
<p>缺页率 : 表示 “缺页次数 / 内存访问次数”</p>
<p>影响因素 : 页面置换算法, 分配给进程的物理页面数目, 页面本身的大小, 程序的编写方法.</p>
<h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><ul>
<li>如果分配给一个进程的物理页面太少, 不能包含整个的工作集, 即常驻集 属于 工作集, 那么进程将会造成很多的缺页中断, 需要频繁的在内存与外存之间替换页面, 从而使进程的运行速度变得很慢, 我们把这种状态称为 “抖动”.</li>
<li>产生抖动的原因 : 随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以OS要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡.</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/08/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/" title="深入理解操作系统学习笔记" target="_blank" rel="external">https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/08/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/OXygenPanda.github.io/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">劳振煜</span><small class="ml-1x">致力于技术开发</small></a></h3>
        <div>哈尔滨工程大学2022届计算机技术</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/OXygenPanda.github.io/2020/11/12/C++11/smart_ptr/" title="shared_ptr的简单实现"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/OXygenPanda.github.io/2020/11/03/C++11/C++11/" title="C++11新语法新特性使用剖析"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/OXygenPanda.github.io/images/donate/alipay.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/OXygenPanda.github.io/images/donate/wechat.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
    
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/OXygenPanda" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/OXygenPanda.github.io/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
        
        
        <div class="publishby">
            <span id="busuanzi_container_site_pv">
                点击<span id="busuanzi_value_site_pv" style="font-family:Courier"></span>次，
                访客<span id="busuanzi_value_site_uv" style="font-family:Courier"></span>人,
		<span id="sitetime"></span>
            </span>
        </div>

        <!--
        <div class="publishby">
            Theme by
            <a href="https://github.com/cofess" target="_blank"> cofess </a>
            base on
            <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
        -->
    </div>
</footer>


<script>function siteTime(){
    window.setTimeout("siteTime()", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
       year - 作为date对象的年份，为4位年份值
       month - 0-11之间的整数，做为date对象的月份
       day - 1-31之间的整数，做为date对象的天数
       hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
       minutes - 0-59之间的整数，做为date对象的分钟数
       seconds - 0-59之间的整数，做为date对象的秒数
       microseconds - 0-999之间的整数，做为date对象的毫秒数
    */
    var t1 = Date.UTC(2020,05,19,21,20,52); //t1为建站时间
    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = t2-t1;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
    document.getElementById("sitetime").innerHTML="已运行"+/*diffYears+" 年 "+*/diffDays+"天"+diffHours+"小时"+diffMinutes+"分钟"+diffSeconds+"秒";
    // 因为建站时间还没有一年，就将之注释掉了。需要的可以取消
    }
    siteTime();
</script>


  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/OXygenPanda.github.io/js/plugin.min.js"></script>


<script src="/OXygenPanda.github.io/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/OXygenPanda.github.io/',
        CONTENT_URL: '/OXygenPanda.github.io/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/OXygenPanda.github.io/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   






</body>
</html>