<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>劳振煜的知識倉儲</title>
  
  <subtitle>Study &amp; Share</subtitle>
  <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/atom.xml" rel="self"/>
  
  <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/"/>
  <updated>2021-03-07T03:01:25.940Z</updated>
  <id>https://oxygenpanda.github.io/OXygenPanda.github.io/</id>
  
  <author>
    <name>劳振煜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法之美</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/02/10/HugeFour/DataStructrues/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BE%8E/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BE%8E/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/02/10/HugeFour/DataStructrues/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BE%8E/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BE%8E/</id>
    <published>2021-02-10T07:10:00.000Z</published>
    <updated>2021-03-07T03:01:25.940Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录了数据结构与算法之美的学习笔记, 记录了一些自己觉得比较重要的点.</p><a id="more"></a><h1 id="05-数组"><a href="#05-数组" class="headerlink" title="05 | 数组"></a>05 | 数组</h1><h2 id="主题-为什么很多编程语言中数组都是从0开始编号"><a href="#主题-为什么很多编程语言中数组都是从0开始编号" class="headerlink" title="主题 : 为什么很多编程语言中数组都是从0开始编号?"></a>主题 : 为什么很多编程语言中数组都是从0开始编号?</h2><hr><p>数组是一种线性表数据结构, 用一组连续的内存空间, 来存储一组具有相同类型的数据.</p><pre><code class="hljs cpp">a[i]_address = base_address + i * data_type_size</code></pre><p>数组的连续存储, 相较于链表的非连续存储的优点 : 支持随机访问, 随机访问时间复杂度为 O(1), 有序情况下, 查找的时间复杂度为 O(logN); 插入删除的时间复杂度为 O(N)</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>在数组不有序, 且对排序无所谓的情况下, 在某个位置插入元素, 可以将该位置的元素赋值到数组末尾, 再将元素赋值到该位.</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除元素时, 可以用数组来记录删除的索引值, 当数组空间不够用时, 触发删除操作.</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>STL中的 vector 已经很好地把数组的一些存在的问题解决了, 细节给隐藏起来了, 并且支持扩容, 但是需要注意的是, 如果提前知道元素个数, 应当初始化长度.</p><hr><h1 id="06-07-链表"><a href="#06-07-链表" class="headerlink" title="06 07 | 链表"></a>06 07 | 链表</h1><h2 id="主题-如何实现LRU缓存淘汰算法"><a href="#主题-如何实现LRU缓存淘汰算法" class="headerlink" title="主题 : 如何实现LRU缓存淘汰算法?"></a>主题 : 如何实现LRU缓存淘汰算法?</h2><hr><p>缓存大小有限, 当缓存被用满时, 哪些数据应该被清理出去, 哪些数据应当被保留? 有以下三种淘汰策略 :</p><ul><li>先进先出策略 FIFO</li><li>最少使用策略 LFU</li><li>最近最少使用策略 LRU</li></ul><p>解决办法 :</p><ol><li>维护一个有序的单链表</li><li>遍历链表来查询访问的数据</li><li>如果此数据在链表中存在, 将原来的位置删除, 把数据插入在链表头</li><li>如果此数据在链表中不存在, 如果缓存未满, 把数据插入在链表头; 如果缓存已满, 把链表尾部节点删除, 把数据插入在链表头</li><li>此时, 缓存访问的时间是 O(N)</li><li>引入 hashtable 记录每一个数据在链表中的位置, 可以将缓存访问的时间降低到  O(1)</li></ol><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表分为 : 单链表, 双向链表, 循环链表.</p><p>链表是非连续存储的线性表, 插入和删除的时间复杂度为 O(1), 不支持随机访问, 查找的时间复杂度为 O(N)</p><hr><h2 id="主题-如何轻松写出正确的链表代码"><a href="#主题-如何轻松写出正确的链表代码" class="headerlink" title="主题 : 如何轻松写出正确的链表代码?"></a>主题 : 如何轻松写出正确的链表代码?</h2><p>技巧一 : 理解指针或者引用的含义</p><p>技巧二 : 警惕指针丢失和内存泄漏</p><p>技巧三 : 利用哨兵简化实现难度</p><p>技巧四 : 留意边界条件处理</p><p>可能存在的边界条件 :</p><ol><li>链表为空;</li><li>只包含一个节点;</li><li>只包含两个节点;</li><li>处理头结点和尾结点.</li></ol><p>技巧五 : 举例画图</p><p>技巧六 : 多写多练</p><hr><h1 id="08-栈"><a href="#08-栈" class="headerlink" title="08 | 栈"></a>08 | 栈</h1><h2 id="主题-如何实现浏览器的前进和后退功能"><a href="#主题-如何实现浏览器的前进和后退功能" class="headerlink" title="主题 : 如何实现浏览器的前进和后退功能"></a>主题 : 如何实现浏览器的前进和后退功能</h2><hr><p>点完页面 a-b-c 之后, 点击浏览器的后退按钮, 可以看到页面 a 和页面 b.</p><p>后退到 a 后, 前进可以到达 b 和 c.</p><p>但是如果点击了 d, 就再也看不到 c 了.</p><hr><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种操作受限的线性表, 只允许在一端插入和删除数据.</p><p>栈根据底层实现可以分为 : 顺序栈 和 链式栈.</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>函数调用栈 : 操作系统给每一个线程分配一块独立的内存空间, 栈空间用来存储函数调用时的临时变量. 每进入一个函数, 临时变量作为一个栈帧入栈, 函数执行完, 函数对应的栈帧出栈.</p><p>波兰表达式 : 计算前缀表达式和后缀表达式时, 需要使用栈来存储符号和数字.</p><p>括号匹配</p><p>浏览器前进后退 : 两个栈, 点击页面放入第一个栈中, 点击后退时, 第一个栈的顶放入第二个栈, 点击前进时, 第二个栈的顶放入第一个栈, 再次点击新页面时, 放入第一个栈, 清空第二个栈.</p><hr><h1 id="09-队列"><a href="#09-队列" class="headerlink" title="09 | 队列"></a>09 | 队列</h1><h2 id="主题-队列在线程池等有限资源池中的应用"><a href="#主题-队列在线程池等有限资源池中的应用" class="headerlink" title="主题 : 队列在线程池等有限资源池中的应用"></a>主题 : 队列在线程池等有限资源池中的应用</h2><hr><p>CPU资源是有限的, 任务的处理速度与线程个数并不是线性正相关.</p><p>过多的线程反而会导致 CPU 频繁切换, 处理性能下降.</p><blockquote><p>  当我们向固定大小的线程池请求一个线程时, 如果没有空闲资源时, 应该是拒绝服务还是排队请求呢?</p></blockquote><p>解决方式 :</p><ol><li>采用非阻塞的方式, 遇到没有线程的情况, 直接拒绝服务;</li><li>采用阻塞的方式, 遇到没有线程的情况, 就进行排队, 但是应该选择顺序队列还是链式队列呢? :<ol><li>链式队列 : 无限排队, 可能会导致过多的请求排队等待, 会导致响应时间过长. 所以不合适.</li><li>顺序队列 : 请求排队数量受限, 对于响应时间敏感的系统来说, 较为合适.</li></ol></li></ol><hr><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列同样也是一种操作受限的数据结构, 固定端输入和另一端输出</p><p>队列根据底层数据结构, 可以分为 顺序队列 和 链式队列.</p><p>队列输出可以在入队的时候集中搬移.</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>阻塞队列 : 在普通队列的基础上, 增加阻塞的功能, 在队列空的时候, 取操作会被阻塞; 在队列满的时候, 放操作会被阻塞.      ← 生产者 - 消费者模型</p><p>并发队列 : 线程安全的队列叫并发队列, 在 push() 和 pop() 上加锁, 但是锁粒度大并发度就会低, 同一时刻允许一个存或者取操作, 基于数组的循环队列, 利用CAS原子操作, 可以实现高效的并发队列.</p><p>分布式系统中的消息队列</p><hr><h1 id="10-递归"><a href="#10-递归" class="headerlink" title="10 | 递归"></a>10 | 递归</h1><h2 id="主题-如何用三行代码找到-“最终推荐人”"><a href="#主题-如何用三行代码找到-“最终推荐人”" class="headerlink" title="主题 : 如何用三行代码找到 “最终推荐人”"></a>主题 : 如何用三行代码找到 “最终推荐人”</h2><p>用户 A 推荐用户 B 注册, 用户 B 推荐用户 C 注册.</p><p>用户 C 的最终推荐人是用户 A.</p><hr><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>一种应用广泛的编程技巧.</p><p>递归三个条件 :</p><ol><li>一个问题的解可以分解为几个子问题的解;</li><li>子问题和原问题的求解思路相同;</li><li>存在递归终止条件.</li></ol><h3 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h3><p>调用一个函数时, 将临时变量作为栈帧压入到内存栈中, 等函数执行完成返回时, 出栈.</p><p>一般, 系统栈或者虚拟机栈的空间都不大.</p><p>如果递归求解的规模巨大, 调用层次更深, 会有堆栈溢出的风险.</p><h3 id="递归调试"><a href="#递归调试" class="headerlink" title="递归调试"></a>递归调试</h3><ol><li>打印日志发现, 递归值.</li><li>结合条件断点进行调试.</li></ol><hr><h1 id="11-14-排序"><a href="#11-14-排序" class="headerlink" title="11 - 14 | 排序"></a>11 - 14 | 排序</h1><h2 id="主题-为什么插入排序比冒泡排序更受欢迎"><a href="#主题-为什么插入排序比冒泡排序更受欢迎" class="headerlink" title="主题 : 为什么插入排序比冒泡排序更受欢迎?"></a>主题 : 为什么插入排序比冒泡排序更受欢迎?</h2><hr><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>常见的排序 : 冒泡, 插入, 选择, 归并, 快速, 堆, 计数, 基数, 桶排序.</p><p>其他的排序 : 猴子排序, 睡眠排序, 面条排序.</p><p>按照时间复杂度来划分 :</p><ul><li>O(N^2) : 冒泡排序, 选择排序, 插入排序</li><li>O(NlogN) : 快速排序, 归并排序, 堆排序</li><li>O(N) : 桶排序, 计数排序, 基数排序</li></ul><p>原地排序 : 空间复杂度为O(1)的排序算法</p><p>稳定性 : 数值相等的元素, 排序后相对位置不变</p><h3 id="冒泡排序-选择排序-插入排序"><a href="#冒泡排序-选择排序-插入排序" class="headerlink" title="冒泡排序 | 选择排序 | 插入排序"></a>冒泡排序 | 选择排序 | 插入排序</h3><p>这三种排序都是原地排序.</p><p>冒泡排序 : 原地排序, 稳定, O(N^2)</p><p>插入排序 : 原地排序, 稳定, O(N^2)</p><p>选择排序 : 原地排序, 非稳定, O(N^2)</p><h3 id="归并排序-快速排序"><a href="#归并排序-快速排序" class="headerlink" title="归并排序 | 快速排序"></a>归并排序 | 快速排序</h3><p>适合大规模的数据排序.</p><p>归并排序 : 分治思想, 递归实现. 非原地排序, 稳定, O(NlogN), 空间O(N)</p><p>快速排序 : 分治思想, 递归实现. 原地排序, 不稳定, O(NlogN)</p><h3 id="桶排序-计数排序-基数排序"><a href="#桶排序-计数排序-基数排序" class="headerlink" title="桶排序 | 计数排序 | 基数排序"></a>桶排序 | 计数排序 | 基数排序</h3><p>这三个排序, 都是非原地排序.</p><p>桶排序 : N 个数, M 个桶, 时间复杂度为 O(N * log(N / M)) 当 M ≈ N 时, 时间复杂度接近于 O(N).</p><p>计数排序 : 数据范围内所有数据都准备一个桶, 特殊的桶排序</p><p>基数排序 : 时间复杂度为 O(k * N)</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>快速排序</p><ul><li>三数取中法 : 首, 尾, 中三个元素, 取中间大小的元素作为分区点.</li><li>随机法 : 随机选取元素作为分区点.</li><li>避免堆栈溢出 : 1. 限制递归深度, 超出阈值就停止递归; 2. 在堆上模拟实现一个函数调用栈, 手动模拟压栈和出栈的过程, 没有了系统栈大小的限制.</li></ul><hr><h1 id="15-16-二分查找"><a href="#15-16-二分查找" class="headerlink" title="15 16 | 二分查找"></a>15 16 | 二分查找</h1><h2 id="主题-快速查找"><a href="#主题-快速查找" class="headerlink" title="主题 : 快速查找"></a>主题 : 快速查找</h2><hr><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>时间复杂度 : O(logN)</p><p>对数时间复杂度有时候要比常数时间复杂度还要高效, 42亿数据的二分需要32次, 而O(1)有时候代表的是O(1000)</p><p>二分代码结构 :</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(left &lt;= right)&#123;<span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(nums[mid] &gt; target)right = mid - <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)left = mid + <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> mid;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</code></pre><h3 id="二分查找的适用场合"><a href="#二分查找的适用场合" class="headerlink" title="二分查找的适用场合 :"></a>二分查找的适用场合 :</h3><ol><li>顺序结构, 数组</li><li>有序数据</li><li>数据量不能太小, 比如10个, 是否使用影响不大</li><li>数据量不能太大, 1GB的数据, 需要内存连续, 要求有点高</li></ol><h3 id="四种常见的二分查找变形问题"><a href="#四种常见的二分查找变形问题" class="headerlink" title="四种常见的二分查找变形问题 :"></a>四种常见的二分查找变形问题 :</h3><ol><li>查找第一个值等于给定值的元素</li><li>查找最后一个值等于给定值的元素</li><li>查找第一个大于等于给定值的元素</li><li>查找最后一个小于等于给定值的元素</li></ol><p><strong>第一个问题和第二个问题 :</strong></p><p>采用这样的方式, 就可以轻松判断而且很好理解</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>)</span></span>;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;            <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(nums[mid] &gt; target)  right = mid - <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(mid == <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] != target) &#123;                    res[<span class="hljs-number">0</span>] = mid;                    <span class="hljs-keyword">break</span>;                &#125;                right = mid - <span class="hljs-number">1</span>;            &#125;        &#125;        left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;            <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(nums[mid] &gt; target)  right = mid - <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(mid == nums.size() - <span class="hljs-number">1</span> || nums[mid+<span class="hljs-number">1</span>] != target) &#123;                    res[<span class="hljs-number">1</span>] = mid;                    <span class="hljs-keyword">break</span>;                &#125;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><p><strong>第三个问题</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;            <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(nums[mid] &gt;= target)&#123;                <span class="hljs-keyword">if</span>(mid == <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] &lt; target)  <span class="hljs-keyword">return</span> mid;                <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span>                left = mid + <span class="hljs-number">1</span>;        &#125;</code></pre><p><strong>第四个问题类似于第三个问题</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;            <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;                right = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(mid == nums.size() - <span class="hljs-number">1</span> || nums[mid + <span class="hljs-number">1</span>] &gt; target)    <span class="hljs-keyword">return</span> mid;                <span class="hljs-keyword">else</span>    left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;</code></pre><hr><h1 id="17-跳表"><a href="#17-跳表" class="headerlink" title="17 | 跳表"></a>17 | 跳表</h1><h2 id="主题-为什么-Redis-一定要用跳表来实现有序集合"><a href="#主题-为什么-Redis-一定要用跳表来实现有序集合" class="headerlink" title="主题 : 为什么 Redis 一定要用跳表来实现有序集合?"></a>主题 : 为什么 Redis 一定要用跳表来实现有序集合?</h2><p>Redis核心操作 :</p><ul><li>插入一个数据</li><li>删除一个数据</li><li>查找一个数据</li><li>按照区间查找数据</li><li>迭代输出有序序列</li></ul><p>红黑树的话, 第四个操作效率不高, 而且跳表的代码实现相较于红黑树来说简单, 不容易出错, 更为灵活, 能够改变索引构建策略, 有效地平衡执行效率和内存消耗.</p><hr><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>前文提到, 二分查找只适用于数组, 而不适用于链表, 但是对链表稍加改造就可以使它适用于二分查找.</p><p>改进后的数据结构就是跳表.</p><p>链表上增加多级索引, 能够快速定位到某个节点.</p><p>查询的时间复杂度 O(logN)</p><p>以空间换取时间, 实现在链表上的快速查找, 空间复杂度 O(N)</p><p>插入和删除时间复杂度 O(logN)</p><p>但是, 插入删除操作过多的话, 会导致两个索引之间存在大量节点, 会退化成单链表, 因此也需要动态更新.</p><p>类似于, 红黑树, AVL有调整规则, 跳表的调整策略是 : 随机函数.</p><p>随机函数计算某个值, 那么把 key 加入到 第一层至第k层索引层上.</p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;Website&quot; src=&quot;https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&amp;logo=Blogger&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://www.github.com/OXygenPanda&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&amp;logo=GitHub&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&amp;logo=WeChat&quot;&gt;&lt;/a&gt;



&lt;/p&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文记录了数据结构与算法之美的学习笔记, 记录了一些自己觉得比较重要的点.&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>OS | 进程间通信 IPC</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/02/02/HugeFour/OperatingSystem/OS_NOTE/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/02/02/HugeFour/OperatingSystem/OS_NOTE/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2021-02-02T07:10:00.000Z</published>
    <updated>2021-03-08T13:01:12.458Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a></p><p>进程可能需要频繁和其他进程交流. 比如, shell 管道, 第一个进程的输出必须传递给第二个进程.</p><p>接下来, 就讨论有关 进程间通信(Inter Process communication, IPC).</p><p>进程通信存在三个问题 :</p><ol><li>一个进程如何传递消息给其他进程.</li><li>如何确保两个或多个线程之间不会相互干扰.</li><li>数据的先后顺序问题.</li></ol><p>第一个问题, 在线程中不是问题, 线程共享同一内存空间, 可以很容易地进行通信;</p><p>第二个和第三个问题, 同样适用于线程.</p><h2 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h2><p>两个或多个线程同时对一共享数据进行修改, 从而影响到了程序运行的正确性, 这种被称为竞态条件.</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>禁止一个或多个进程在同一个时刻对共享资源(共享内存, 共享文件等)进行读写.</p><p>也就是一个互斥条件.</p><blockquote><p>  在任何操作系统中, 为了实现互斥操作而选用适当的原语是一个主要的设计问题.</p></blockquote><p>一个好的解决方案, 应当包含四个条件 :</p><ol><li>任何时候, 两个进程不能同时处于临界区</li><li>不应当对CPU的速度和数量做任何假设</li><li>位于临界区外的进程不得阻塞其他进程</li><li>不能使任何进程无限等待进入临界区</li></ol><h2 id="忙等互斥"><a href="#忙等互斥" class="headerlink" title="忙等互斥"></a>忙等互斥</h2><p>介绍互斥的各种设计.</p><h3 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h3><p>单处理器, 屏蔽中断, 能够屏蔽CPU的时钟中断, 进而阻止进程的切换, 但是如何进程运行时间过长, 可能会导致系统崩溃.</p><p>多处理器, 屏蔽中断, 仅一块CPU会受限, 其他CPU仍然能够访问共享内存.</p><p>屏蔽中断是一项很有用的技术, 但是不是一项通用的互斥机制.</p><h3 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h3><p>软件层面的解决方案, 锁变量初始化为0, 当一个线程想进入功关键区域, 查看锁的值, 如果是0, 设置为1, 进程进入, 出来后, 恢复为0; 如果是1, 阻塞.</p><p>有可能, 一个线程发现是0, 想设置为1, 而另一个线程也发现是0时, 会出现多个线程访问关键区域.</p><p>根本原因, 修改锁变量, 不是一种原子性操作, 仍然可能发生竞态.</p><h3 id="严格轮询法"><a href="#严格轮询法" class="headerlink" title="严格轮询法"></a>严格轮询法</h3><p>先查看一段代码 :</p><p>进程 0</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(TRUE)&#123;<span class="hljs-keyword">while</span>(turn != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//进入关键区域</span>critical_region();turn = <span class="hljs-number">1</span>;<span class="hljs-comment">//离开关键区域</span>noncritical_region();&#125;&#125;</code></pre><p>进程 1</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(TRUE)&#123;<span class="hljs-keyword">while</span>(turn != <span class="hljs-number">1</span>)&#123;critical_region();turn = <span class="hljs-number">0</span>;noncritical_region();&#125;&#125;</code></pre><p>多个进程, 必须得频繁使用临界区资源, 否则容易长时间阻塞其他进程. while 体现了忙等待, 除非是认为等待时间很短, 否则不使用忙等待.</p><p>用于忙等待的锁, 称为 自旋锁.</p><h3 id="Peterson-解法"><a href="#Peterson-解法" class="headerlink" title="Peterson 解法"></a>Peterson 解法</h3><p>荷兰数学家 T.Dekker 结合锁变量和警告变量, 提出不需要严格轮换的软件互斥算法.</p><p>后来, G.L.Peterson 发现了一种简单的互斥算法 :</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span><span class="hljs-comment">/* 进程数量 */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 2</span><span class="hljs-comment">/* 现在轮到谁 */</span><span class="hljs-keyword">int</span> turn;<span class="hljs-comment">/* 所有值初始化为 0 */</span><span class="hljs-keyword">int</span> interested[N];<span class="hljs-comment">/* 进程是 0 或 1 */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enter_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> process)</span></span>&#123;<span class="hljs-comment">// 另一个进程号</span><span class="hljs-keyword">int</span> other;<span class="hljs-comment">// 另一个进程</span>other = <span class="hljs-number">1</span> - process;<span class="hljs-comment">//表示愿意进入临界区</span>interested[process] = TRUE;turn = process;<span class="hljs-comment">//空循环</span><span class="hljs-keyword">while</span>(turn == process &amp;&amp; interested[other] == <span class="hljs-literal">true</span>)&#123;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">leave_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> process)</span></span>&#123;<span class="hljs-comment">//表示愿意离开临界区</span>interested[process] = FALSE;</code></pre><h3 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h3><p>需要硬件帮助的方案.</p><p>多处理器的计算机, 会有这条指令 : TSL RX,LOCK</p><p>称为测试并加锁.</p><p>实现了原子操作, 锁住内存总线, 防止其他CPU访问内存.</p><h2 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h2><p>Peterson, TSL 和 XCHG 都是正确的, 但是都有忙等待的缺点.</p><p>解法本质上一样, 检查能否进入临界区, 不允许则原地等待.</p><p>进程间原语</p><p><code>sleep</code> : 调用者阻塞, 直到被其他进程唤醒.</p><p><code>wakeup</code> : 唤醒其他进程.</p><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>又称为, 有界缓冲区问题 : 两个进程共享一个公共的固定大小的缓冲区. 一个是生产者, 将信息放入缓冲区, 另一个是消费者, 会从缓冲区取出.</p><p>描述 : 生产者可以将数据写入缓冲区, 当写满时, 生产者睡眠, 阻塞; 消费者可以将读取缓冲区数据, 当为空时, 消费者睡眠, 阻塞.</p><p>使用一个监听变量, Count 来记录缓冲区的数据量.</p><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> N 100</span><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<span class="hljs-keyword">int</span> item;<span class="hljs-keyword">while</span>(TRUE)&#123;item = produce_item();<span class="hljs-keyword">if</span>(count == N)&#123;sleep();&#125;insert_item(item);count = count + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>)&#123;wakeup(consumer);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<span class="hljs-keyword">int</span> item;<span class="hljs-keyword">while</span>(TRUE)&#123;i(count == <span class="hljs-number">0</span>)&#123;sleep();&#125;item = remove_item();count = count - <span class="hljs-number">1</span>;i(count == N - <span class="hljs-number">1</span>)&#123;wakeup(producer);&#125;consumer_item(item);&#125;&#125;</code></pre><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="用信号量解决生产者-消费者问题"><a href="#用信号量解决生产者-消费者问题" class="headerlink" title="用信号量解决生产者-消费者问题"></a>用信号量解决生产者-消费者问题</h3><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><h3 id="Futexes"><a href="#Futexes" class="headerlink" title="Futexes"></a>Futexes</h3><h3 id="Pthreads中的互斥量"><a href="#Pthreads中的互斥量" class="headerlink" title="Pthreads中的互斥量"></a>Pthreads中的互斥量</h3><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><h3 id="用消息传递解决生产者-消费者问题"><a href="#用消息传递解决生产者-消费者问题" class="headerlink" title="用消息传递解决生产者-消费者问题"></a>用消息传递解决生产者-消费者问题</h3><h2 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h2><h2 id="避免锁-读-复制-更新"><a href="#避免锁-读-复制-更新" class="headerlink" title="避免锁 : 读-复制-更新"></a>避免锁 : 读-复制-更新</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;Website&quot; src=&quot;https://img.shields.io/badge/博客-劳振煜的知識倉儲</summary>
      
    
    
    
    <category term="OS" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/OS/"/>
    
    
    <category term="OS" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>OS | 进程和线程</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/30/HugeFour/OperatingSystem/OS_NOTE/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/30/HugeFour/OperatingSystem/OS_NOTE/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-01-30T10:10:00.000Z</published>
    <updated>2021-03-06T13:11:14.172Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a># 进程和线程</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>即使可以使用的CPU只有一个, 也支持并发操作.</p><p>每个程序运行几十或者几百毫秒, 即使每一个瞬间CPU只能运行一个进程, 在一秒内, 也运行了多个进程. 给人并行的错觉. 也就是伪并行.</p><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>所有计算机上运行的软件, 包括系统, 被组织为若干顺序进程 (sequential processes), 简称为进程(process).</p><p>一个进程就是一个正在执行的程序的实例, 包括程序计数器, 寄存器和变量的当前值.</p><p>进程切换的时候, 运行的进程把逻辑程序计数器装载到物理程序计数器中, 程序结束时, 再把物理程序计数器放回逻辑程序计数器.</p><p>进程是某一特定活动的总和, 有程序, 输入输出以及状态.</p><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>以下是创建进程的方式 : </p><ul><li>系统初始化</li><li>正在运行的程序执行了创建进程的系统调用(fork)</li><li>用户请求创建一个新进程</li><li>初始化一个批处理工作</li></ul><h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h3><p>启动操作系统的时候, 通常会创建若干进程.</p><p>前台进程 : 和用户进行交互完成工作的进程.</p><p>守护进程 : 在后台用来处理一些活动, 比如 email, web, 新闻等的进程.</p><p>unix中, 使用 ps 可以列出正在运行的进程, 在windows里使用任务管理器.</p><h3 id="系统调用创建"><a href="#系统调用创建" class="headerlink" title="系统调用创建"></a>系统调用创建</h3><p>一个新的进程可以由其他进程通过系统调用创建, 比如大量数据需要从网络调取并处理, 可以创建一个进程读数据并放到缓冲区, 第二个进程取走并正确处理. </p><p>在多处理器中, 让每个进程运行在不同的CPU上也可以使得工作做的更快.</p><h3 id="用户请求创建"><a href="#用户请求创建" class="headerlink" title="用户请求创建"></a>用户请求创建</h3><p>输入一个命令或者双击图标可以启动程序.</p><h3 id="批处理创建"><a href="#批处理创建" class="headerlink" title="批处理创建"></a>批处理创建</h3><p>在 UNIX 系统中, 只有一个系统调用来创建一个新的进程, <code>fork()</code> , 调用会创建一个与调用进程相关的副本, 父进程和子进程会有相同的内存映像, 相同的环境字符串和相同的打开文件, 通常子进程会执行 <code>execve()</code> 来改变内存映像并运行一个新的程序.</p><ul><li>UNIX 中的一些系统调用</li></ul><p>有一些 UNIX 系统的实现, 父进程和子进程在不可写的内存区域上是共享的, 而可写内存区域通过 写时赋值(copy-on-write) 共享, 一旦两者之一想要修改部分内存, 则该内存首先被明确的赋值, 以确保修改发生在私有的内存区域. </p><h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>进程终止有几种情况 :</p><ol><li>正常退出 (自愿)</li><li>错误退出 (自愿)</li><li>严重错误 (非自愿)</li><li>被其他进程杀死 (非自愿)</li></ol><h3 id="正常退出"><a href="#正常退出" class="headerlink" title="正常退出"></a>正常退出</h3><p>调用 UNIX 中的 <code>exit()</code></p><h3 id="错误退出"><a href="#错误退出" class="headerlink" title="错误退出"></a>错误退出</h3><pre><code class="hljs cpp">cc foo.c</code></pre><p>比如, 想要编译 foo.c 文件, 但是该文件不存在, 就会发生错误退出, 参数不合理.</p><h3 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h3><p>由于程序中的错误导致. 比如, 执行非法指令, 引用不存在的内存, 除数为0等.</p><h3 id="被进程杀死"><a href="#被进程杀死" class="headerlink" title="被进程杀死"></a>被进程杀死</h3><p>调用 UNIX 中的 <code>kill()</code></p><h2 id="进程层次结构"><a href="#进程层次结构" class="headerlink" title="进程层次结构"></a>进程层次结构</h2><p>父进程创建了子进程, 父子进程之间存在一定的关联, 子进程又会创建更多的进程, 从而形成一个进程层次结构.</p><h3 id="UNIX-进程体系"><a href="#UNIX-进程体系" class="headerlink" title="UNIX 进程体系"></a>UNIX 进程体系</h3><p>在 UNIX 中, 进程和它的所有子进程以及子进程的子进程共同组成一个进程组. 当用户从键盘中发出一个信号后, 该信号会被发送给当前与键盘相关的进程组中的所有成员. 每个进程可以分别捕获信号, 忽略信号 或者 采取默认的动作.</p><p>UNIX 在启动时初始化自己, 一个称为 <code>init</code> 的特殊进程是整个操作系统进程树的根.</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><pre><code class="hljs bash">cat chapter1 chapter2 chapter3 | grep tree</code></pre><p>两个进程, cat 进程将三个文件级联, grep 进程等待输入选择具有 tree 关键词的内容.</p><p>当 grep 进程就绪开始运行时, 但是 cat 进程还没有执行, 于是 grep 进程会阻塞, 等待输入完毕.<br>所以, 进程可能会经历以下状态 :</p><p>阻塞 ← 运行 ←→ 就绪</p><p>阻塞 → 就绪</p><p>具体说明 : </p><p>运行 → 阻塞 : 进程因为等待输入而阻塞</p><p>运行 → 就绪 : 调度程序选择了另一个进程, 时间片没有轮到自己</p><p>就绪 → 运行 : 调度程序选择一个进程开始运行, 时间片轮到了自己</p><p>阻塞 → 就绪 : 输入完毕</p><p>状态说明 :</p><ol><li>运行态 : 进程实际占用 CPU 时间片</li><li>就绪态 : 可以运行, 但是其他进程正在运行</li><li>阻塞态 : 除非某种外部事件发生, 否则进程不能运行</li></ol><h2 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h2><p>操作系统维护一张进程表(process table).</p><p>每个进程占用一个表项, 包含进程的重要信息, 包括程序计数器, 堆栈指针, 内存分配状况, 所打开的文件状态, 账号和调度信息, 状态切换的信息. 从而能够保证进程在随后可以再次启动, 就像从未被中断过.</p><p>表项内容 :</p><ul><li><p>进程管理</p><p>  寄存器, 程序计数器, 程序状态字, 堆栈指针, 进程状态, 优先级, 调度参数, 进程ID, 父进程, 进程组, 信号, 进程开始的时间, 使用的CPU时间, 子进程的CPU时间, 下次定时器时间</p></li><li><p>存储管理</p><p>  text segment 指针</p><p>  data segment 指针</p><p>  stack segment 指针</p></li><li><p>文件管理</p><p>  根目录</p><p>  工作目录</p><p>  文件描述符</p><p>  用户ID</p><p>  组ID</p></li></ul><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>传统的操作系统中, 每个进程都有一个地址空间和一个控制线程.</p><p>事实上, 经常存在同一地址空间中运行多个控制线程的情况.</p><h2 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h2><p>为什么要在进程模型上再创建一个线程的概念, 需要分三步回答 : </p><ul><li>多线程之间可以共享一块地址空间和所有可用数据, 这是多进程不具备的       ← 共享</li><li>线程比进程轻量化, 创建容易撤销也容易, 创建线程比进程快 10 - 100 倍        ← 轻量</li><li>如果存在大量的计算和大量的IO处理, 多线程能够加快执行速度                       ←高性能</li></ul><h3 id="多线程解决方案"><a href="#多线程解决方案" class="headerlink" title="多线程解决方案"></a>多线程解决方案</h3><p>调度线程是从网络中读入工作请求, 检查完之后, 选择一个空闲的(阻塞的)工作线程来处理请求, 通常方式是将消息的指针写入到每个线程关联的特殊字中. 调度线程会唤醒正在睡眠的工作线程, 把工作线程的状态从阻塞态变为就绪态.</p><p>这种模型允许服务器编写为顺序线程的集合, 在分派线程的程序中包含一个死循环, 用来获得工作请求并把请求派给工作线程.<br>每个工作线程的代码包含一个从调度线程接收的请求, 并且检查 web 高速缓存中是否存在所需页面, 如果有, 直接把页面返回给客户, 接着工作线程阻塞, 等待一个新请求的到达. 如果没有, 工作线程就从磁盘调入该页面, 将页面返回给客户, 然后工作线程阻塞, 等待新请求.</p><p>下面是调度线程和工作线程的代码, 假设 TRUE 为 1, buf 和 page 分别是保存工作请求和 web 页面的相应结构.</p><p><strong>调度线程的大致逻辑</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(TRUE)&#123;get_next_request(&amp;buf);handoff_work(&amp;buf);&#125;</code></pre><p><strong>工作线程的大致逻辑</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(TRUE)&#123;wait_for_work(&amp;buf);look_for_page_in_cache(&amp;buf, &amp;page);<span class="hljs-keyword">if</span>(page_not_in_cache(&amp;page))&#123;read_page_from_disk(&amp;buf, &amp;page);&#125;<span class="hljs-keyword">return</span> _page(&amp;page);&#125;</code></pre><h3 id="单线程解决方案"><a href="#单线程解决方案" class="headerlink" title="单线程解决方案"></a>单线程解决方案</h3><p>如果只有单线程来处理请求, 那么在等待磁盘操作时, 服务器空转, 不处理任何到来的其他请求. 导致效率极低, 也说明了多线程能够提高程序的并行性和程序的性能.</p><h3 id="状态机解决方案"><a href="#状态机解决方案" class="headerlink" title="状态机解决方案"></a>状态机解决方案</h3><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>单线程 - 无并行性, 性能较差, 阻塞系统调用</p><p>多线程 - 有并行性, 阻塞系统调用</p><p>有限状态机 - 并行性, 非阻塞系统调用, 中断</p><h2 id="经典线程模型"><a href="#经典线程模型" class="headerlink" title="经典线程模型"></a>经典线程模型</h2><p>进程存放程序正文和数据以及其他资源的地址空间, 资源包括 : 打开的文件, 子进程, 即将发生的定时器, 信号处理程序, 账号信息等. 进程管理资源较为方便.</p><p>进程中包含执行的线程 : </p><ul><li>线程会有程序计数器, 用来记录接下来要执行哪一条指令;</li><li>线程会有寄存器, 用来保存当前正在使用的变量;</li><li>线程会有堆栈, 用来记录程序的执行路径.</li></ul><p>多个线程中, 各个线程共享同一地址空间和其他资源.</p><p>由于每个线程可以访问进程地址空间中的每个内存地址, 因此一个线程可以读取, 写入甚至擦除另一个线程的堆栈. 线程之间除了共享同一内存空间外, 还有以下不同的内容 :</p><p><strong>每个进程中的内容(线程共享内容) 进程的属性</strong></p><ul><li>地址空间</li><li>全局变量</li><li>打开文件</li><li>子进程</li><li>即将发生的定时器</li><li>信号和信号处理程序</li><li>账户信息</li></ul><p><strong>每个线程中的内容 线程的属性</strong></p><ul><li>程序计数器</li><li>寄存器</li><li>堆栈</li><li>状态</li></ul><p>线程有以下几种状态 : 运行态, 阻塞态, 就绪态和终止态.</p><h2 id="线程系统调用"><a href="#线程系统调用" class="headerlink" title="线程系统调用"></a>线程系统调用</h2><p>进程通常以单线程开始, 然后这个线程通过调用一个库函数(比如 <code>thread_create</code>)创建新的线程.<br>线程创建的函数会要求指定新创建线程的名称.<br>创建的线程通常都返回一个线程标识符, 该标识符就是新线程的名字.</p><p>使用, <code>thread_exit</code> 来退出线程.</p><p>使用, <code>thread_join</code> 表示一个线程可以等待另一个线程退出.</p><p>使用, <code>thread_yield</code> 允许线程自动放弃CPU从而让另一个线程运行.</p><h2 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h2><p><code>IEEE 1003.1c</code> 线程标准</p><p>线程包被定义为 <code>Pthreads</code>, 这个标准定义了60多种功能调用.</p><p>POSIX线程是一种独立于语言而存在的执行模型, 以及并行执行模型.</p><p>线程调用 : </p><p><code>pthread_create</code> : 创建一个新线程</p><p><code>pthread_exit</code> : 结束调用的线程. 释放线程拥有的堆栈.</p><p><code>pthread_join</code> : 等待一个特定的线程退出</p><p><code>pthread_yield</code> : 释放CPU来运行另一个线程</p><p><code>pthread_attr_init</code> : 创建并初始化一个线程的属性结构</p><p><code>pthread_attr_destory</code> : 删除一个线程的属性结构</p><p>一个例子 :</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUMBER_OF_THREADS 10</span><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">print_hello_world</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * tid)</span></span>&#123;    <span class="hljs-comment">/* 输出线程的标识符, 然后退出 */</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World. Greeting from thread %d\n&quot;</span>, tid);    pthread_exit(<span class="hljs-literal">NULL</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">/* 主程序创建10个线程, 然后退出 */</span>    <span class="hljs-keyword">pthread_t</span> threads[NUMBER_OF_THREADS];    <span class="hljs-keyword">int</span> status, i;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUMBER_OF_THREADS; ++ i)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Main here. Creating thread %d\n&quot;</span>, i);        status = pthread_create(&amp;threads[i], <span class="hljs-literal">NULL</span>, print_hello_world, (<span class="hljs-keyword">void</span> *)i);        <span class="hljs-keyword">if</span>(status != <span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Oops. pthread_create returned error code %d\n&quot;</span>, status);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);        &#125;    &#125;    <span class="hljs-built_in">exit</span>(<span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><p>三种实现方式 : </p><ul><li>在用户空间中实现线程;</li><li>在内核空间中实现线程;</li><li>在用户和内核空间中混合实现线程.</li></ul><h3 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h3><p>整个线程包放在用户空间中, 内核对线程一无所知, 不知道线程的存在.<br>包括以下几个过程 : pthread_create, pthread_exit, pthread_join, pthread_yield.<br>维护一张线程表, 记录各线程的属性. 由运行时系统统一管理.</p><p><strong>在用户空间实现线程的优势</strong></p><p>启动比进行内核调用效率更高, 不需要切换到内核, 不需要上下文切换, 不需要对内存高速缓存进行刷新, 线程调度便捷.</p><p><strong>在用户空间实现线程的裂势</strong></p><h3 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h3><h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;Website&quot; src=&quot;https://img.shields.io/badge/博客-劳振煜的知識倉儲</summary>
      
    
    
    
    <category term="OS" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/OS/"/>
    
    
    <category term="OS" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>02 Smart_Ptr</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/26/C++/modern%20cpp/02%20smart_ptr/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/26/C++/modern%20cpp/02%20smart_ptr/</id>
    <published>2021-01-26T13:05:00.000Z</published>
    <updated>2021-03-06T10:13:41.191Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a><blockquote><p>  学习自 : 现代 C++</p></blockquote></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>上一讲中的 shape_wrapper 在某一程度上可以作为智能指针使用。</p><p>使用智能指针，可以简化资源的管理，从根本上消除内存泄漏的可能性。</p><a id="more"></a><p>这一讲把 shape_wrapper 改造成一个完整的智能指针。</p><p>智能指针本质上其实就是 RAII 资源管理功能的自然展现。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape_wrapper</span>&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">shape_wrapper</span><span class="hljs-params">(shape *ptr = <span class="hljs-literal">nullptr</span>)</span></span><span class="hljs-function">: <span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span> </span>&#123;&#125;~shape_wrapper()&#123; <span class="hljs-keyword">delete</span> ptr_; &#125;<span class="hljs-function">shape *<span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr_; &#125;<span class="hljs-keyword">private</span>:shape *ptr_;&#125;;</code></pre><p>这个类可以完成智能指针最基本的功能：对超出作用域的对象进行释放。但是相比智能指针来说，缺少了一些特性：</p><ol><li>这个类只适用于 shape 类</li><li>该类对象的行为不够像指针</li><li>拷贝该类对象会引发程序行为异常</li></ol><p>接下来是逐一解决以上的问题。</p><h2 id="模板化和易用性"><a href="#模板化和易用性" class="headerlink" title="模板化和易用性"></a>模板化和易用性</h2><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span> &#123;</span><span class="hljs-keyword">public</span>:  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span><span class="hljs-function">    : <span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span> </span>&#123;&#125;  ~smart_ptr()  &#123;    <span class="hljs-keyword">delete</span> ptr_;  &#125;  <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr_; &#125;<span class="hljs-keyword">private</span>:  T* ptr_;&#125;;</code></pre><p>这里使用模板 template，只需要将原本 shape* 替换成为 T*。使用的时候，将 <code>shape_wrapper</code> 改为 <code>smart_ptr&lt;shape&gt;</code> 即可。</p><h2 id="使用像指针的类"><a href="#使用像指针的类" class="headerlink" title="使用像指针的类"></a>使用像指针的类</h2><p>这个类和指针的差异在于：</p><ul><li>它不能使用 * 运算符解引用</li><li>它不能使用→ 运算符指向对象成员</li><li>它不能像指针一样用在布尔表达式里</li></ul><p>修改如下：</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span> &#123;</span><span class="hljs-keyword">public</span>:  …  T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> *ptr_; &#125;  T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> ptr_; &#125;  <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr_; &#125;&#125;</code></pre><h2 id="拷贝构造和赋值"><a href="#拷贝构造和赋值" class="headerlink" title="拷贝构造和赋值"></a>拷贝构造和赋值</h2><pre><code class="hljs cpp"><span class="hljs-comment">//假设会出现以下的行为</span>smart_ptr&lt;shape&gt; ptr1&#123;create_shape(shape_type::circle)&#125;;smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;</code></pre><p><code>Smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;</code> 可能会导致同一内存释放两次，会导致程序奔溃。</p><p>禁止拷贝的方案：使用 <code>=delete</code></p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span> &#123;</span>  …  smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&amp;)    = <span class="hljs-keyword">delete</span>;  smart_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> smart_ptr&amp;)    = <span class="hljs-keyword">delete</span>;  …&#125;;</code></pre><p>禁止拷贝解决了一种可能出错的情况。</p><p>注意：针对以上问题，不能采用多拷贝一份对象来解决。采用智能指针的目的之一是减少对象的拷贝。</p><hr><p>也可以尝试在拷贝时转移指针的所有权，实现如下：</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span> &#123;</span>  …  smart_ptr(smart_ptr&amp; other)  &#123;    ptr_ = other.release();  &#125;  smart_ptr&amp; <span class="hljs-keyword">operator</span>=(smart_ptr&amp; rhs)  &#123;    smart_ptr(rhs).swap(*<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  &#125;  …  <span class="hljs-function">T* <span class="hljs-title">release</span><span class="hljs-params">()</span></span><span class="hljs-function">  </span>&#123;    T* ptr = ptr_;    ptr_ = <span class="hljs-literal">nullptr</span>;    <span class="hljs-keyword">return</span> ptr;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&amp; rhs)</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;    swap(ptr_, rhs.ptr_);  &#125;  …&#125;;</code></pre><p>以上赋值函数的惯用法，要比 if(this ≠ &amp;rhs) 异常安全。</p><p>以上代码的惯用法保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能发生在第一步，第一步如果发生异常，this对象完全不受影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态。</p><p>以上代码的最大问题是，程序员一不小心把它传递给另一个 smart_ptr，你就不再拥有这个对象了。</p><h2 id="移动指针？"><a href="#移动指针？" class="headerlink" title="移动指针？"></a>移动指针？</h2><p>下一讲会讲述移动语义，我们先简单看看 smart_ptr 如何使用移动语义来改善其行为。修改如下：</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span> &#123;</span>  …  smart_ptr(smart_ptr&amp;&amp; other)  &#123;    ptr_ = other.release();  &#125;  smart_ptr&amp; <span class="hljs-keyword">operator</span>=(smart_ptr rhs)  &#123;    rhs.swap(*<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  &#125;  …&#125;;</code></pre><p>修改方案有亮点：</p><ol><li>把拷贝构造函数中的参数类型 smart_ptr &amp; 改成了 smart_ptr &amp;&amp;, 现在它成了移动构造函数。</li><li>把赋值函数中的参数类型 smart_ptr &amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。</li></ol><p>现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。</p><p>如果只提供移动构造函数，而不手动写一个拷贝构造函数，那么后者会被自动禁用。于是有以下结果：</p><pre><code class="hljs cpp">smart_ptr&lt;shape&gt; ptr1&#123;create_shape(shape_type::circle)&#125;;smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;             <span class="hljs-comment">// 编译出错</span>smart_ptr&lt;shape&gt; ptr3;ptr3 = ptr1;                             <span class="hljs-comment">// 编译出错</span>ptr3 = <span class="hljs-built_in">std</span>::move(ptr1);                  <span class="hljs-comment">// OK，可以</span>smart_ptr&lt;shape&gt; ptr4&#123;<span class="hljs-built_in">std</span>::move(ptr3)&#125;;  <span class="hljs-comment">// OK，可以</span></code></pre><p>这是C++11中的 unique_ptr 的基本行为。</p><h2 id="子类指针向基类指针的转换"><a href="#子类指针向基类指针的转换" class="headerlink" title="子类指针向基类指针的转换"></a>子类指针向基类指针的转换</h2><p>原本的继承关系中，circle* 可以向上转型成为 shape*，而 smart_ptr<circle></circle> 无法向上转型成为 smart_ptr<shape>。不过，只需要增加一点额外的模板代码，就可以解决这个问题。</shape></p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;  smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)  &#123;    ptr_ = other.release();  &#125;</code></pre><p>在参数里传入的是 smart_ptr&lt;U&gt; 也就是说，可以传入另一个模板参数的 smart_ptr 作为拷贝构造的参数。这样 smart_ptr<circle></circle> 可以移动给 smart_ptr<shape> 但是不能移动给 smart_ptr<triangle>.</triangle></shape></p><p>需要注意的是，以上代码不会被看作是移动构造函数，因而不能自动地删除拷贝构造函数的行为。可以额外使用 =delete 的方式。</p><pre><code class="hljs cpp">smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&amp;) = <span class="hljs-keyword">delete</span>;smart_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> smart_ptr&amp;) = <span class="hljs-keyword">delete</span>;</code></pre><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>Unique_ptr 是一种较为安全的智能指针。但是一个对象智能被一个指针拥有，不能满足所有使用场合。一种常见的情况是，多个智能指针同时拥有一个对象，当所有智能指针失效时，这个对象也会被删除。这就是 shared_ptr。</p><p>多个不同的 shared_ptr 可以共享同一对象，并且共享同一计数值。当 shared_ptr 析构时，它需要删除对象和共享技术。</p><p>计数接口：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shared_count</span> &#123;</span><span class="hljs-keyword">public</span>:  shared_count();  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_count</span><span class="hljs-params">()</span></span>;  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">reduce_count</span><span class="hljs-params">()</span></span>;  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">get_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;&#125;;</code></pre><p>以下实现时多线程不安全的简化版本：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shared_count</span> &#123;</span><span class="hljs-keyword">public</span>:  shared_count() : count_(<span class="hljs-number">1</span>) &#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_count</span><span class="hljs-params">()</span></span><span class="hljs-function">  </span>&#123;    ++count_;  &#125;  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">reduce_count</span><span class="hljs-params">()</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">return</span> --count_;  &#125;  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">get_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">return</span> count_;  &#125;<span class="hljs-keyword">private</span>:  <span class="hljs-keyword">long</span> count_;&#125;;</code></pre><p>Shared_ptr 类的实现：</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span> &#123;</span><span class="hljs-keyword">public</span>:  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span><span class="hljs-function">    : <span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">if</span> (ptr) &#123;      shared_count_ =        <span class="hljs-keyword">new</span> shared_count();    &#125;  &#125;  ~smart_ptr()  &#123;    <span class="hljs-keyword">if</span> (ptr_ &amp;&amp;      !shared_count_         -&gt;reduce_count()) &#123; <span class="hljs-comment">//此时计数为0</span>      <span class="hljs-keyword">delete</span> ptr_;      <span class="hljs-keyword">delete</span> shared_count_;    &#125;  &#125;<span class="hljs-keyword">private</span>:  T* ptr_;  shared_count* shared_count_;&#125;;</code></pre><p>为了方便实现赋值及其他一些惯用法，我们需要一个 swap 成员函数：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&amp; rhs)</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;    swap(ptr_, rhs.ptr_);    swap(shared_count_,         rhs.shared_count_);  &#125;</code></pre><p> 拷贝构造函数以及移动构造函数如下：</p><pre><code class="hljs cpp"><span class="hljs-comment">//拷贝构造</span>smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&amp; other) &#123;   ptr_ = other.ptr_;   <span class="hljs-keyword">if</span> (ptr_) &#123;     other.shared_count_       -&gt;add_count();     shared_count_ =       other.shared_count_;   &#125; &#125;<span class="hljs-comment">//向上转型的拷贝构造</span> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt; smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other) &#123;   ptr_ = other.ptr_;   <span class="hljs-keyword">if</span> (ptr_) &#123;     other.shared_count_       -&gt;add_count();     shared_count_ =       other.shared_count_;   &#125; &#125;<span class="hljs-comment">//移动构造</span> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt; smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) &#123;   ptr_ = other.ptr_;   <span class="hljs-keyword">if</span> (ptr_) &#123;     shared_count_ =       other.shared_count_;     other.ptr_ = <span class="hljs-literal">nullptr</span>;   &#125; &#125;</code></pre><p>注意：以上代码会编译失败</p><blockquote><p>Fatal error : ‘ptr_’ is a private member of ‘smart_ptr<circle></circle>’</p></blockquote><p>错误原因，模板的各个实例间并不天然是friend关系，因而不能互访私有成员ptr_和share_count_，我们需要在 smart_ptr 的定义中显示声明：</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span>;</span></code></pre><p>方便调试过程，增加一个返回引用计数值的函数，如下：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">if</span> (ptr_) &#123;      <span class="hljs-keyword">return</span> shared_count_        -&gt;get_count();    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;  &#125;</code></pre><p>验证代码如下：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span> &#123;</span><span class="hljs-keyword">public</span>:  <span class="hljs-keyword">virtual</span> ~shape() &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span> :</span> <span class="hljs-keyword">public</span> shape &#123;<span class="hljs-keyword">public</span>:  ~circle() &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;~circle()&quot;</span>); &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-function">smart_ptr&lt;circle&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> circle())</span></span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;use count of ptr1 is %ld\n&quot;</span>,         ptr1.use_count());  smart_ptr&lt;shape&gt; ptr2;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;use count of ptr2 was %ld\n&quot;</span>,         ptr2.use_count());  ptr2 = ptr1;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;use count of ptr2 is now %ld\n&quot;</span>,         ptr2.use_count());  <span class="hljs-keyword">if</span> (ptr1) &#123;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;ptr1 is not empty&quot;</span>);  &#125;&#125;</code></pre><h2 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h2><p>对应于C++里的不同的类型强制转换：</p><ul><li>static_cast</li><li>Reinterpret_cast</li><li>Const_cast</li><li>Dynamic_cast</li></ul><p>智能指针需要实现类似的函数模板。为了实现转换，需要添加构造函数。</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;  smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other, T* ptr)  &#123;    ptr_ = ptr;    <span class="hljs-keyword">if</span> (ptr_) &#123;      other.shared_count_        -&gt;add_count();      shared_count_ =        other.shared_count_;    &#125;  &#125;</code></pre><p>这样可以实现转换所需的函数模板了，下面实现 dynamic_pointer_cast ：</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<span class="hljs-function">smart_ptr&lt;T&gt; <span class="hljs-title">dynamic_pointer_cast</span><span class="hljs-params">(<span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other)</span></span>&#123;  T* ptr = <span class="hljs-keyword">dynamic_cast</span>&lt;T*&gt;(other.get());  <span class="hljs-keyword">return</span> smart_ptr&lt;T&gt;(other, ptr);&#125;</code></pre><p>验证代码如下：</p><pre><code class="hljs cpp">smart_ptr&lt;circle&gt; ptr3 = dynamic_pointer_cast&lt;circle&gt;(ptr2);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;use count of ptr3 is %ld\n&quot;</span>, ptr3.use_count());</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;  // std::swap</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shared_count</span> &#123;</span><span class="hljs-keyword">public</span>:  shared_count() <span class="hljs-keyword">noexcept</span>    : count_(<span class="hljs-number">1</span>) &#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function">  </span>&#123;    ++count_;  &#125;  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">reduce_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">return</span> --count_;  &#125;  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">get_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">return</span> count_;  &#125;<span class="hljs-keyword">private</span>:  <span class="hljs-keyword">long</span> count_;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span> &#123;</span><span class="hljs-keyword">public</span>:  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;  <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span>;</span>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span><span class="hljs-function">    : <span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">if</span> (ptr) &#123;      shared_count_ =        <span class="hljs-keyword">new</span> shared_count();    &#125;  &#125;  ~smart_ptr()  &#123;    <span class="hljs-keyword">if</span> (ptr_ &amp;&amp;      !shared_count_         -&gt;reduce_count()) &#123;      <span class="hljs-keyword">delete</span> ptr_;      <span class="hljs-keyword">delete</span> shared_count_;    &#125;  &#125;  smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&amp; other)  &#123;    ptr_ = other.ptr_;    <span class="hljs-keyword">if</span> (ptr_) &#123;      other.shared_count_        -&gt;add_count();      shared_count_ =        other.shared_count_;    &#125;  &#125;  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;  smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other) <span class="hljs-keyword">noexcept</span>  &#123;    ptr_ = other.ptr_;    <span class="hljs-keyword">if</span> (ptr_) &#123;      other.shared_count_-&gt;add_count();      shared_count_ = other.shared_count_;    &#125;  &#125;  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;  smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) <span class="hljs-keyword">noexcept</span>  &#123;    ptr_ = other.ptr_;    <span class="hljs-keyword">if</span> (ptr_) &#123;      shared_count_ =        other.shared_count_;      other.ptr_ = <span class="hljs-literal">nullptr</span>;    &#125;  &#125;  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;  smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other,            T* ptr) <span class="hljs-keyword">noexcept</span>  &#123;    ptr_ = ptr;    <span class="hljs-keyword">if</span> (ptr_) &#123;      other.shared_count_        -&gt;add_count();      shared_count_ =        other.shared_count_;    &#125;  &#125;  smart_ptr&amp;  <span class="hljs-keyword">operator</span>=(smart_ptr rhs) <span class="hljs-keyword">noexcept</span>  &#123;    rhs.swap(*<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  &#125;  <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">return</span> ptr_;  &#125;  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">if</span> (ptr_) &#123;      <span class="hljs-keyword">return</span> shared_count_        -&gt;get_count();    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&amp; rhs)</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;    swap(ptr_, rhs.ptr_);    swap(shared_count_,         rhs.shared_count_);  &#125;  T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>  &#123;    <span class="hljs-keyword">return</span> *ptr_;  &#125;  T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>  &#123;    <span class="hljs-keyword">return</span> ptr_;  &#125;  <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">return</span> ptr_;  &#125;<span class="hljs-keyword">private</span>:  T* ptr_;  shared_count* shared_count_;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&lt;T&gt;&amp; lhs,</span></span><span class="hljs-function"><span class="hljs-params">          smart_ptr&lt;T&gt;&amp; rhs)</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function"></span>&#123;  lhs.swap(rhs);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<span class="hljs-function">smart_ptr&lt;T&gt; <span class="hljs-title">static_pointer_cast</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function"></span>&#123;  T* ptr = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(other.get());  <span class="hljs-keyword">return</span> smart_ptr&lt;T&gt;(other, ptr);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<span class="hljs-function">smart_ptr&lt;T&gt; <span class="hljs-title">reinterpret_pointer_cast</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function"></span>&#123;  T* ptr = <span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(other.get());  <span class="hljs-keyword">return</span> smart_ptr&lt;T&gt;(other, ptr);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<span class="hljs-function">smart_ptr&lt;T&gt; <span class="hljs-title">const_pointer_cast</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function"></span>&#123;  T* ptr = <span class="hljs-keyword">const_cast</span>&lt;T*&gt;(other.get());  <span class="hljs-keyword">return</span> smart_ptr&lt;T&gt;(other, ptr);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<span class="hljs-function">smart_ptr&lt;T&gt; <span class="hljs-title">dynamic_pointer_cast</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function"></span>&#123;  T* ptr = <span class="hljs-keyword">dynamic_cast</span>&lt;T*&gt;(other.get());  <span class="hljs-keyword">return</span> smart_ptr&lt;T&gt;(other, ptr);&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;Website&quot; src=&quot;https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&amp;logo=Blogger&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://www.github.com/OXygenPanda&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&amp;logo=GitHub&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&amp;logo=WeChat&quot;&gt;&lt;/a&gt;


&lt;blockquote&gt;
&lt;p&gt;  学习自 : 现代 C++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;&lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;上一讲中的 shape_wrapper 在某一程度上可以作为智能指针使用。&lt;/p&gt;
&lt;p&gt;使用智能指针，可以简化资源的管理，从根本上消除内存泄漏的可能性。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"/>
    
    
    <category term="modern C++" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/modern-C/"/>
    
  </entry>
  
  <entry>
    <title>01 RAII</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/25/C++/modern%20cpp/01%20RAII/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/25/C++/modern%20cpp/01%20RAII/</id>
    <published>2021-01-25T12:00:00.000Z</published>
    <updated>2021-03-06T10:13:43.499Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a><blockquote><p>  学习自 : 现代 C++</p></blockquote></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>这里说的堆是动态分配内存的区域, 与数据结构里的堆不同.</p><p>这里的内存必须手动释放, 否则会造成内存泄漏.</p><a id="more"></a><p>内存泄漏两大原因 : 异常或者分支导致 delete 未执行; 分配和释放在两个函数里, 忘记 delete.</p><p><code>new</code> 和 <code>delete</code> 通常底层使用 <code>malloc</code> 和 <code>free</code> 来实现.</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();</code></pre><p>堆的内存管理器的操作通常有 : </p><ol><li><strong>让内存管理器分配一个某个大小的内存块</strong></li><li><strong>让内存管理器释放一个之前分配的内存块</strong></li><li>让内存管理器进行垃圾收集操作, 寻找不再使用的内存块并予以释放</li></ol><p>C++会做1和2. Java会做1和3. Python会做1,2和3.</p><p>注意 : 内存回收会把连续未使用的内存块合并成一块, 以便满足后续的较大内存分配要求.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;bar *ptr = <span class="hljs-keyword">new</span> bar();...<span class="hljs-keyword">delete</span> ptr;&#125;</code></pre><p>以上代码如果在…处发生了异常, 程序终止的话, 会导致内存泄漏.</p><hr><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>和数据结构里的栈十分相似.</p><p>满足后进先出.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;...&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<span class="hljs-keyword">int</span> a = n + <span class="hljs-number">1</span>;foo(a);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;...bar(<span class="hljs-number">42</span>);...&#125;</code></pre><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>在 x86 在内的大部分计算机体系架构中, 栈的增长方向是低地址, 也就是意味着我们平时画的栈上分是低地址.</p><p>任何一个函数只能使用进入函数时, 栈指针上分部分的栈空间.</p><p>当调用另一个函数时, 会把参数压入栈中, 然后把下一行汇编指令的地址也压入栈, 并且跳转到新的函数.</p><p>随后, 新的函数会继续分配一部分栈空间保存本地变量. 结束后, 会根据之前压入栈的地址回到未执行的代码中.</p><h3 id="使用栈空间的优势"><a href="#使用栈空间的优势" class="headerlink" title="使用栈空间的优势"></a>使用栈空间的优势</h3><ol><li>栈上的分配极为简单, 移动一下栈指针.</li><li>栈上的释放也极为简单, 函数执行完毕后移动一下栈指针.</li><li>由于后进先出的执行过程, 不可能出现内部碎片.</li></ol><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>每一个函数所占用的栈内存空间称为栈帧, GCC 和 Clang 的命令行参数中提到的 frame 的, 如 <code>-fomit-frame-pointer</code> 一般就是指栈帧.</p><h3 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h3><p>编译器会自动调用析构函数, 包括在函数执行发生异常的情况.</p><hr><h2 id="RAII-读-a-re-i-i"><a href="#RAII-读-a-re-i-i" class="headerlink" title="RAII(读 a - re - i - i)"></a>RAII(读 a - re - i - i)</h2><p>RAII : Resource Acquisition Is Initialization</p><p>是C++所特有的资源管理方式. 其他语言如 D / Ada / Rust 也采用 RAII. 在主流编程语言中只有 C++ 依赖 RAII 来做资源管理.</p><p>RAII依托于栈和析构函数, 对所有的资源包括堆内存在内进行管理. 这也是在C++中没有使用垃圾回收机制的原因</p><p>很多时候, 对象不能或者不应该存储在栈上, 比如 : </p><ol><li>对象很大;</li><li>对象的大小在编译时不能确定;</li><li>对象是函数的返回值, 但由于特殊的原因, 不应使用对象的值返回.</li></ol><p>比如 : 在工厂方法或其他面向对象编程的时候, 返回值类型是基类的指针或者引用.</p><pre><code class="hljs cpp"><span class="hljs-comment">// 工厂方法</span><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape_type</span> &#123;</span>circle,triangle,rectangle,...&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span> &#123;</span>...&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span> :</span> <span class="hljs-keyword">public</span> shape &#123; ... &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">triangle</span> :</span> <span class="hljs-keyword">public</span> shape &#123; ... &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rectangle</span> :</span> <span class="hljs-keyword">public</span> shape &#123; ... &#125;;<span class="hljs-function">shape *<span class="hljs-title">create_shape</span><span class="hljs-params">(shape_type type)</span></span>&#123;...<span class="hljs-keyword">switch</span>(type)&#123;<span class="hljs-keyword">case</span> shape_type::circle:<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> circle(...);<span class="hljs-keyword">case</span> shape_type::triangle:<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> triangle(...);<span class="hljs-keyword">case</span> shape_type::rectangle:<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> rectangle  (...);&#125;&#125;</code></pre><p>这里应该返回的是一个对象的指针, 而不是一个对象. 因为对象是继承关系的, 无法确定返回类型的大小. 会引发对象切片</p><p>如何确保不会发生内存泄漏?</p><p>答案 : 在析构函数和它的栈展开行为上. 需要把返回值放在一个本地变量中, 并确保其析构函数会删除该对象即可. 实现如下 : </p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape_wrapper</span>&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">shape_wrapper</span><span class="hljs-params">(shape *ptr = <span class="hljs-literal">nullptr</span>)</span> : <span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span> </span>&#123;&#125;~shape_wrapper()&#123;<span class="hljs-keyword">delete</span> ptr_;&#125;<span class="hljs-function">shape *<span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<span class="hljs-keyword">private</span>:shape *ptr_;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;...<span class="hljs-function">shape_wrapper <span class="hljs-title">ptr_wrapper</span><span class="hljs-params">(create_shape(...))</span></span>;...&#125;</code></pre><p>delete 一个空指针是一种合法的空操作.</p><pre><code class="hljs cpp"><span class="hljs-comment">// new circle(...)</span>&#123;<span class="hljs-keyword">void</span> *temp = <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">sizeof</span>(circle));<span class="hljs-keyword">try</span>&#123;circle *ptr = <span class="hljs-keyword">static_cast</span>&lt;circle *&gt;(temp);ptr-&gt;circle(...);<span class="hljs-keyword">return</span> ptr;&#125;<span class="hljs-keyword">catch</span> (...) &#123;<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<span class="hljs-keyword">throw</span>;&#125;&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(ptr != <span class="hljs-literal">nullptr</span>)&#123;ptr-&gt;shape();<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;&#125;</code></pre><p>在析构函数里做必要的清理工作, 这就是 RAII 的基本用法. 这种清理并不限于释放内存, 也可以是 : </p><ul><li>关闭文件 (fstream 的析构就会这么做)</li><li>释放同步锁</li><li>释放其他重要的系统资源</li></ul><p>例如, 我们应该使用 :</p><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::mutex mtx;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_func</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mtx)</span></span>;<span class="hljs-comment">//做需要同步的工作</span>&#125;</code></pre><p>而不是 : </p><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::mutex mtx;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_func</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//做需要同步的工作</span><span class="hljs-comment">//如果发生异常或提前返回</span><span class="hljs-comment">//下面这一句不会自动执行</span>mtx.unlock();&#125;</code></pre><p>上面的 <code>shape_wrapper</code> 差不多是一个最简单的智能指针.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用栈是最自然的内存使用方式.</p><p>使用基于栈和析构函数的RAII, 可以有效地对包括堆内存在内的系统资源进行统一管理.</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><h3 id="01-1"><a href="#01-1" class="headerlink" title="01_1"></a>01_1</h3><p>测试中断会导致堆区内存无法释放而导致内存泄漏.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">bar</span>&#123;</span>    <span class="hljs-keyword">public</span>:        bar() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;called construct function.&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;        ~bar()&#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;called destruct function.&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;    bar *ptr = <span class="hljs-keyword">new</span> bar();    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);                    <span class="hljs-comment">//&lt;--- 异常或者终止会导致内存泄漏,无法释放掉ptr所指向的内存空间</span>    <span class="hljs-keyword">delete</span> ptr;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    foo();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs cpp">out:called construct function.</code></pre><h3 id="01-2"><a href="#01-2" class="headerlink" title="01_2"></a>01_2</h3><p>写了一些带有继承关系的类, 中断仍然无法释放内存.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape_type</span> &#123;</span>    circle,    triangle,    rectangle,&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span> &#123;</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;shape&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        ~shape() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;shape destructor.&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span> :</span> <span class="hljs-keyword">public</span> shape &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;circle&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        ~circle() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;circle destructor.&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">triangle</span> :</span> <span class="hljs-keyword">public</span> shape &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;triangle&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;&#125;;<span class="hljs-function">shape* <span class="hljs-title">create_shape</span><span class="hljs-params">(shape_type type)</span></span>&#123;    <span class="hljs-keyword">switch</span>(type)&#123;        <span class="hljs-keyword">case</span> shape_type::circle : <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> circle;        <span class="hljs-keyword">case</span> shape_type::triangle : <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> triangle;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    shape * sptr = create_shape(shape_type::circle);         <span class="hljs-comment">//&lt;--- 通过 create_shape 来创建对象</span>    sptr-&gt;print();    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    <span class="hljs-keyword">delete</span> sptr;                                             <span class="hljs-comment">//&lt;--- 终止后仍然不会释放堆内存空间</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs cpp">out:circle</code></pre><h3 id="01-3"><a href="#01-3" class="headerlink" title="01_3"></a>01_3</h3><p>利用 RAII 的思路, 在栈区对象的析构函数中释放资源, 使得即使抛出异常, 仍然能够释放堆区内存.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape_type</span> &#123;</span>    circle,    triangle,    rectangle,&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span> &#123;</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;shape&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        ~shape() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;shape destructor.&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span> :</span> <span class="hljs-keyword">public</span> shape &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;circle&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        ~circle() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;circle destructor.&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">triangle</span> :</span> <span class="hljs-keyword">public</span> shape &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;triangle&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;&#125;;<span class="hljs-function">shape* <span class="hljs-title">create_shape</span><span class="hljs-params">(shape_type type)</span></span>&#123;    <span class="hljs-keyword">switch</span>(type)&#123;        <span class="hljs-keyword">case</span> shape_type::circle : <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> circle;        <span class="hljs-keyword">case</span> shape_type::triangle : <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> triangle;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape_wrapper</span> &#123;</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">shape_wrapper</span><span class="hljs-params">(shape* ptr = <span class="hljs-literal">nullptr</span>)</span> : <span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span> </span>&#123;&#125;        ~shape_wrapper() &#123; <span class="hljs-keyword">delete</span> ptr_; &#125;        <span class="hljs-function">shape* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;            <span class="hljs-keyword">return</span> ptr_;        &#125;    <span class="hljs-keyword">private</span>:        shape* ptr_;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">try</span>&#123;        <span class="hljs-function">shape_wrapper <span class="hljs-title">sw</span><span class="hljs-params">(create_shape(shape_type::circle))</span></span>;        sw.get()-&gt;print();        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;test&quot;</span>;    &#125; <span class="hljs-keyword">catch</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* err_info)&#123;                            <span class="hljs-comment">//&lt;--- 异常, 仍然会栈展开释放资源</span>        <span class="hljs-built_in">cerr</span> &lt;&lt; err_info &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//exit(1);                                                //&lt;--- 终止仍然不能释放</span>    <span class="hljs-comment">//delete sw.get(); 不需要写 因为有栈展开, 会自动调用栈上的对象的析构函数</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs cpp">out:circleshape destructortest</code></pre>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;Website&quot; src=&quot;https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&amp;logo=Blogger&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://www.github.com/OXygenPanda&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&amp;logo=GitHub&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&amp;logo=WeChat&quot;&gt;&lt;/a&gt;


&lt;blockquote&gt;
&lt;p&gt;  学习自 : 现代 C++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;&lt;h2 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h2&gt;&lt;p&gt;这里说的堆是动态分配内存的区域, 与数据结构里的堆不同.&lt;/p&gt;
&lt;p&gt;这里的内存必须手动释放, 否则会造成内存泄漏.&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"/>
    
    
    <category term="modern C++" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/modern-C/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/20/HugeFour/OperatingSystem/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/20/HugeFour/OperatingSystem/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2021-01-20T06:07:00.000Z</published>
    <updated>2021-02-02T06:08:48.619Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a><blockquote><p>  学习自 : <a href="https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=6979152329662416408">https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=6979152329662416408</a></p></blockquote></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>服务器应对并发时, 如果使用多线程程序, 每一个连接创建一个线程, 由于上下文切换,  处理句柄会导致代价很高. 所以很多时候, 使用的是单线程程序, 其中 DMA 保证了不同时候到来的 IO数据 不会丢失.</p><a id="more"></a><p>最简单的一个由程序来接收IO数据的程序.</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span>(Fdx in (FdA ~ FdE) &#123;<span class="hljs-keyword">if</span>(Fdx 有数据) &#123;读Fdx;处理;&#125;&#125;&#125;</code></pre><p>但是, 每一次由用户来询问内核, 开销较大, 因此有了 <code>select()</code>.</p><h2 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h2><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;FD_ZERO(&amp;rset);<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) &#123;FD_SET(fds[i], &amp;rset);&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;round again&quot;</span>);select(max + <span class="hljs-number">1</span>, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//阻塞函数</span><span class="hljs-comment">/*</span><span class="hljs-comment">para 0:文件描述符最大的范围(因为第一位是fd=0,所以要加1)</span><span class="hljs-comment">para 1:读文件描述符(比较关注)</span><span class="hljs-comment">para 2:写文件描述符</span><span class="hljs-comment">para 3:异常文件描述符</span><span class="hljs-comment">para 4:超时时间</span><span class="hljs-comment">*/</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) &#123;<span class="hljs-keyword">if</span>(FD_ISSET(fds[i], &amp;rset)) &#123;<span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, MAXBUF);read(fds[i], buffer, MAXBUF);<span class="hljs-built_in">puts</span>(buffer);&#125;&#125;&#125;</code></pre><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>使用 rset(bitmap) 来标记注册的 Fds ;</li><li>将 rset 拷贝至内核态 ;</li><li>select() 阻塞 ;</li><li>有数据到来后, 内核对有数据的 rset位 置位, 并且 select() 返回 ;</li><li>遍历 Fds 判断是否被置位, 如果置位就说明对应的 IO 有数据 ;</li><li>由于破坏了 rset位图, 需要重新遍历 Fds 标记 rest位图 ;</li><li>循环 2 - 6.</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>rset 的数据结构以及存储的数据的表示</li></ol><pre><code class="hljs cpp">rset的数据类型是 bitmap假设 fds 分别是 <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>那么rest 的值就是 bitmap&lt;<span class="hljs-number">1024</span>&gt;<span class="hljs-number">0110&#x27;0101&#x27;01000.</span>..<span class="hljs-comment">//左边第一个代表的是 fds 值为0的不存在</span><span class="hljs-comment">//1024 因为 Linux 默认支持最大线程数是1024</span></code></pre><ol start="2"><li>工作状态</li></ol><pre><code class="hljs cpp">无数据 : select() 阻塞有数据 : 内核 <span class="hljs-number">1.</span> 对有数据来的FD置位 <span class="hljs-number">2.</span> select() 返回</code></pre><ol start="3"><li>返回值</li></ol><pre><code class="hljs cpp">成功 : 大于 <span class="hljs-number">0</span> 出错 : <span class="hljs-number">-1</span>超时 : <span class="hljs-number">0</span></code></pre><h3 id="select-的优点"><a href="#select-的优点" class="headerlink" title="select() 的优点"></a>select() 的优点</h3><ol><li>将 rset 交给内核监听, 节约了一定的开销;</li><li><strong>select() 的核心是内核等待队列唤醒机制.</strong></li></ol><h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select() 的缺点"></a>select() 的缺点</h3><ol><li>rset : 1024 bitmap</li><li>FDset 不可重用</li><li>用户态拷贝的时候切换到内核态, 仍然有开销</li><li>O(n) 时间复杂度去遍历得到哪一个 IO 有数据</li></ol><h2 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h2><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><span class="hljs-keyword">int</span> id;        <span class="hljs-comment">//fds</span><span class="hljs-keyword">short</span> events;  <span class="hljs-comment">//关注的事件</span><span class="hljs-keyword">short</span> revents; <span class="hljs-comment">//反馈(初始值为0)</span>&#125;;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<span class="hljs-built_in">memset</span>(&amp;client, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(client));addrlen = <span class="hljs-keyword">sizeof</span>(client);pollfds[i].fd = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen);pollfds[i].events = POLLIN;&#125;sleep(<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;round again&quot;</span>);poll(pollfds, <span class="hljs-number">5</span>, <span class="hljs-number">50000</span>);   <span class="hljs-comment">//阻塞</span><span class="hljs-comment">/*</span><span class="hljs-comment">para 0 : 结构体数组名</span><span class="hljs-comment">para 1 : fds的个数</span><span class="hljs-comment">para 2 : 超时时间</span><span class="hljs-comment">*/</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) &#123;<span class="hljs-keyword">if</span>(pollfds[i].revents &amp; POLLIN) &#123; <span class="hljs-comment">//判 revents 和 关注的事件</span>pollfds[i].revents = <span class="hljs-number">0</span>;         <span class="hljs-comment">//置位达到可重用效果</span><span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, MAXBUF);read(pollfds[i], fd, buffer, MAXBUF);<span class="hljs-built_in">puts</span>(buffer);&#125;&#125;&#125;</code></pre><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>用户态拷贝 fds 至内核态, 由内核监听(和 select() 一样)</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>struct pollfd 的细节</li></ol><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">pollfd</span> 的一个节点相当于是 <span class="hljs-title">rset</span> 中的一位</span><span class="hljs-class"><span class="hljs-title">events</span>  用于标记关注的事件, 如果同时关注多个事件, 事件1 &amp; 事件2</span><span class="hljs-class"><span class="hljs-title">revents</span> 初始为0, 内核置数, 处理时清零, 可重用</span></code></pre><ol><li>工作状态</li></ol><pre><code class="hljs cpp">无数据 : poll() 阻塞有数据 : 内核 <span class="hljs-number">1.</span> pollfds.revents 置位 <span class="hljs-number">2.</span> poll 返回</code></pre><h3 id="poll-的优点"><a href="#poll-的优点" class="headerlink" title="poll() 的优点"></a>poll() 的优点</h3><ol><li>数组可以超过 1024 长(最大65535长)</li><li>重置 revents 后可重用</li></ol><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll()"></a>epoll()</h2><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>[5];</span><span class="hljs-keyword">int</span> epfd = epoll_create(<span class="hljs-number">10</span>);                        <span class="hljs-comment">// 1</span>......<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) &#123;<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><span class="hljs-built_in">memset</span>(&amp;client, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(client));addrlen = <span class="hljs-keyword">sizeof</span>(client);ev.data.fd = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen);ev.events = EPOLLIN;epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);  <span class="hljs-comment">// 2</span>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;round again&quot;</span>);nfds = epoll_waits(epfd, events, <span class="hljs-number">5</span>, <span class="hljs-number">10000</span>);       <span class="hljs-comment">// 3</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; nfds; i ++) &#123;<span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, MAXBUF);read(events[i].data.fd, buffer, MAXBUF);<span class="hljs-built_in">puts</span>(buffer);&#125;&#125;</code></pre><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>1 : 创建白板 epfd</p><p>2 : 在白板上写字 : fd - events, 得到了一些列 fd - events 的 epfd</p><p>3 : epfd 由用户态和内核态共享内存 ( 实际上还是要拷贝到内核态, 在 <code>epoll_ctl()</code> 就拷贝 )</p><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>函数细节</li></ol><pre><code class="hljs cpp">epoll_ctl()  向内核注册新的描述符或者改变某个文件描述符的状态, 已注册的描述符在内核中被维护成红黑树epoll_wait() 回调函数, 内核将有数据的描述符加入到一个链表中, 进程获得描述符数</code></pre><ol><li>工作状态</li></ol><pre><code class="hljs cpp">没数据 : epoll() 阻塞(水平触发下, 边缘触发?)有数据 : <span class="hljs-number">1.</span> <span class="hljs-string">&quot;置位&quot;</span>(重排,将有数据的fd-events放在最前面) <span class="hljs-number">2.</span> 返回值是有数据的IO数</code></pre><ol><li>两种触发模式</li></ol><pre><code class="hljs cpp">LT:水平触发当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-BlockingET:边缘触发和 LT 模式不同的是，通知之后进程必须立即处理事件。下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</code></pre><h3 id="epoll-的优点"><a href="#epoll-的优点" class="headerlink" title="epoll() 的优点"></a>epoll() 的优点</h3><ol><li>时间复杂度 O(1)</li></ol>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;Website&quot; src=&quot;https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&amp;logo=Blogger&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://www.github.com/OXygenPanda&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&amp;logo=GitHub&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&amp;logo=WeChat&quot;&gt;&lt;/a&gt;


&lt;blockquote&gt;
&lt;p&gt;  学习自 : &lt;a href=&quot;https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;amp;seid=6979152329662416408&quot;&gt;https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;amp;seid=6979152329662416408&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;服务器应对并发时, 如果使用多线程程序, 每一个连接创建一个线程, 由于上下文切换,  处理句柄会导致代价很高. 所以很多时候, 使用的是单线程程序, 其中 DMA 保证了不同时候到来的 IO数据 不会丢失.&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/15/HugeFour/DataStructrues/tree/RBTree/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/15/HugeFour/DataStructrues/tree/RBTree/</id>
    <published>2021-01-15T14:48:00.000Z</published>
    <updated>2021-01-15T14:51:33.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><strong>名称 :</strong> 红黑树</p><p><strong>优点 :</strong></p><p>相较AVL树来说, 平衡条件宽松, 减少了很多因插入删除节点导致的调整. 适合于插入删除频繁的情况.</p><p>AVL树适合于插入删除较少, 搜索较多的情况.</p><p><strong>平衡条件 :</strong> </p><ol><li>每个节点非黑即红</li><li>根节点是黑色</li><li>叶节点(NIL)是黑色  NIL : 虚拟空节点</li><li>如果一个节点是红色, 则它的两个子节点都是黑色的</li><li>从根节点触发到所有叶节点路径上, 黑色节点数量相同 (最长是最短路径的2倍 : 长边红黑相间, 短边黑色)</li></ol><p><strong>认识 :</strong> </p><p>平衡条件 4 和 5 限制了红黑树最长边和最短边的2倍长度关系. 本质上, 红黑树也是通过控制树高来保证平衡. 红黑树相比AVL树控制条件更弱, 因此插入删除调整的频次也会低. AVL树更适用于插入删除较少但是访问较多的情况.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;红黑树&quot;&gt;&lt;a href=&quot;#红黑树&quot; class=&quot;headerlink&quot; title=&quot;红黑树&quot;&gt;&lt;/a&gt;红黑树&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;名称 :&lt;/strong&gt; 红黑树&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点 :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相较AV</summary>
      
    
    
    
    <category term="tree" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/tree/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/15/HugeFour/DataStructrues/sort/quick/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/15/HugeFour/DataStructrues/sort/quick/</id>
    <published>2021-01-15T10:00:00.000Z</published>
    <updated>2021-01-15T14:51:52.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>名称 :</strong> 快速排序</p><p><strong>性质 :</strong> 不稳定的排序算法</p><p><strong>用途 :</strong> 分治思路的排序</p><p><strong>复杂度 :</strong> 时间 O(nlogn) 空间 O(1)</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs cpp"><span class="hljs-comment">/************************************************************************</span><span class="hljs-comment">    &gt; File Name: quick_sort2.cpp</span><span class="hljs-comment">    &gt; Author: Lao Zhenyu</span><span class="hljs-comment">    &gt; Mail: LaoZhenyu_961112@163.com</span><span class="hljs-comment">    &gt; Created Time: 五  1/15 17:48:29 2021</span><span class="hljs-comment">************************************************************************/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;    <span class="hljs-keyword">if</span>(left &gt;= right)   <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> i,j,base;    base = arr[left];    i = left, j = right;    <span class="hljs-keyword">while</span>(i &lt; j)&#123;        <span class="hljs-keyword">while</span>(arr[j] &gt;= base &amp;&amp; i &lt; j)            j--;        <span class="hljs-keyword">while</span>(arr[i] &lt;= base &amp;&amp; i &lt; j)            i++;        <span class="hljs-keyword">if</span>(i &lt; j)            swap(arr[i], arr[j]);    &#125;    arr[left] = arr[i];    arr[i] = base;    quickSort(arr, left, i - <span class="hljs-number">1</span>);    quickSort(arr, i + <span class="hljs-number">1</span>, right);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,&#125;;    quickSort(arr, <span class="hljs-number">0</span>, arr.size() - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : arr)&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="排序算法" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/14/HugeFour/DataStructrues/sort/merge/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/14/HugeFour/DataStructrues/sort/merge/</id>
    <published>2021-01-14T12:00:00.000Z</published>
    <updated>2021-01-15T14:52:09.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>名称 :</strong> 归并排序</p><p><strong>性质 :</strong> 稳定的排序算法</p><p><strong>作者 :</strong> 冯诺依曼</p><p><strong>用途 :</strong> 分治思路的排序</p><p><strong>复杂度 :</strong> 时间 O(nlogn) 空间 O(n)</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs cpp"><span class="hljs-comment">/************************************************************************</span><span class="hljs-comment">    &gt; File Name: merge_sort.cpp</span><span class="hljs-comment">    &gt; Author: Lao Zhenyu</span><span class="hljs-comment">    &gt; Mail: LaoZhenyu_961112@163.com</span><span class="hljs-comment">    &gt; Created Time: 四  1/14 20:38:22 2021</span><span class="hljs-comment">************************************************************************/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span></span>&#123;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">L</span><span class="hljs-params">(mid - left + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">R</span><span class="hljs-params">(right - mid)</span></span>;    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; L.size(); ++ i)&#123;        L[i] = arr[left + i];    &#125;    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; R.size(); ++ j)&#123;        R[j] = arr[mid + <span class="hljs-number">1</span> + j];    &#125;    i = <span class="hljs-number">0</span>;    j = <span class="hljs-number">0</span>;    k = left;    <span class="hljs-keyword">while</span>(i &lt; L.size() &amp;&amp; j &lt; R.size())&#123;        <span class="hljs-keyword">if</span>(L[i] &gt;= R[j])&#123;            arr[k] = R[j];            j++;        &#125; <span class="hljs-keyword">else</span> &#123;            arr[k] = L[i];            i++;        &#125;        k++;    &#125;    <span class="hljs-keyword">while</span>(i &lt; L.size())&#123;        arr[k] = L[i];        k++;        i++;    &#125;    <span class="hljs-keyword">while</span>(j &lt; R.size())&#123;        arr[k] = R[j];        k++;        j++;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;    <span class="hljs-keyword">if</span>(left &lt; right)&#123;        <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);        mergeSort(arr, left, mid);        mergeSort(arr, mid + <span class="hljs-number">1</span>, right);        merge(arr, left, mid, right);    &#125;    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;    mergeSort(arr,<span class="hljs-number">0</span>, arr.size() - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n : arr)&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="排序算法" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/07/HugeFour/DataStructrues/tree/AVLTree/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/07/HugeFour/DataStructrues/tree/AVLTree/</id>
    <published>2021-01-07T13:00:00.000Z</published>
    <updated>2021-01-15T14:51:32.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>名称 :</strong> AVL树</p><p><strong>发明者 :</strong> </p><p>G. M. Adelson-Velsky</p><p>E.M. Landis</p><p><strong>年代 :</strong> 1962年(58岁)</p><p><strong>优点 :</strong></p><p>由于对每个节点的左右子树的树高做了限制, 所以整棵树不会退化成一个链表</p><p>**学习重点 : **</p><ol><li>平衡二叉排序树,本质上也是二叉排序树, 所以拥有二叉排序树的所有性质</li><li>平衡二叉排序树的学习重点, 在于平衡条件以及平衡调整的相关学习</li></ol><p><strong>性质 :</strong></p><ol><li>平衡条件 : | H(left) - H(right) | ≤ 1</li></ol><p><strong>思考 :</strong> </p><p>​    高度为 H 的树, 所包含节点的范围是?</p><p>​    BinarySearchTree : H ≤ size ≤ 2^H - 1</p><p>​    AVLTree : low(H-2) + low(H-1) + 1 ≤ size ≤ 2^H - 1 (low(H) 是 H 高度的二叉树的最少节点数) 左边等于 1.5^H</p><p><strong>操作</strong>SSS</p><p>AVL树 - 左旋</p><img src="https://i.loli.net/2021/01/08/3XlUQLIxHNKTCt5.png" style="zoom:33%;">左旋前<img src="https://i.loli.net/2021/01/08/IxZvkmGhcprAE42.png" style="zoom:33%;">左旋后AVL树 - 右旋<img src="https://i.loli.net/2021/01/08/oNYgrvHhOSkb9BK.png" style="zoom:33%;">右旋前<img src="https://i.loli.net/2021/01/08/oNYgrvHhOSkb9BK.png" style="zoom:33%;">右旋后<h3 id="失衡类型"><a href="#失衡类型" class="headerlink" title="失衡类型"></a>失衡类型</h3><p>h(1,2,3,4) 分别代表左孩子的左子树个高,左孩子的右子树高,右孩子的左子树高和右孩子的右子树高</p><p>LL类型:左子树的左孩子更高</p><p>满足条件 : h1 = max(h3, h4) + 2 = h2 + 1</p><p>调整方案 : K1 右旋</p><p>LR类型:左子树的右孩子更高</p><p>满足条件 : max(h2, h3) = h4 = h1</p><p>调整方案 : 小左旋, 大右旋(左孩子左旋, 根节点右旋)</p><p>RL类型:右子树的左孩子更高</p><p>调整方案 : 小右旋, 大左旋</p><p>RR类型:右子树的右孩子更高</p><p>调整方案 : K1 左旋</p><h3 id="平衡调整策略"><a href="#平衡调整策略" class="headerlink" title="平衡调整策略"></a>平衡调整策略</h3><ol><li>发生在回溯阶段的, 第一个失衡节点处</li><li>理解平衡调整策略的关键在于 : 分析清楚四种情况下, ABCD四棵子树树高的关系</li><li>LL, 大右旋</li><li>LR, 先小左旋, 再大右旋</li><li>RL, 先小右旋, 再大左旋</li><li>RR, 大左旋</li></ol><h3 id="代码关键点"><a href="#代码关键点" class="headerlink" title="代码关键点"></a>代码关键点</h3><ol><li>插入和删除以后, 注意调整树高字段, 先调低的root, 再调高的tmp</li><li>引入了NIL节点, 代替了 NULL和nullptr, NULL不可访问资源, NIL是一个实际节点, 可以访问资源(h,lchild,rchild)</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> L(n) (n-&gt;lchild)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R(n) (n-&gt;rchild)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> H(n) (n-&gt;h)</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><span class="hljs-keyword">int</span> key,h;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span>&#125;Node;<span class="hljs-comment">//虚拟空节点, 为红黑树做准备的节点</span>Node __NIL;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NIL (&amp;__NIL)</span>__attribute__((constructor))<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_NIL</span><span class="hljs-params">()</span></span>&#123;NIL-&gt;key = <span class="hljs-number">0</span>, NIL-&gt;h = <span class="hljs-number">0</span>;NIL-&gt;lchild = NIL-&gt;rchild = <span class="hljs-literal">nullptr</span>;&#125;<span class="hljs-comment">//优先初始化上面这一段代码</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * AVL树的若干操作:</span><span class="hljs-comment"> * 1. 创建节点</span><span class="hljs-comment"> * 2. 销毁节点</span><span class="hljs-comment"> * 3. 插入</span><span class="hljs-comment"> * 4. 删除</span><span class="hljs-comment">*/</span><span class="hljs-function">Node *<span class="hljs-title">getNewNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;Node * tmp = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));tmp-&gt;key = key;tmp-&gt;h = <span class="hljs-number">1</span>;tmp-&gt;lchild = NIL, tmp-&gt;rchild = NIL;<span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node * root)</span></span>&#123;<span class="hljs-keyword">if</span>(root == NIL)<span class="hljs-keyword">return</span>;clear(root-&gt;lchild);clear(root-&gt;rchild);<span class="hljs-built_in">free</span>(root);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//调整高度</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update_height</span><span class="hljs-params">(Node * root)</span></span>&#123;root-&gt;h = (H(L(root)) &gt; H(R(root)) ? H(L(root)) : H(R(root))) + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//左旋</span><span class="hljs-function">Node * <span class="hljs-title">left_rotate</span><span class="hljs-params">(Node * root)</span></span>&#123;Node * tmp = root-&gt;rchild; <span class="hljs-comment">//新根节点</span>root-&gt;rchild = tmp-&gt;lchild; <span class="hljs-comment">//新左挂旧右</span>tmp-&gt;lchild = root; <span class="hljs-comment">//旧根挂新左</span>update_height(root);update_height(tmp);<span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-comment">//右旋</span><span class="hljs-function">Node * <span class="hljs-title">right_rotate</span><span class="hljs-params">(Node * root)</span></span>&#123;Node * tmp = root-&gt;lchild; <span class="hljs-comment">//新根</span>root-&gt;lchild = tmp-&gt;rchild; <span class="hljs-comment">//新右成旧左</span>tmp-&gt;rchild = root; <span class="hljs-comment">//旧根成新左</span>update_height(root);update_height(tmp);<span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-comment">//调整</span><span class="hljs-function">Node * <span class="hljs-title">maintain</span><span class="hljs-params">(Node * root)</span></span>&#123;<span class="hljs-comment">//平衡调整代码</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(H(L(root)) - H(R(root))) &lt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> root;<span class="hljs-keyword">if</span>(root-&gt;lchild-&gt;h &gt; root-&gt;rchild-&gt;h) &#123;<span class="hljs-comment">//LR先小左旋</span><span class="hljs-keyword">if</span>(root-&gt;lchild-&gt;lchild-&gt;h &lt; root-&gt;lchild-&gt;rchild-&gt;h)root-&gt;lchild = left_rotate(root-&gt;lchild);<span class="hljs-comment">//LL大右旋</span>root = right_rotate(root);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//RL先小右旋</span><span class="hljs-keyword">if</span>(root-&gt;rchild-&gt;rchild-&gt;h &lt; root-&gt;rchild-&gt;lchild-&gt;h)root-&gt;rchild = right_rotate(root-&gt;rchild);<span class="hljs-comment">//RR大左旋</span>root = left_rotate(root);&#125;<span class="hljs-keyword">return</span> root;&#125;<span class="hljs-function">Node * <span class="hljs-title">insert</span><span class="hljs-params">(Node * root, <span class="hljs-keyword">int</span> key)</span></span>&#123;<span class="hljs-keyword">if</span>(root == NIL)<span class="hljs-keyword">return</span> getNewNode(key);<span class="hljs-keyword">if</span>(root-&gt;key == key)<span class="hljs-keyword">return</span> root;<span class="hljs-keyword">if</span>(key &lt; root-&gt;key)root-&gt;lchild = insert(root-&gt;lchild, key);<span class="hljs-keyword">if</span>(key &gt; root-&gt;key)root-&gt;rchild = insert(root-&gt;rchild, key);update_height(root);<span class="hljs-keyword">return</span> maintain(root);&#125;<span class="hljs-comment">//寻找前驱节点,默认传入度为2的节点,前父节点有左子树</span><span class="hljs-function">Node * <span class="hljs-title">predeccessor</span><span class="hljs-params">(Node * root)</span></span>&#123;Node * tmp = root-&gt;lchild;<span class="hljs-keyword">while</span>(tmp-&gt;rchild)tmp = tmp-&gt;rchild;<span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-function">Node * <span class="hljs-title">erase</span><span class="hljs-params">(Node * root, <span class="hljs-keyword">int</span> key)</span></span>&#123;<span class="hljs-keyword">if</span>(root == NIL)<span class="hljs-keyword">return</span> NIL;<span class="hljs-keyword">if</span>(key &lt; root-&gt;key) &#123;root-&gt;lchild = erase(root-&gt;lchild, key);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root-&gt;key) &#123;root-&gt;rchild = erase(root-&gt;rchild, key);&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//删除当前节点</span><span class="hljs-keyword">if</span>(root-&gt;rchild == NIL || root-&gt;lchild == NIL)&#123;Node * tmp = root-&gt;rchild != NIL ? root-&gt;rchild : root-&gt;lchild;<span class="hljs-built_in">free</span>(root);<span class="hljs-keyword">return</span> tmp;&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 删除度为2的节点</span>Node * tmp = predeccessor(root);root-&gt;key = tmp-&gt;key;root-&gt;lchild = erase(root-&gt;lchild, root-&gt;key);&#125;&#125;update_height(root);<span class="hljs-keyword">return</span> maintain(root);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Node * root)</span></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d[%d], %d, %d)\n&quot;</span>,root-&gt;key, root-&gt;h,root-&gt;lchild-&gt;key,root-&gt;rchild-&gt;key);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Node * root)</span></span>&#123;<span class="hljs-keyword">if</span>(root == NIL)<span class="hljs-keyword">return</span>;print(root);output(root-&gt;lchild);output(root-&gt;rchild);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)</span></span>&#123;<span class="hljs-keyword">int</span> op, val;Node* root = NIL;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;op, &amp;val))&#123;<span class="hljs-keyword">switch</span>(op)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: root = erase(root, val); <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: root = insert(root, val); <span class="hljs-keyword">break</span>;&#125;output(root);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------------\n&quot;</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="tree" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/tree/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/06/HugeFour/DataStructrues/tree/BinarySearchTree/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/06/HugeFour/DataStructrues/tree/BinarySearchTree/</id>
    <published>2021-01-06T12:00:00.000Z</published>
    <updated>2021-01-08T15:24:23.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>名称 :</strong> 二叉排序树, 二叉搜索树</p><p><strong>性质 :</strong> </p><ol><li>左子树 &lt; 根节点</li><li>右子树 &gt; 根节点</li></ol><p><strong>用途 :</strong> 解决与排名有关的检索需求</p><p><strong>插入过程 :</strong> 根据插入节点值和根节点比较, 选择左子树或右子树继续比较, 最终放在叶子节点上</p><p><strong>删除过程 :</strong></p><ol><li><p>删除叶子节点</p><p> 直接删除</p></li><li><p>删除度为1的节点</p><p> 把孩子交给祖父节点</p></li><li><p>删除度为2的节点</p><p> 中序遍历 : 10 17 20 28 29 30 32</p><p> 性质 : 待删除节点的前驱无右子树, 后继无左子树, 因此前驱后继一定不是度为2的节点</p><p> 将前驱或后继直接覆盖待删除节点后, 问题转换为删除叶子节点或者是度为1的节点</p></li></ol><p><strong>优化 :</strong></p><ol><li>删除掉处理度为0的代码逻辑，不影响代码整体功能</li><li>解决排名相关的检索需求，修改二叉搜索树的定义，增加size字段，记录每棵树的节点数目<ol><li><code>K == LS - 1</code> : 根节点就是排名第k的元素</li><li><code>k &lt;= LS</code> : 排名第k位的元素在左子树中</li><li><code>k &gt; LS</code> : $search_k(root-&gt;rchild, k - LS - 1)$</li></ol></li><li>解决 top-k 问题，输出前k位的元素(找到小于第k位的所有元素)<ol><li>根节点就是第k位元素, 输出左子树所有节点和根节点值</li><li>第k位元素在左子树中, 前k位元素全部在左子树中</li><li>第k位元素在右子树中, 说明左子树中的所有节点和根节点都是前k位元素 </li></ol></li><li>二叉排序树和快速排序的关系<ol><li>二叉排序树是快速排序的逻辑结构</li><li>思考1: 快速排序算法的时间复杂度和二叉排序树建树时间复杂度之间的关系</li><li>思考2：快速选择算法和二叉排序树的关系</li></ol></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KEY(n)    (n ? n-&gt;key : 0)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE(n)   (n ? n-&gt;size : 0)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> L(n)      (n ? n-&gt;lchild : 0)</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><span class="hljs-keyword">int</span> key, size;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span>&#125;Node;<span class="hljs-comment">/*</span><span class="hljs-comment"> * 二叉搜索树的若干操作:</span><span class="hljs-comment"> * 1. 创建节点</span><span class="hljs-comment"> * 2. 销毁节点</span><span class="hljs-comment"> * 3. 查找</span><span class="hljs-comment"> * 4. 插入</span><span class="hljs-comment"> * 5. 删除</span><span class="hljs-comment">*/</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * 优化1: 将删除度为0和度为1的节点的代码合并</span><span class="hljs-comment"> * 优化2: 实现查找第k位的元素</span><span class="hljs-comment"> * 优化3: 实现输出前k位的元素(TOP-K)</span><span class="hljs-comment">*/</span><span class="hljs-comment">//更新树高</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update_size</span><span class="hljs-params">(Node * root)</span></span>&#123;root-&gt;size = SIZE(root-&gt;lchild) + SIZE(root-&gt;rchild) + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//创建节点</span><span class="hljs-function">Node * <span class="hljs-title">getNewNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;Node *p = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));p-&gt;key = key;p-&gt;size = <span class="hljs-number">1</span>;p-&gt;lchild = <span class="hljs-literal">nullptr</span>, p-&gt;rchild = <span class="hljs-literal">nullptr</span>;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-comment">//销毁树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node * root)</span></span>&#123;<span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span>;clear(root-&gt;lchild);clear(root-&gt;rchild);<span class="hljs-built_in">free</span>(root);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//查找</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(Node* root, <span class="hljs-keyword">int</span> val)</span></span>&#123;<span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(root-&gt;key == val)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(root-&gt;key &gt; val)<span class="hljs-keyword">return</span> search(root-&gt;lchild, val);<span class="hljs-keyword">if</span>(root-&gt;key &lt; val)    <span class="hljs-keyword">return</span> search(root-&gt;rchild, val);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//查找第k大的元素</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search_k</span><span class="hljs-params">(Node * root, <span class="hljs-keyword">int</span> k)</span></span>&#123;<span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(SIZE(L(root)) == k - <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> root-&gt;key;<span class="hljs-keyword">if</span>(k &lt;= SIZE(L(root)))&#123;<span class="hljs-keyword">return</span> search_k(root-&gt;lchild, k);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> search_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-comment">//插入</span><span class="hljs-function">Node * <span class="hljs-title">insert</span><span class="hljs-params">(Node * root, <span class="hljs-keyword">int</span> val)</span></span>&#123;<span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)    <span class="hljs-keyword">return</span> getNewNode(val);<span class="hljs-keyword">if</span>(root-&gt;key == val)<span class="hljs-keyword">return</span> root;<span class="hljs-keyword">if</span>(val &lt; root-&gt;key)     root-&gt;lchild = insert(root-&gt;lchild, val);<span class="hljs-keyword">if</span>(val &gt; root-&gt;key)     root-&gt;rchild = insert(root-&gt;rchild, val);update_size(root);<span class="hljs-keyword">return</span> root;&#125;<span class="hljs-comment">//寻找前驱(默认父节点有左孩子)</span><span class="hljs-function">Node * <span class="hljs-title">predecessor</span><span class="hljs-params">(Node * root)</span></span>&#123;Node * tmp = root-&gt;lchild;<span class="hljs-keyword">while</span>(tmp-&gt;rchild != <span class="hljs-literal">nullptr</span>)tmp = tmp-&gt;rchild;<span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-comment">//删除节点</span><span class="hljs-function">Node * <span class="hljs-title">erase</span><span class="hljs-params">(Node * root, <span class="hljs-keyword">int</span> val)</span></span>&#123;<span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<span class="hljs-keyword">if</span>(root-&gt;key &gt; val)root-&gt;lchild = erase(root-&gt;lchild, val);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;key &lt; val)root-&gt;rchild = erase(root-&gt;rchild, val);<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//删除节点本身</span>   <span class="hljs-comment">//删除度为0的节点和度为1的节点操作相同 </span><span class="hljs-keyword">if</span>(root-&gt;lchild == <span class="hljs-literal">nullptr</span> || root-&gt;rchild == <span class="hljs-literal">nullptr</span>)&#123;Node * tmp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;<span class="hljs-built_in">free</span>(root);<span class="hljs-keyword">return</span> tmp;&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//删除度为2的节点</span>Node * tmp = predecessor(root);root-&gt;key = tmp-&gt;key;root-&gt;lchild = erase(root-&gt;lchild, tmp-&gt;key);&#125;&#125;update_size(root);<span class="hljs-keyword">return</span> root;&#125;<span class="hljs-comment">//输出整棵树的所有节点 - 中序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Node * root)</span></span>&#123;<span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span>;output(root-&gt;lchild);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d, %d, %d, size : %d]\n&quot;</span>,KEY(root),KEY(root-&gt;lchild),KEY(root-&gt;rchild),SIZE(root));output(root-&gt;rchild);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//输出前k个节点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output_k</span><span class="hljs-params">(Node *root, <span class="hljs-keyword">int</span> k)</span></span>&#123;<span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span> || root == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(k &lt;= SIZE(L(root)))&#123;output_k(root-&gt;lchild, k);&#125; <span class="hljs-keyword">else</span> &#123;output(root-&gt;lchild);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d, %d, %d, size : %d]\n&quot;</span>,KEY(root),KEY(root-&gt;lchild),KEY(root-&gt;rchild),SIZE(root));output_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)</span></span>&#123;<span class="hljs-keyword">int</span> op, val;<span class="hljs-comment">/* op :</span><span class="hljs-comment"> * 0 查找</span><span class="hljs-comment"> * 1 插入</span><span class="hljs-comment"> * 2 删除</span><span class="hljs-comment"> * 3 查找第k位的元素</span><span class="hljs-comment"> * 4 输出前k位的元素</span><span class="hljs-comment">*/</span>Node * root = <span class="hljs-literal">nullptr</span>;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;op, &amp;val))&#123;<span class="hljs-keyword">switch</span>(op)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;search %d, result : %d\n&quot;</span>, val, search(root, val)); <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: root = insert(root, val); <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: root = erase(root, val); <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;search k %d, result : %d\n&quot;</span>,val, search_k(root, val)); <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output top-%d elements\n&quot;</span>,val);output_k(root, val);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------\n&quot;</span>);&#125; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span>(op != <span class="hljs-number">0</span> &amp;&amp; op != <span class="hljs-number">4</span>)&#123;output(root);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------\n&quot;</span>);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉排序树&quot;&gt;&lt;a href=&quot;#二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;二叉排序树&quot;&gt;&lt;/a&gt;二叉排序树&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;</summary>
      
    
    
    
    <category term="tree" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/tree/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 45. 把数组排成最小的数</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/18/leetcode/offer/%E5%89%91%E6%8C%87Offer%2045/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/18/leetcode/offer/%E5%89%91%E6%8C%87Offer%2045/</id>
    <published>2020-12-18T13:06:00.000Z</published>
    <updated>2020-12-18T13:11:01.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a>剑指 Offer 45. 把数组排成最小的数</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" title="leetcode链接">剑指 Offer 45. 把数组排成最小的数</a></p><p><strong>难度:</strong><font color="orange">中等</font></p><p><strong>描述</strong></p><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><a id="more"></a><p><strong>示例</strong></p><pre><code class="hljs cpp">输入: [<span class="hljs-number">10</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-string">&quot;102&quot;</span>    输入: [<span class="hljs-number">3</span>,<span class="hljs-number">30</span>,<span class="hljs-number">34</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]输出: <span class="hljs-string">&quot;3033459&quot;</span>限制:<span class="hljs-number">0</span> &lt; nums.length &lt;= <span class="hljs-number">100</span>输出结果可能非常大，所以你需要返回一个字符串而不是整数拼接起来的数字可能会有前导 <span class="hljs-number">0</span>，最后结果不需要去掉前导 <span class="hljs-number">0</span></code></pre><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>思路是, 因为每一个数字内的相对关系是不能改变的, 因此不能把数字拆分成各个数位做排序. 因此, 可以寻找数字排列先后的规律, 比如, <code>10</code> 和 <code>2</code> 两个数字可以组成 <code>102</code> 和 <code>210</code> , 但是 <code>102 &lt; 210</code> 因此, <code>10</code> 在前. 这就是一种排序规则. 可以写一个 lambda 表达式指导 <code>sort()</code> 按照刚刚模拟的方式来排序所有数字. 最后拼接到目标串中.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; strs;        <span class="hljs-built_in">string</span> res;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n : nums)            strs.push_back(to_string(n));        sort(strs.begin(),strs.end(),[](<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp; b)-&gt;<span class="hljs-keyword">bool</span>&#123;            <span class="hljs-keyword">return</span> a+b &lt; b+a; <span class="hljs-comment">// 102 &lt; 210</span>        &#125;);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> str : strs)            res += str;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-45-把数组排成最小的数&quot;&gt;&lt;a href=&quot;#剑指-Offer-45-把数组排成最小的数&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 45. 把数组排成最小的数&quot;&gt;&lt;/a&gt;剑指 Offer 45. 把数组排成最小的数&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/&quot; title=&quot;leetcode链接&quot;&gt;剑指 Offer 45. 把数组排成最小的数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;orange&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="剑指 Offer 专题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 29. 顺时针打印矩阵</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/15/leetcode/offer/%E5%89%91%E6%8C%87Offer%2029/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/15/leetcode/offer/%E5%89%91%E6%8C%87Offer%2029/</id>
    <published>2020-12-15T13:40:00.000Z</published>
    <updated>2020-12-18T13:06:04.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a>剑指 Offer 29. 顺时针打印矩阵</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" title="leetcode链接">剑指 Offer 29. 顺时针打印矩阵</a></p><p><strong>难度:</strong><font color="green">简单</font></p><p><strong>描述</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><a id="more"></a><p><strong>示例</strong></p><pre><code class="hljs cpp">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]    输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]]输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]限制:<span class="hljs-number">0</span> &lt;= matrix.length &lt;= <span class="hljs-number">100</span><span class="hljs-number">0</span> &lt;= matrix[i].length &lt;= <span class="hljs-number">100</span></code></pre><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>第一种思路是模拟法, 模拟我们正常地顺时针行走, 提供一个方向数组, 提前判断下一步会不会超出边界, 如果超出, 那么就转向, 也就是改变 <code>directionIndex</code> 的值, 因为可能会从北回到东, 所以需要 <code>mod 4</code> .</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 方向数组,东-南-西-北</span>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;        <span class="hljs-keyword">if</span>(matrix.size() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;        <span class="hljs-keyword">int</span> row = matrix.size(), col = matrix[<span class="hljs-number">0</span>].size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">visit</span><span class="hljs-params">(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(col, <span class="hljs-literal">false</span>))</span></span>;        <span class="hljs-keyword">int</span> total = row * col;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(total)</span></span>;        <span class="hljs-keyword">int</span> rows = <span class="hljs-number">0</span>, cols = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> directionIndex = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; total ; ++ i)&#123;            res[i] = matrix[rows][cols];            visit[rows][cols] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 已经访问过</span>            <span class="hljs-keyword">int</span> nextrow = rows + direction[directionIndex][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 下一个横坐标</span>            <span class="hljs-keyword">int</span> nextcol = cols + direction[directionIndex][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 下一个纵坐标</span>            <span class="hljs-comment">//判断下一个坐标是否合法或者是否访问过, 访问过就改变方向</span>            <span class="hljs-keyword">if</span>(nextrow &lt; <span class="hljs-number">0</span> || nextrow &gt;= row || nextcol &lt; <span class="hljs-number">0</span> || nextcol &gt;= col || visit[nextrow][nextcol])                directionIndex = (directionIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;            rows += direction[directionIndex][<span class="hljs-number">0</span>];            cols += direction[directionIndex][<span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>第二种思路是缩小边界法, 它一共是四个边界 <code>l</code> <code>r</code> <code>u</code> <code>d</code> 来表示, 当前 <code>left</code> <code>right</code> <code>up</code> <code>down</code> 四个边界.因为每一次都是沿着四条边移动, 而且每一次访问完一条边, 一定会有一条边界向内缩. 循环体里的 4 个 <code>if</code> 用于最终退出.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;        <span class="hljs-keyword">if</span>(matrix.size() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> r = matrix[<span class="hljs-number">0</span>].size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> d = matrix.size() - <span class="hljs-number">1</span>;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l ; i &lt;= r ; ++ i)  res.push_back(matrix[u][i]);            <span class="hljs-keyword">if</span>(++ u &gt; d)    <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = u ; j &lt;= d ; ++ j)  res.push_back(matrix[j][r]);            <span class="hljs-keyword">if</span>(-- r &lt; l)    <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r ; i &gt;= l ; -- i)  res.push_back(matrix[d][i]);            <span class="hljs-keyword">if</span>(-- d &lt; u)    <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = d ; j &gt;= u ; -- j)  res.push_back(matrix[j][l]);            <span class="hljs-keyword">if</span>(++ l &gt; r)    <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-29-顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#剑指-Offer-29-顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 29. 顺时针打印矩阵&quot;&gt;&lt;/a&gt;剑指 Offer 29. 顺时针打印矩阵&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/&quot; title=&quot;leetcode链接&quot;&gt;剑指 Offer 29. 顺时针打印矩阵&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="剑指 Offer 专题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/11/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/11/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-12-11T11:13:00.000Z</published>
    <updated>2020-12-11T11:18:25.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a><blockquote><p>  内存管理是一个很深刻的话题, 对于初学者来说, 内存管理看不到摸不着, 我们常使用 new / delete 来管理我们的堆内存. 仅此而已.</p></blockquote></p><p>本文记录了侯捷老师内存管理课程的学习笔记以及部分自己写的代码.</p><p>目的是了解C++如何进行内存管理, 剖析源码, 能够设计自己的内存池.</p><h2 id="C-中内存管理工具"><a href="#C-中内存管理工具" class="headerlink" title="C++中内存管理工具"></a>C++中内存管理工具</h2><table><thead><tr><th>分配</th><th>释放</th><th>类型</th><th>是否可以重载</th></tr></thead><tbody><tr><td>malloc()</td><td>free()</td><td>C函数</td><td>不可以</td></tr><tr><td>new</td><td>delete</td><td>C++表达式</td><td>不可以</td></tr><tr><td>::operator new()</td><td>::operator delete()</td><td>C++函数</td><td>可以</td></tr><tr><td>allocator&lt;T&gt;::allocate()</td><td>allocator&lt;T&gt;::deallocate()</td><td>C++标准库</td><td>可自由设计并搭配容器</td></tr></tbody></table><p>用法示例</p><pre><code class="hljs cpp"><span class="hljs-keyword">void</span>* p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">512</span>); <span class="hljs-comment">//512 bytes</span><span class="hljs-built_in">free</span>(p1);<span class="hljs-built_in">complex</span>&lt;<span class="hljs-keyword">int</span>&gt;* p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">complex</span>&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">//one object</span><span class="hljs-keyword">delete</span> p2;<span class="hljs-keyword">void</span>* p3 = ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-number">512</span>); <span class="hljs-comment">//512 bytes</span>::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p3)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __GUNC__ <span class="hljs-comment">//GNUC 2.9</span></span><span class="hljs-keyword">void</span>* p4 = alloc::allocate(<span class="hljs-number">512</span>);alloc::deallocate(p4,<span class="hljs-number">512</span>); <span class="hljs-comment">//得记得当初申请了多少的内存,比较适用于容器</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-comment">/*************************/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __GNUC__ <span class="hljs-comment">//GNUC 4.9</span></span><span class="hljs-comment">//allocate() 和 deallocate() 是 non-static 必须由 object 调用</span><span class="hljs-keyword">void</span>* p4 = allocator&lt;<span class="hljs-keyword">int</span>&gt;().allocate(<span class="hljs-number">7</span>); <span class="hljs-comment">//分配7个int的内存大小</span>allocator&lt;<span class="hljs-keyword">int</span>&gt;().deallocate((<span class="hljs-keyword">int</span>*)p4, <span class="hljs-number">7</span>);<span class="hljs-comment">//allocate() 和 deallocate() 是 non-static 必须由 object 调用</span><span class="hljs-keyword">void</span>* p5 = __gnu_cxx::__pool_alloc&lt;<span class="hljs-keyword">int</span>&gt;().allocate(<span class="hljs-number">9</span>); <span class="hljs-comment">//分配9个int的内存大小</span>__gnu_cxx::__pool_alloc&lt;<span class="hljs-keyword">int</span>&gt;().deallocate((<span class="hljs-keyword">int</span>*)p5, <span class="hljs-number">9</span>);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><h2 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h2><pre><code class="hljs cpp">Complex* pc = <span class="hljs-keyword">new</span> Complex(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);编译器转换→Complex *pc;<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">void</span>* mem = <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">sizeof</span>(Complex)); <span class="hljs-comment">//allocate</span>pc = <span class="hljs-keyword">static_cast</span>&lt;Complex*&gt;(mem);           <span class="hljs-comment">//cast</span>pc-&gt;Complex::Complex(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);                 <span class="hljs-comment">//construct</span><span class="hljs-comment">//只有编译器才能够像上式直接调用 ctor</span>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">std</span>::bad_alloc) &#123;<span class="hljs-comment">//allocate 失败, 不执行 ctor</span>&#125;</code></pre><h2 id="operator-new-vc98默认版本"><a href="#operator-new-vc98默认版本" class="headerlink" title="operator new() vc98默认版本"></a>operator new() vc98默认版本</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::nothrow t&amp;)</span> _<span class="hljs-title">THROW0</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123; <span class="hljs-comment">//try to allocate size bytes</span><span class="hljs-keyword">void</span> *p;<span class="hljs-keyword">while</span>((p == <span class="hljs-built_in">malloc</span>(size)) == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//buy more memory or return null pointer</span>_TRY_BEGIN<span class="hljs-keyword">if</span>(_callnewh(size) == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;_CATCH(<span class="hljs-built_in">std</span>::bad_alloc)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;_CATCH_END&#125;<span class="hljs-keyword">return</span> (p);&#125;</code></pre><h2 id="delete-运算符"><a href="#delete-运算符" class="headerlink" title="delete 运算符"></a>delete 运算符</h2><pre><code class="hljs cpp">Complex* pc = <span class="hljs-keyword">new</span> Complex(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);...<span class="hljs-keyword">delete</span> pc;编译器转换-&gt;pc-&gt;~Complex();        <span class="hljs-comment">//先析构</span><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pc)</span></span>;   <span class="hljs-comment">//然后释放内存</span></code></pre><h2 id="operator-delete-vc98默认版本"><a href="#operator-delete-vc98默认版本" class="headerlink" title="operator delete() vc98默认版本"></a>operator delete() vc98默认版本</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> __cdecl <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * p)</span> _<span class="hljs-title">THROW0</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123; <span class="hljs-comment">//free an allocated object</span><span class="hljs-built_in">free</span>(p);&#125;</code></pre><h2 id="array-new-array-delete"><a href="#array-new-array-delete" class="headerlink" title="array new / array delete"></a>array new / array delete</h2><pre><code class="hljs cpp">Complex * pca = <span class="hljs-keyword">new</span> Complex[<span class="hljs-number">3</span>];<span class="hljs-comment">//触发三次ctor</span>...<span class="hljs-keyword">delete</span> [] pca; <span class="hljs-comment">//触发三次dtor</span></code></pre><p>内存分配的时候, 头部会有 cookie 方便回收.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> * pi = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<span class="hljs-keyword">delete</span> pi;vc6 : cookie<span class="hljs-number">61</span>h(记录大小是<span class="hljs-number">60</span>字节,<span class="hljs-number">1</span>表示使用了这一块)<span class="hljs-function">Debugger <span class="hljs-title">Header</span><span class="hljs-params">(<span class="hljs-number">32</span> Bytes)</span></span><span class="hljs-function"><span class="hljs-keyword">int</span></span><span class="hljs-function"><span class="hljs-keyword">int</span></span><span class="hljs-function"><span class="hljs-keyword">int</span></span>...<span class="hljs-keyword">int</span>no man landPad(<span class="hljs-number">12</span> Bytes)<span class="hljs-number">61</span>h</code></pre><h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><pre><code class="hljs gauss"><span class="hljs-keyword">new</span> (p)</code></pre><p>允许我们在已经申请的堆内存上, 构建一个对象.</p><p>placement new 没有对应的 placement delete, 因为 placement new操作并没有分配内存.</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> * buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-keyword">sizeof</span>(Complex)*<span class="hljs-number">3</span>];Complex * pc = <span class="hljs-keyword">new</span> (buf) Complex(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);...<span class="hljs-keyword">delete</span> [] buf;编译器-&gt;Complex * pc;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">void</span> * mem = <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">sizeof</span>(Complex), buf); <span class="hljs-comment">//实际上不操作</span>pc = <span class="hljs-keyword">static_cast</span>&lt;Complex*&gt;(mem);                 <span class="hljs-comment">//cast</span>pc-&gt;Complex::Complex(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);                       <span class="hljs-comment">//construct</span>&#125;</code></pre><h2 id="C-应用程序分配内存的途径"><a href="#C-应用程序分配内存的途径" class="headerlink" title="C++应用程序分配内存的途径"></a>C++应用程序分配内存的途径</h2><p><strong>应用程序</strong></p><pre><code class="hljs cpp">Foo *p = <span class="hljs-keyword">new</span> Foo(x);<span class="hljs-keyword">delete</span> p;编译器-&gt;不可以改变不可以重载Foo *p = (Foo*)<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">sizeof</span>(Foo));<span class="hljs-keyword">new</span> (p) Foo(x);p-&gt;~Foo();<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(x)</span></span>;</code></pre><p><strong>operator new / operator delete</strong></p><pre><code class="hljs cpp">Foo *p = (Foo*)<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">sizeof</span>(Foo));调用 -&gt; ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span>;调用 -&gt; <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">size_t</span>);<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(x)</span></span>;调用 -&gt; ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*)</span></span>;调用 -&gt; <span class="hljs-built_in">free</span>(<span class="hljs-keyword">void</span>*);</code></pre><p><strong>在类中重载 <code>operator new</code> 和 <code>operator delete</code></strong></p><pre><code class="hljs cpp">Foo *p = (Foo*)<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">sizeof</span>(Foo));重载 <span class="hljs-function">Foo::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span>; -&gt; 调用 ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(x)</span></span>;重载 <span class="hljs-function">Foo::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*)</span></span>; -&gt; 调用 ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*)</span></span>;</code></pre><h2 id="C-容器分配内存的途径"><a href="#C-容器分配内存的途径" class="headerlink" title="C++容器分配内存的途径"></a>C++容器分配内存的途径</h2><p><strong>容器</strong></p><pre><code class="hljs cpp">T *p = allocate();construct();destroy();deallocate(p);</code></pre><p><strong>分配器</strong></p><pre><code class="hljs cpp">allocate();deallocate();调用 -&gt; ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">or</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span></code></pre><h2 id="重载-operator-new-operator-delete"><a href="#重载-operator-new-operator-delete" class="headerlink" title="重载 ::operator new / ::operator delete"></a>重载 ::operator new / ::operator delete</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-title">myAlloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myFree</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * ptr)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">free</span>(ptr);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;global new()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> myAlloc(size);&#125;<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-keyword">size_t</span> size)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;global new[]&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> myAlloc(size);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * ptr)</span></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;global delete()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;myFree(ptr);&#125;<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span> * ptr)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;global delete[]&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;myFree(ptr);&#125;</code></pre><h2 id="重载-operator-new-operator-delete-1"><a href="#重载-operator-new-operator-delete-1" class="headerlink" title="重载 operator new / operator delete"></a>重载 operator new / operator delete</h2><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-comment">/*重载这两个函数应该是 static, 编译器默认*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span>   <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">size_t</span>)</span></span>; <span class="hljs-comment">//第二参数 optional</span>&#125;;Foo *p = <span class="hljs-keyword">new</span> Foo;编译器-&gt;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">void</span> * mem = <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">sizeof</span>(Foo)); <span class="hljs-comment">//此处调用类中重载的 operator new</span>p = <span class="hljs-keyword">static_cast</span>&lt;Foo*&gt;(mem);p-&gt;Foo::Foo(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//使用 ::delete p; 可以绕过重载的 operator delete</span>编译器-&gt;p-&gt;~Foo();<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">//此处调用类中重载的 operator delete</span></code></pre><h2 id="重载-placement-new-placement-delete"><a href="#重载-placement-new-placement-delete" class="headerlink" title="重载 placement new / placement delete"></a>重载 placement new / placement delete</h2><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><span class="hljs-comment">/* 1,2默认版本; 3,4重载版本;*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>&#123; <span class="hljs-comment">// 调用 new Foo</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span> * start)</span></span>&#123; <span class="hljs-comment">// 调用 new (&amp;) Foo</span><span class="hljs-keyword">return</span> start;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">long</span> extra)</span></span>&#123; <span class="hljs-comment">// 调用 new (100) Foo</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size + extra);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">long</span> extra, <span class="hljs-keyword">char</span> init)</span></span>&#123; <span class="hljs-comment">//调用 new(100,&#x27;a&#x27;) Foo</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size + extra);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">** placement new 重载时, 第一参数必须为 size_t</span><span class="hljs-comment">** 否则, [Error] &#x27;operator new&#x27; takes type &#x27;size_t&#x27;(unsigned int) </span><span class="hljs-comment">** as first parameter</span><span class="hljs-comment">*/</span><span class="hljs-comment">/*</span><span class="hljs-comment">** placement delete 重载时, 不会被 delete 调用</span><span class="hljs-comment">** 除非 new 的时候抛出异常, 才会去调用对应的重载的 operator delete()</span><span class="hljs-comment">*/</span>&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; targe</summary>
      
    
    
    
    <category term="C++" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"/>
    
    <category term="内存管理" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 - 数组</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/10/HugeFour/DataStructrues/01%E6%95%B0%E7%BB%84%20vector/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/10/HugeFour/DataStructrues/01%E6%95%B0%E7%BB%84%20vector/</id>
    <published>2020-12-10T11:42:00.000Z</published>
    <updated>2020-12-10T11:48:45.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-数组"><a href="#数据结构-数组" class="headerlink" title="数据结构 - 数组"></a>数据结构 - 数组</h1><p>该篇是数据结构的开篇. 数据结构学习拟定计划是学习 &lt;&lt;数据结构与算法 C++描述&gt;&gt; by Sartaj Sahni 的同时, 阅读 &lt;&lt;STL源码剖析&gt;&gt; by 侯捷, 完成对应数据结构在STL中的实现.</p><p>这一篇主要是 vector 的实现.</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的特性较为简单, 在内存空间中连续, 存储同一类型元素, 查询时间复杂度为<code>O(1)</code>, 插入删除时间复杂度为<code>O(n)</code>. 数据与数据的关系只有先后关系.</p><h2 id="vector-未完成"><a href="#vector-未完成" class="headerlink" title="vector(未完成)"></a>vector(未完成)</h2><pre><code class="hljs cpp"><span class="hljs-comment">// linear.c</span><span class="hljs-comment">//</span><span class="hljs-comment">// Created by OXygen on 2020/12/9.</span><span class="hljs-comment">//</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;linear.h&quot;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myvector</span> &#123;</span><span class="hljs-keyword">protected</span>:<span class="hljs-keyword">typedef</span> _Tp           value_type;<span class="hljs-keyword">typedef</span> value_type*    pointer;<span class="hljs-keyword">typedef</span> pointer        iterator;<span class="hljs-keyword">typedef</span> _Tp&amp;           reference;<span class="hljs-keyword">private</span>:iterator start;iterator finish;iterator end_of_storage;<span class="hljs-keyword">public</span>:<span class="hljs-comment">// Construction &amp; Deconstruction</span>myvector() &#123; start = finish = end_of_storage = <span class="hljs-literal">nullptr</span>; &#125;myvector(<span class="hljs-keyword">int</span> capacity, value_type initElem = <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">if</span>(capacity &gt; <span class="hljs-number">0</span>) initalloc(capacity,initElem); &#125;myvector(<span class="hljs-keyword">const</span> myvector&amp; LeftVector) &#123;<span class="hljs-keyword">int</span> size = LeftVector.size();<span class="hljs-keyword">this</span>-&gt;resize(size);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size ; ++ i)&#123;<span class="hljs-keyword">this</span>[i] = LeftVector[i];&#125;&#125;<span class="hljs-comment">//myvector(myvector &amp;&amp; RightVector) noexcept &#123;&#125;</span>~myvector() &#123;<span class="hljs-keyword">this</span>-&gt;clear();start = finish = end_of_storage = <span class="hljs-literal">nullptr</span>;&#125;;<span class="hljs-comment">// Operations</span>myvector &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> myvector &amp; LeftVector) &#123;<span class="hljs-keyword">if</span>(&amp;LeftVector == <span class="hljs-keyword">this</span>)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-keyword">if</span>(start != <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">this</span>-&gt;clear();&#125;<span class="hljs-keyword">int</span> size = LeftVector.size();<span class="hljs-keyword">this</span>-&gt;resize(size);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size ; ++ i)&#123;<span class="hljs-keyword">this</span>[i] = LeftVector[i];&#125;<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">//myvector &amp; operator=(myvector &amp;&amp; RightVector) noexcept &#123;&#125;</span><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> myvector &amp; LeftVector) &#123;<span class="hljs-keyword">if</span>(&amp;LeftVector == <span class="hljs-keyword">this</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;size() != LeftVector.size())<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-keyword">this</span>-&gt;size() ; ++ i)&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>[i] != LeftVector[i])<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> myvector &amp; LeftVector) &#123;<span class="hljs-keyword">return</span> !<span class="hljs-keyword">operator</span>==(LeftVector);&#125;<span class="hljs-comment">// Capacity</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> (finish - start);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> (end_of_storage - start);&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;size() == <span class="hljs-number">0</span>);&#125;<span class="hljs-comment">// Visit</span><span class="hljs-function">value_type <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//empty应该抛出异常</span><span class="hljs-keyword">return</span> *begin();&#125;<span class="hljs-function">value_type <span class="hljs-title">back</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//empty应该抛出异常</span><span class="hljs-keyword">return</span> *(end() - <span class="hljs-number">1</span>);&#125;<span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> start;&#125;<span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> finish;&#125;<span class="hljs-comment">// Modifiers</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(iterator location, value_type InsertElem)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(iterator location)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(iterator _begin, iterator _end)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(value_type PushElem)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">emplace_back</span><span class="hljs-params">(value_type PushElem)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-keyword">private</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initalloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, value_type Elem)</span></span>&#123;start = <span class="hljs-keyword">new</span> value_type[capacity];iterator it = start;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; capacity ; ++ i, ++ it) &#123;*it = Elem;&#125;end_of_storage = it + <span class="hljs-number">1</span>;finish = it;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">growalloc</span><span class="hljs-params">()</span></span>&#123;&#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构-数组&quot;&gt;&lt;a href=&quot;#数据结构-数组&quot; class=&quot;headerlink&quot; title=&quot;数据结构 - 数组&quot;&gt;&lt;/a&gt;数据结构 - 数组&lt;/h1&gt;&lt;p&gt;该篇是数据结构的开篇. 数据结构学习拟定计划是学习 &amp;lt;&amp;lt;数据结构与算法 C++描</summary>
      
    
    
    
    <category term="vector" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/vector/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 14- I. 剪绳子</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/07/leetcode/offer/%E5%89%91%E6%8C%87Offer%2014%20I/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/07/leetcode/offer/%E5%89%91%E6%8C%87Offer%2014%20I/</id>
    <published>2020-12-07T13:40:00.000Z</published>
    <updated>2020-12-07T13:46:11.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a>剑指 Offer 14- I. 剪绳子</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" title="leetcode链接">剑指 Offer 14- I. 剪绳子</a></p><p><strong>难度:</strong><font color="orange">中等</font></p><p><strong>描述</strong></p><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]*k[1]*…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><a id="more"></a><p><strong>示例</strong></p><pre><code class="hljs cpp">输入: <span class="hljs-number">2</span>输出: <span class="hljs-number">1</span>解释: <span class="hljs-number">2</span> = <span class="hljs-number">1</span> + <span class="hljs-number">1</span>, <span class="hljs-number">1</span> × <span class="hljs-number">1</span> = <span class="hljs-number">1</span>    输入: <span class="hljs-number">10</span>输出: <span class="hljs-number">36</span>解释: <span class="hljs-number">10</span> = <span class="hljs-number">3</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span>, <span class="hljs-number">3</span> × <span class="hljs-number">3</span> × <span class="hljs-number">4</span> = <span class="hljs-number">36</span></code></pre><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这样的题目, 适合先枚举多个例子找规律.</p><p>我们枚举到6,7,8的时候, 应该可以感受到, 每个数需要尽量地拆分多的数字<code>3</code>, 但是最终拆分剩下<code>4</code>的时候, 需要转换成<code>2+2</code>.</p><p>我们不需要循环地去重复 : <code>n -= 3</code> 和 <code>res *= 3 </code> , 因为, 这样的循环可以计算出运算的次数.</p><p>使用<code>count  = n / 3</code> 得知以上的循环会进行多少次, <code>count % 3</code> 得知以上的循环会剩下什么数.</p><p>如果剩下的数字是 <code>1</code>  说明我们把<code>4</code>拆分成了<code>3+1</code>, 所以回退一步, 结果为<code>pow(3, count - 1) * 4</code></p><p>如果剩下的数字是 <code>0</code>  说明这个数字<code>n</code>可以全部拆分成<code>3</code>, 所以结果为<code>pow(3, count)</code></p><p>如果剩下的数字是 <code>2</code>  说明结果为<code>pow(3, count) * 2</code></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-comment">/*</span><span class="hljs-comment"></span><span class="hljs-comment">        2 : 1 + 1 -&gt; 1</span><span class="hljs-comment">        3 : 2 + 1</span><span class="hljs-comment">        4 : 2 + 2</span><span class="hljs-comment">        5 : 3 + 2</span><span class="hljs-comment">        6 : 3 + 3</span><span class="hljs-comment">        7 : 3 + 2 + 2</span><span class="hljs-comment">        8 : 3 + 3 + 2</span><span class="hljs-comment">        </span><span class="hljs-comment">        */</span>        <span class="hljs-keyword">if</span>( n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>)   <span class="hljs-keyword">return</span> (n - <span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> count = n / <span class="hljs-number">3</span>;        <span class="hljs-keyword">int</span> rest = n % <span class="hljs-number">3</span>;        <span class="hljs-keyword">return</span> (rest == <span class="hljs-number">1</span>) ? <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, count - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span> : (rest == <span class="hljs-number">0</span>) ? <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, count) : rest * <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, count);    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-14-I-剪绳子&quot;&gt;&lt;a href=&quot;#剑指-Offer-14-I-剪绳子&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 14- I. 剪绳子&quot;&gt;&lt;/a&gt;剑指 Offer 14- I. 剪绳子&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/jian-sheng-zi-lcof/&quot; title=&quot;leetcode链接&quot;&gt;剑指 Offer 14- I. 剪绳子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;orange&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]*k[1]*…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="剑指 Offer 专题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2020.12.07 861. 翻转矩阵后的得分</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/07/leetcode/daily/861.%20%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/07/leetcode/daily/861.%20%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/</id>
    <published>2020-12-07T13:00:00.000Z</published>
    <updated>2020-12-07T13:21:15.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="861-翻转矩阵后的得分"><a href="#861-翻转矩阵后的得分" class="headerlink" title="861. 翻转矩阵后的得分"></a>861. 翻转矩阵后的得分</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/score-after-flipping-matrix/" title="leetcode链接">861. 翻转矩阵后的得分</a></p><p><strong>难度:</strong><font color="orange">中等</font></p><p><strong>描述</strong></p><p>有一个二维矩阵 A 其中每个元素的值为 0 或 1 。</p><p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p><p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p><p>返回尽可能高的分数。</p><a id="more"></a><p><strong>示例</strong></p><pre><code class="hljs cpp">输入 : [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]输出 : <span class="hljs-number">39</span>解释 :转换为 [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<span class="hljs-number">0b1111</span> + <span class="hljs-number">0b1001</span> + <span class="hljs-number">0b1111</span> = <span class="hljs-number">15</span> + <span class="hljs-number">9</span> + <span class="hljs-number">15</span> = <span class="hljs-number">39</span>提示 :<span class="hljs-number">1</span> &lt;= A.length &lt;= <span class="hljs-number">20</span><span class="hljs-number">1</span> &lt;= A[<span class="hljs-number">0</span>].length &lt;= <span class="hljs-number">20</span>A[i][j] 是 <span class="hljs-number">0</span> 或 <span class="hljs-number">1</span></code></pre><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>首先, <code>16</code>一定比<code>8</code>大. 也就是说, 最高位的<code>b1</code>一定比低位的<code>b1</code>表示的数字要大. 因此, 可以通过反转行, 来使得最高位是<code>b1</code>. 其次, 行已经达到最优的情况, 该反转列了, 列的反转结果会导致<code>b0</code>和<code>b1</code>的数量交换, 因此, 如果一列上<code>b1</code>的数量大于<code>b0</code>时, 不需要反转, 否则反转.</p><p>经过行列反转后, 达到最优解. 计算结果.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">matrixScore</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = A.size();        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = A[<span class="hljs-number">0</span>].size();        <span class="hljs-comment">// 反转行</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; ++ i)&#123;            <span class="hljs-keyword">if</span>(A[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//首位是0才需要行反转</span>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; ++ j)&#123;                    A[i][j] = A[i][j] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 反转列</span>        <span class="hljs-keyword">int</span> mid = (m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; ++ j)&#123;            count = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; ++ i)&#123;                count += A[i][j];            &#125;            <span class="hljs-keyword">if</span>(count &lt; mid)&#123; <span class="hljs-comment">//1的数量小于一半时才需要列反转</span>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; ++ i)                    A[i][j] = A[i][j] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;                                &#125;        &#125;        <span class="hljs-comment">// 计算</span>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; ++ i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; ++ j)&#123;                res += A[i][j] * <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">1</span> - j);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;861-翻转矩阵后的得分&quot;&gt;&lt;a href=&quot;#861-翻转矩阵后的得分&quot; class=&quot;headerlink&quot; title=&quot;861. 翻转矩阵后的得分&quot;&gt;&lt;/a&gt;861. 翻转矩阵后的得分&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/score-after-flipping-matrix/&quot; title=&quot;leetcode链接&quot;&gt;861. 翻转矩阵后的得分&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;orange&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一个二维矩阵 A 其中每个元素的值为 0 或 1 。&lt;/p&gt;
&lt;p&gt;移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。&lt;/p&gt;
&lt;p&gt;在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。&lt;/p&gt;
&lt;p&gt;返回尽可能高的分数。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="每日一题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>仓库介绍</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/24/github/%E4%BB%93%E5%BA%93%E4%BB%8B%E7%BB%8D/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/24/github/%E4%BB%93%E5%BA%93%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-11-24T06:56:00.000Z</published>
    <updated>2020-11-24T14:06:41.085Z</updated>
    
    <content type="html"><![CDATA[<center><bold>深入理解操作系统课程学习 - 清华大学</bold>    <br><font size="1.5">    记录清华大学深入理解操作系统课程学习的笔记    </font></center><left><a href="https://github.com/OXygenPanda/Deep_into_OperatingSystem" target="_blank"><img src="https://img.shields.io/badge/Github-@Deep_into_OperatingSystem-f3e1e1.svg?style=flat-square&logo=GitHub"></a></left>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;bold&gt;
深入理解操作系统课程学习 - 清华大学
&lt;/bold&gt;
    &lt;br&gt;
&lt;font size=&quot;1.5&quot;&gt;
    记录清华大学深入理解操作系统课程学习的笔记
    &lt;/font&gt;
&lt;/center&gt;

&lt;left&gt;
&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="github" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/github/"/>
    
    
    <category term="github" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机网络</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/23/HugeFour/Network/Deep_into_Network/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/23/HugeFour/Network/Deep_into_Network/</id>
    <published>2020-11-23T11:20:00.000Z</published>
    <updated>2020-12-06T13:31:13.039Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a></p> <h1 id="计算机网络学习"><a href="#计算机网络学习" class="headerlink" title="计算机网络学习"></a>计算机网络学习</h1><p>本文章记录着小劳的计算机网络学习, 从2020.11.22开始学习, 目标能够掌握概念, 对网络编程有一个偏底层的理解. 学习自韩立刚老师的b站课程.</p><p>传送门 : <a class="btn" href="https://www.bilibili.com/video/BV17p411f7ZZ?p=1" title="传送门">b站 韩立刚 计算机网络</a></p><a id="more"></a><p><code>custom</code></p><h1 id="计算机网络-第一章"><a href="#计算机网络-第一章" class="headerlink" title="计算机网络 第一章"></a>计算机网络 第一章</h1><blockquote><p>  计算机网络第一章的主要内容是 : 概述</p></blockquote><h2 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h2><p>第一章 : 概述</p><p>第二章 : 物理层</p><p>第三章 : 数据链路层</p><p>第四章 : 网络层</p><p>第五章 : 运输层</p><p>第六章 : 应用层</p><p>第七章 : 网络安全</p><p>第八章 : 因特网上的音频,视频服务</p><p>第九章 : 无线网络</p><p>第十章 : 下一代因特网</p><h2 id="计算机网络在信息时代的作用"><a href="#计算机网络在信息时代的作用" class="headerlink" title="计算机网络在信息时代的作用"></a>计算机网络在信息时代的作用</h2><p>21世纪的特征 : 数字化, 网络化, 信息化</p><p>网络化 : 三网(电信网络, 计算机网络, 有线电视网络)</p><p>计算机网络 : 因特网, 其他网络(政府网络, 军用网络)</p><h3 id="计算机网络的重要功能"><a href="#计算机网络的重要功能" class="headerlink" title="计算机网络的重要功能"></a>计算机网络的重要功能</h3><p>连通性 : 彼此联通, 交换信息</p><p>共享 : 信息共享, 软硬件共享(软 : ssh ; 硬 : 打印机等设备)</p><h2 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2><p>终端到网络(路由器)的距离大约是100米, 路由器与路由器的连接扩展了网络的距离和接入网设备的数量.</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>网络 : 许多计算机连接在一起</p><p>互联网 : 许多网络连接在一起 (internet)</p><p>因特网 : 全球最大的一个互联网 (Internet, 使用 TCP/IP 协议)</p><h3 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h3><p>1st : ARPANET向互联网发展 (上世纪60年代 - 80 年代中期)</p><ul><li>1969年 分组交换网</li><li>1975年 互联网</li><li>1983年 TCP/IP (因特网起源)</li></ul><p>2nd : 三级结构的因特网 (上世纪80年代中期 - 90 年代初期)</p><ul><li>分层次, 比如 : 学校网 - 区域网 - 主干网(带宽 : 45 M)</li></ul><p>3rd : 多层次ISP结构的因特网</p><ul><li>ISP : Internet Service Provider 因特网服务提供商</li><li>第一层ISP - 第二层ISP - 第三层ISP(提供接入) - 校园网等</li><li>如果服务器需要提供的客户范围较小, 应该接入越低层的ISP</li></ul><h3 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h3><p>因特网协会 : ISOC</p><p>因特网体系结构委员会 IAB :</p><ul><li>因特网研究部 IRTF :<ul><li>因特网研究指导小组 IRSG</li></ul></li><li>因特网工程部 IETF :<ul><li>因特网工程指导小组 IESG</li></ul></li></ul><h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><p><strong>因特网的核心部分</strong></p><p><strong>因特网的边缘部分</strong></p><p>主机之间的通信方式 :</p><ul><li>客户端服务器方式 (Client / Server 方式)</li><li>对等方式 (Peer-to-Peer 方式)</li></ul><p>数据交换方式 :</p><ul><li>电路交换 (Circuit Switching)<ul><li>交换机同时只能提供网络中的两个终端通信</li><li>过程 : 申请占用通信资源, 一直占用通信资源, 释放通信资源</li><li>适用于 : 实时性通信, 核心路由器之间可以使用电路交换</li></ul></li><li>报文交换 (Message Switching)<ul><li>报文一般比分组长的多</li><li>报文交换的时延较长</li></ul></li><li>分组交换 (Packet Switching)<ul><li>完整的一个数据包称为报文, 需要分为多个组进行发送</li><li>每一个分组带上一个首部</li><li>分组的优势在于, 通信时路径可以复用</li><li>接收端去电首部后, 拼接分组成报文</li><li>路由器有存储转发功能</li><li>优点 : 高效, 灵活, 迅速, 可靠</li><li>问题 : 时延, 开销</li></ul></li></ul><h2 id="计算机在我国的发展"><a href="#计算机在我国的发展" class="headerlink" title="计算机在我国的发展"></a>计算机在我国的发展</h2><p>中国在1994年4月20日正式接入互联网.</p><h2 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h2><p>计算机网络最简单的定义 : 一些互相连接的, 自治的计算机的集合</p><p>作用范围(使用的技术) :</p><p>广域网 : WAN (花钱买服务, 花钱买带宽</p><p>城域网 : MAN</p><p>局域网 : LAN (自己购买设备, 带宽固定, 自己维护, 距离100米之内)</p><p>使用者 : 公用网, 专用网</p><p>拓扑结构 : 总线型, 环型, 星型, 树型, 网状</p><p>交换方式 : 电路交换, 报文交换, 分组交换</p><p>工作方式 : 资源子网, 通信子网, 接入网</p><h2 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h2><p>以下5点是性能指标 :</p><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>速率是指连接在计算机网络上的主机在<strong>数字信道</strong>上传送数据位数的速率, 也称为 data rate 或者 bit rate. 单位是 b/s kb/s Mb/s Gb/s</p><p>一般来说, 运营商告诉的100M是指100Mbps, 转换成下行速率是 100 / 8 = 12.5 Mbit / s</p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>带宽是指数据通信领域中, <strong>数字信道</strong>所能传送的最高速率</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>吞吐量是指在单位时间内通过<strong>某个网络</strong>的数据量</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p><p>发送时延 = 数据块长度(比特) / 信道带宽(比特/秒)</p><p>传播时延 = 信道长度(米) / 信号在信道上的传播速率(米/秒)</p><p>处理时延 = 网络节点存储转发处理时间</p><p>排队时延 = 网络节点缓存队列排队时间</p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>信道利用率 = 有数据通过时间 / (有 + 无) 数据通过时间</p><p>网络利用率 = 信道利用率加权平均值</p><p>D = D0 / (1 - U) [D0 : 网络空闲时延 D : 网络当前时延 U : 信道利用率]</p><p>以下7点是非性能指标 : 费用, 质量, 标准化, 可靠性, 可扩展性, 可升级性, 管理与维护</p><h2 id="计算机网络的体系机构"><a href="#计算机网络的体系机构" class="headerlink" title="计算机网络的体系机构"></a>计算机网络的体系机构</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>ISO : 国际标准化组织</p><p>OSI/RM : 互联网法律上的国际标准</p><p>TCP/IP Suite : 因特网事实上的国际标准</p><p>Network Protocols : 数据交换遵守的规则, 标准或约定</p><p>网络体系结构 : 计算机网络各层及协议的集合</p><h3 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h3><p><strong>OSI 是七层模型 :</strong></p><p>​    应用层 - 能够产生网络流量, 能够和用户交互的应用程序</p><p>​    表示层 - 加密, 压缩, 编解码 (开发人员考虑)</p><p>​    会话层 - 服务和客户端建立的会话 查木马 netstat -nb | more</p><p>​    传输层 - 可靠传输建立会话, 不可靠传输不建立会话(QQ发消息, DNS解析), 流量控制</p><p>​    网络层 - IP地址编址 选择最佳路径 动态路由</p><p>​    链路层 - 数据如何封装 为数据包添加物理层地址(MAC地址)</p><p>​    物理层 - 电压 接口标准</p><p><strong>分层的作用 :</strong> 1.标准化 ; 2.降低耦合度</p><p>开发者考虑应用层到会话层, 网络工程师考虑传输层到链路层</p><p><strong>网络排错 :</strong> 从底层往上检查(比如 : 先看网线, IP, 浏览器检查)</p><p><strong>网络安全和OSI参考模型 :</strong></p><p>​    物理层安全 - 给别人提供了接入网络的机会</p><p>​    链路层安全 - ADSL密码, 无线网卡密码</p><p>​    网络层安全 - 网关设置内网中某些网段可以访问外网, 某一些不可以</p><p>​    应用层安全 - SQL注入漏洞, 上传漏洞(文件类型检查)</p><h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p><strong>TCP/IP 是五层模型 :</strong></p><p>​    应用层</p><p>​    传输层</p><p>​    网络层</p><p>​    链路层</p><p>​    物理层</p><p><strong>开放系统信息交换涉及的概念 :</strong></p><p>实体 : 交换信息的硬件和软件的进程</p><p>协议 : 控制两个对等实体通信的规则</p><p>服务 : 下层向上层提供服务, 上层需要使用下层提供的服务来实现本层的功能</p><p>服务访问点 : 相邻两层实体间交换信息的地方</p><p><strong>TCP/IP 模型的数据单元 :</strong></p><p>​    应用层 - 传输数据单元 PDU</p><p>​    运输层 - 运输层报文</p><p>​    网络层 - IP数据报(IP分组)</p><p>​    数据链路层 - 数据帧</p><p>​    物理层 - bits</p><h1 id="计算机网络-第二章"><a href="#计算机网络-第二章" class="headerlink" title="计算机网络 第二章"></a>计算机网络 第二章</h1><p>由于是物理层, 暂时先跳过学习</p><h1 id="计算机网络-第三章"><a href="#计算机网络-第三章" class="headerlink" title="计算机网络 第三章"></a>计算机网络 第三章</h1><blockquote><p>  第三章的主要内容是 : 数据链路层</p></blockquote><h2 id="数据链路层基本概念及基本问题"><a href="#数据链路层基本概念及基本问题" class="headerlink" title="数据链路层基本概念及基本问题"></a>数据链路层基本概念及基本问题</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>数据发送模型 :</p><ul><li>主机1 - 电话网 - 路由器1 - 局域网 - 路由器2 - 广域网 - 路由器3 - 局域网 - 主机2.</li><li>在路由器上数据上升到网络层, 再进行转发.</li></ul><p>数据链路层的信道类型 :</p><ul><li>点对点信道</li><li>广播信道</li></ul><p>链路与数据链路 :</p><ul><li>链路 (link) 是一条点对点的物理线路段</li><li>数据链路 (data link) 除了物理线路外, 还必须有通信协议来控制这些数据的传输</li></ul><p>帧 :</p><ul><li>链路层传输的数据单元</li><li>获得网络层的数据报增加帧头和帧尾, 传递给物理层</li></ul><h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><ol><li><p>封装成帧(一定要知道哪里开始哪里结束)</p><p>封装成帧就是在一段数据的前后分别添加首部和尾部, 然后就构成一个帧, 确定帧的边界.</p><p>首部和尾部的一个重要作用就是进行帧定界.</p><p>帧的数据部分长度最大为1500字节.</p><p>帧首部和帧尾部定界的作用 : 确保数据的完整性</p></li><li><p>透明传输(数据中存在开始和结束的标识, 进行转变)</p><p>在帧数据部分出现了SOH帧首部或EOT帧尾部内容, 会出现提前结束.</p><p>解决方法 :</p><ul><li>发送端的数据链路层在数据中出现控制字符”SOH”或者”EOT”的前面插入转义字符”ESC”(十六进制编码为1B).</li><li>字节填充或字符填充——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符.</li><li>如果转义字符也出现在数据中, 那么应该在转义字符前插入一个转义字符. 当接收端收到连续的两个转义字符时, 就删除前面一个.</li></ul></li><li><p>差错控制(检查帧的正确性)</p><p>传输过程中可能会产生比特差错 : 1 可能会变成 0 , 0 可能会变成 1.</p><p>在一段时间内, 传输错误的比特占所传输比特总数的比率称为误码率 BER (bit error rate).</p><p>误码率与信噪比有很大的关系.</p><p>为了保证数据传输的可靠性, 在计算机网络传输数据时, 必须采用各种差错检测措施.</p><p>循环冗余检验 CRC :</p><ul><li>在数据链路层传送的帧中, 广泛使用了 CRC 的技术.</li><li>在发送端, 先把数据划分为组. 假定每组为 k 个比特</li><li>假设待传送的一组数据 M = 101001 (k = 6), 我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送.</li><li>101001 - 000 (增加3位0, 要求除数是4位) / 1101 = 001 (FCS) , 把001加在101001后面, 组成 101001001 , 接收方除以相同的四位数 1101, 如果最终结果是 0 , 说明没有出错. 这个四位数 1101 或者更多位的数, 是链路层保证双方相同的.</li><li>链路层的差错控制, 是无差错接收, 只接受没有比特差错的情况, 不需要重传.(重传是传输层的要求)</li></ul><p>帧检验序列 FCS :</p><ul><li>在数据后面添加上的冗余码称为帧检验序列 FCS.</li><li>循环冗余检验 CRC 和帧检验序列 FCS 并不等同. (CRC 不是获得 FCS 的唯一途径)</li></ul></li></ol><h2 id="两种情况下的数据链路层"><a href="#两种情况下的数据链路层" class="headerlink" title="两种情况下的数据链路层"></a>两种情况下的数据链路层</h2><h3 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h3><p><strong>PPP协议( Pointer-to-Pointer Protocol)</strong></p><p>用户使用拨号电话线接入因特网的时候, 一般都是使用PPP协议. 具有拨号, 身份验证, 可以记账的特性.</p><p><strong>PPP协议应该满足的要求 :</strong> 简单, 封装成帧, 透明性, 多层网络层协议, 多种类型链路, 差错检测, 检测连接状态, 最大传送单元, 网络层地址协商, 数据压缩协商.</p><p><strong>PPP协议不需要满足的要求 :</strong> 纠错, 流量控制, 序号, 多点线路, 半双工或单工链路.</p><p><strong>PPP协议的组成 :</strong></p><ul><li>数据链路层协议可以用于异步串行或同步串行介质.</li><li>它使用LCP(链路控制协议)建立并维护数据链路连接.</li><li>网络控制协议(NCP)允许在点到点连接上使用多种网络层协议.</li></ul><p>|3. 上层协议 : IP IPX AppleTalk |</p><p>|2. 网络控制协议 NCP 针对每一个网络层协议 |</p><p>|2. 链路控制协议 LCP |</p><p>|2. 高级数据链路控制协议 HDLC |</p><p>|1. 物理层 |</p><p><strong>PPP协议帧格式 :</strong></p><p>首部 : | F{1} | A{1} | C{1} | 协议{2} | . 其中, A,C = FF,03 是固定的. 一般 首部和尾部的 : F(=7E)</p><ul><li>协议{2} :<ul><li>0x0021 - PPP帧的信息字段就是IP数据报</li><li>0xC021 - 信息字段是PPP链路控制数据</li><li>0x8021 - 网络控制数据</li><li>0xC023 - 安全性认证PAP</li><li>0xC025 - LQR</li><li>0xC223 - 安全性认证CHAP</li></ul></li></ul><p>数据部分 : IP数据报不超过1500字节.</p><p>尾部 : | FCS{2} | F{1} | . PPP协议的头尾的 F(=7E) 字段相同.</p><p>使用PPP协议以字节为单位还是以比特为单位发送数据时, 填充方案不相同, 具体如下 :</p><p><strong>字节填充 :</strong></p><ul><li>信息字段出现标志字段的值的问题 : 信息字段的 0x7E 被拆分称为0x7D 0x5E, 信息字段的 0x7D 被拆分成0x7D 0x5D, ASCII 控制符(数值小于0x20)前加一个 0x7D 字节.(因此实际传输的信息可能是达不到1500字节)</li></ul><p><strong>零比特填充方法 :</strong></p><ul><li>避免出现和 0x7E 一样的比特序列, 0111,1110, 因此连续5个1补一个0</li><li>PPP协议用在SONET/SDH链路时, 是使用同步传输一连串的比特连续传送). 这时, PPP协议采用零比特填充方法来实现透明传输.</li><li>在发送端, 只要连续发现5个连续的1, 就立即填充一个0. 接收端扫描时, 5个连续的1后删除1个0.(可以用于避免0x7E的出现)</li></ul><p><strong>PPP协议的工作状态 :</strong></p><ul><li>当用户拨号接入ISP时, 路由器的调制解调器对拨号做出确认, 并建立一条物理连接.</li><li>PC机向路由器发送一系列的LCP分组(封装成多个PPP帧).</li><li>这些分组及其响应选择一些PPP参数, 和进行网络层配置, NCP给新接入的PC机分配一个临时的IP地址, 使PC机称为因特网上的一个主机.</li><li>通信完毕时, NCP释放网络层连接, 收回原来分配出去的IP地址. 接着, LCP释放数据链路层连接. 最后释放的是物理层连接.</li></ul><h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><p><strong>补充知识 : 局域网的特定与优点</strong></p><p>局域网最主要的特点是 : 网络为一个单位所拥有, 且地理范围和结点数目均有限.</p><p>局域网具有如下的一些主要优点 :</p><ul><li>具有广播功能, 从一个站点可以很方便地访问全网. 局域网上的主机可以共享连接在局域网上的各种硬件和软件资源.</li><li>便于系统的扩展和逐渐地演变, 各设备的位置可灵活调整和改变.</li><li>提高了系统的可靠性, 可用性和生存性.</li></ul><p><strong>共享通信媒体</strong></p><p>静态划分信道 : 频分复用, 时分复用, 波分复用, 码分复用.</p><p>动态媒体接入控制(多点接入) : 随机接入(被以太网采用), 受控接入(已不被采用)</p><p><strong>认识以太网</strong></p><p>最初的以太网是将许多计算机都连接在一根总线上. 当初认为这样的链接方式既简单又可靠, 因为总线上没有有源器件. 问题是, 同时只有一个设备发送数据, 而且所有的设备都可以接收到数据包, 不够安全.</p><p><strong>以太网协议 :</strong></p><p>以太网使用的是CSMA/CD协议 (带冲突检测的多点接入技术)</p><p>多点接入 : 表示许多计算机以多点接入的方式连接在一根总线上</p><p>载波监听 : 是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据, 如果有, 则暂时不要发送数据, 以免碰撞.</p><p><em>(P35 以太网的冲突检测暂时跳过)</em></p><h2 id="以太局域网"><a href="#以太局域网" class="headerlink" title="以太局域网"></a>以太局域网</h2><p><strong>以太网的两个标准 :</strong></p><ol><li>DIX Ethernet V2 是世界上第一个局域网产品(以太网)的规约.</li><li>IEEE 的 802.3 标准.</li></ol><p><strong>以太网与数据链路层的两个子层 :</strong></p><p>为了使数据链路层能更好地适应多种局域网标准, 802 委员会就将局域网的数据链路层拆成两个子层 :</p><ol><li>逻辑链路控制 LLC 子层</li><li>媒体接入控制 MAC 子层</li></ol><p><strong>以太网提供的服务 :</strong></p><p>以太网提供的服务是不可靠的交付, 即尽最大努力的交付.</p><p>当接收站收到有差错的数据帧时就丢弃此帧, 其他什么都不做. 差错的纠正由高层来决定.</p><p>如果高层发现丢弃一些数据而进行重传, 但以太网并不知道这是一个重传的帧, 而是当做一个新的数据帧来发送.</p><p><em>(集线器部分暂时跳过)</em></p><p>以太网的<strong>信道利用率 :</strong></p><p>以太网的信道被占用的情况 :</p><p>争用期长度为 2tao , 即端到端传播时延的两倍. 检测到碰撞后不发送干扰信号.</p><p>帧长为 L (bit) , 数据发送速率为 C (b/s) , 因而帧的发送时间为 L/C = T0 (s)</p><p>信道利用率的最大值 : 各站发送数据都不发生碰撞的话, Smax = T0 / (T0 + tao)</p><p><strong>MAC层 :</strong></p><p>在局域网中, 硬件地址又称为物理地址, 或 MAC 地址.</p><p>MAC地址一共是48位二进制位, 其中高24位为厂家地址段, 低24位由厂家自行指派.</p><p>适配器检查MAC地址 :</p><p>适配器从网络上每收到一个MAC帧就首先用硬件检查MAC帧中的MAC地址 :</p><ul><li>如果是发送往本站的帧则手下, 然后再进行其他的处理.</li><li>否则就将此帧丢弃, 不再进行其他的处理.</li></ul><p>“发往本站的帧” 包括以下三种类型的帧 :</p><ol><li>单播帧 (一对一)</li><li>广播帧 (一对全体) (MAC地址全1)</li><li>多播帧 (一对多)</li></ol><p><strong>以太网帧格式 :</strong></p><p>MAC帧 : | 目的地址{6} | 源地址{6} | 类型{2} | IP数据报{46 - 1500} | FCS{4} |  最短是64字节</p><p>物理层 : | 前同步码{7} | 帧开始定界符{1} | MAC帧 |</p><p><strong>无效的MAC帧 :</strong></p><ul><li>帧的长度不是整数个字节;</li><li>用收到的帧检验序列 FCS 查出有差错;</li><li>数据字段的长度不在 46 ~ 1500 字节之间;</li><li>有效的MAC帧长度为 64 ~ 1518 字节之间;</li><li>对于检查出的无效的MAC帧就简单地丢弃. 以太网不负责重传丢弃的帧.</li></ul><p><strong>帧间最小间隔 :</strong></p><p>帧间最小间隔为 9.6 us , 相当于 96 bit 的发送时间.</p><p>一个站在检测到总线开始空闲时, 还要等待 9.6 us 才能再次发送数据.</p><p>这样做是为了使刚刚收到的数据帧的站的接收缓存来得及清理, 做好接收下一帧的准备.</p><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><p>集线器<strong>扩展 :</strong> 主机使用光纤和一对光纤调制解调器连接到集线器. 使用集线器连接最好低于30台机器, 冲突域变少, 冲突增大.</p><p><strong>网桥扩展 :</strong> 在一个较小的冲突域里收发数据, 网桥不会转发到其他冲突域中, 可以减少冲突. 网桥有自学习算法并且建立转发表.</p><p>透明网桥使用了生成树算法 : 为了避免产生转发的帧在网络中不断地兜圈子.</p><p><strong>交换机(多接口的高速网桥)扩展 :</strong> 安全, 效率高, 10M的交换机指的是每一个端口都是10M, 每一个端口都是全双工</p><p>交换机学习到的转发表格式 : | Vlan | Mac Address | Type | Ports |</p><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p><strong>LAN和VLAN :</strong></p><p>交换机的使用使得VLAN的创建成为可能.</p><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组.</p><ul><li>这些网段具有某些共同的需求.</li><li>每一个 VLAN 的帧都有一个明确的标识符, 指明发送这个帧的工作站是属于哪一个 VLAN.</li></ul><p>虚拟局域网其实只是局域网给用户提供的一种服务, 而不是一种新型局域网.</p><p>一个 VLAN = 一个广播域 = 逻辑网段(子网)</p><p><strong>ISL 标记(思科方式) :</strong></p><p>ISL 干道使 VLAN 能够跨骨干</p><ul><li>通过特定集成电路来实现</li><li>不需要再客户计算机上采取配置, 客户机不能够看到ISL头</li><li>在交换机之间, 路由器和交换机, 交换机和支持ISL网卡的服务器之间配置</li></ul><p>ISL 封装 : | DA | Type | User | SA | LEN | AAAA03 | HSA | VLAN | BPDU | INDEX | RES | 以太网帧 | CRC |</p><p><strong>虚拟局域网帧格式 :</strong></p><p>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符, 称为 VLAN 标记 (tag) , 用来指明发送该帧的工作站属于哪一个虚拟局域网.</p><p>格式 : | 目的地址{6} | 源地址{6} | VLAN标记{4} | 类型{2} | 数据{46 ~ 1500} | FCS{4} |</p><h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><p>速率达到或超过 100 Mb/s 的以太网称为高速以太网.</p><p><strong>100BASE-T 以太网 :</strong> 可以全双工方式下工作而无冲突发生. 因此, 不使用 CSMA/CD 协议. MAC帧格式仍然是 802.3 标准规定的. 帧间时间间隔从 9.6 us 变成了 0.96 us.</p><p><strong>吉比特以太网 :</strong> 允许在1 Gb/s 下全双工和半双工两种方式工作. 使用 802.3 协议规定的帧格式. 在半双工方式下使用 CSMA/CD 协议, 全双工不需要. 与 10BASE-T 和 100BASE-T 技术向后兼容.</p><p><strong>10吉比特以太网 :</strong> 以太网的工作范围已经从局域网(校园网, 企业网)扩大到城域网和广域网, 从而实现了端到端的以太网传输. 这种工作方式的好处是 : 成熟的技术, 互操作性好, 在广域网中使用以太网时价格便宜, 统一的帧格式简化了操作和管理.</p><h3 id="Cisco建网3层模型"><a href="#Cisco建网3层模型" class="headerlink" title="Cisco建网3层模型"></a>Cisco建网3层模型</h3><p>普通的交换机 : 连接计算机, 需要接口数量多</p><p>汇聚层交换机 : 连接普通的交换机, 一般单位是整栋楼</p><p>核心层交换机 : 连接汇聚层交换机, 一般单位是一个一个区域</p><h3 id="交换机安全"><a href="#交换机安全" class="headerlink" title="交换机安全"></a>交换机安全</h3><p>交换机可以设置某一个端口只能和指定的MAC地址的主机交换数据, 保证链路层安全. 也可以设置某个端口只能连接一台计算机. 否则, 关闭端口.</p><h1 id="计算机网络-第四章"><a href="#计算机网络-第四章" class="headerlink" title="计算机网络 第四章"></a>计算机网络 第四章</h1><blockquote><p>  第四章的主要内容是 : 网络层</p></blockquote><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><p>网络层关注的是如何将分组从源端沿着网络路径送达目的端.</p><p>两种服务 :</p><ol><li>虚电路服务</li><li>数据报服务</li></ol><h3 id="虚电路-专线-固定-不需要写IP地址"><a href="#虚电路-专线-固定-不需要写IP地址" class="headerlink" title="虚电路(专线,固定. 不需要写IP地址)"></a>虚电路(专线,固定. 不需要写IP地址)</h3><p>虚电路表示这是一条逻辑上的连接, 分组都沿着这条逻辑连接按照存储转发方式传送, 而并不是真正建立了一条物理连接. 电路交换的电话通信是先建立一条真正的连接. 因此分组交换的虚连接和电路交换的连接只是类似, 并不完全一样.</p><h3 id="数据报-灵活-低耦合-需要写IP地址"><a href="#数据报-灵活-低耦合-需要写IP地址" class="headerlink" title="数据报(灵活,低耦合. 需要写IP地址)"></a>数据报(灵活,低耦合. 需要写IP地址)</h3><p>网络层向上只提供简单灵活的, 无连接的, 尽最大努力交付的数据报服务. 网络在发送分组时不需要先建立连接. 每一个分组(IP数据报)独立发送, 与其前后的分组无关. 网络层不提供服务质量的承诺. 即所传送的分组可能出错, 丢失, 重复和失序, 当然也不保证分组传送的时限.</p><p>尽最大努力交付的好处 :</p><ul><li>由于传输网络不提供端到端的可靠传输服务, 这就使网络中的路由器可以做的比较简单, 而且价格低廉.</li><li>如果主机中的进程通信需要是可靠的, 那么就由网络的主机中的运输层负责(包括差错处理, 流量控制等).</li><li>采用这种设计思路的好处是 : 网络的造价大大降低, 运行方式灵活, 能够适应多种应用.</li><li>因特网能够发展到今日的规模, 充分证明了当初采用这种设计思路的正确性.</li></ul><h3 id="虚电路服务和数据报服务的比较"><a href="#虚电路服务和数据报服务的比较" class="headerlink" title="虚电路服务和数据报服务的比较"></a>虚电路服务和数据报服务的比较</h3><p><strong>虚电路</strong></p><p>思路 : 可靠通信应当由网络来保证</p><p>连接的建立 : 必须有</p><p>终点地址 : 仅在连接建立阶段使用, 每个分组使用短的虚电路号</p><p>分组的转发 : 属于同一条虚电路的分组均按照同一路由进行转发</p><p>当结点出故障时 : 所有通过出故障的结点的虚电路均不能工作</p><p>分组的顺序 : 总是按发送顺序到达终点</p><p>端到端的差错处理和流量控制 : 可以由网络负责, 也可以由用户主机负责</p><p><strong>数据报</strong></p><p>思路 : 可靠通信应当由用户主机来保证</p><p>连接的建立 : 不需要</p><p>终点地址 : 每个分组都有终点的完整地址</p><p>分组的转发 : 每个分组独立选择路由进行转发</p><p>当结点出故障时 : 由故障的结点可能会丢失分组, 一些路由可能会发生变化</p><p>分组的顺序 : 到达终点时不一定按发送顺序</p><p>端到端的差错处理和流量控制 : 由用户主机负责</p><h2 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h2><h3 id="虚拟互联网"><a href="#虚拟互联网" class="headerlink" title="虚拟互联网"></a>虚拟互联网</h3><p><strong>网络互连的设备</strong></p><p>中间设备又称为中间系统或者中继系统.</p><ul><li>物理层中继系统 : 转发器 或者 集线器</li><li>数据链路层中继系统 : 网桥 或者 交换机</li><li>网络层中继系统 : 路由器</li><li>网络层以上的中继系统 : 网关</li></ul><p>当中继系统是集线器或网桥时, 一般不称为网络互连, 因为这仅仅是把一个网络扩大了, 而这仍然是一个网络.</p><p>网关由于比较复杂, 目前使用的较少.</p><p>互联网都是指用路由器进行互连的网络.</p><p>由于历史原因, 许多有关 TCP/IP 的文献将网络层使用的路由器称为网关.</p><p><strong>网络互联的问题</strong></p><p>互联在一起的网络要进行通信, 会遇到许多问题需要解决, 如 : 不同的寻址方案, 不同的最大分组长度, 不同的网络接入机制, 不同的超时控制, 不同的差错恢复方法, 不同的状态报告方法, 不同的路由选择技术, 不同的用户接入控制, 不同的服务, 不同的管理与控制方式.</p><p><strong>IP协议简介</strong></p><p>网际协议IP 是 TCP/IP 体系中两个最主要的协议之一. 与 IP协议配合使用的还有四个协议 :</p><ol><li>地址解析协议 ARP <em>(Address Resolution Protocol)</em></li><li>逆地址解析协议 RARP <em>(Reserve Address Resolution Protocol)</em></li><li>网际控制报文协议 ICMP <em>(Internet Control Message Protocol)</em></li><li>网际组管理协议 IGMP <em>(Internet Group Management Protocol)</em></li></ol><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p><strong>IP层次结构</strong></p><p>层次化IP地址 : 层次化IP地址将32位的IP地址分为网络ID和主机ID</p><p><strong>网络地址</strong></p><p>网络地址唯一指定了每一个网络. 同一网络中的每台计算机都共享相同的网络地址, 并用它作为自己IP地址的一部分.</p><p>A类地址 : 8位网络号 (net-id : 0…….)</p><ul><li>最大网络数 126 第一个可用的网络号 1 最后一个可用的网络号 127 每个网络的最大主机数 16777214</li></ul><p>B类地址 : 16位网络号(net-id : 10…… ……..)</p><ul><li>最大网络数 16383 第一个可用的网络号 128.1 最后一个可用的网络号 191.255 每个网络的最大主机数 65534</li></ul><p>C类地址 : 24位网络号(net-id : 110….. …….. ………)</p><ul><li>最大网络数 2097151 第一个可用的网络号 192.0.1 最后一个可用的网络号 223.255.255 每个网络的最大主机数 254</li></ul><p>D类地址 : 组播 (1110 28.)</p><p>E类地址 : 研究 (1111 28.)</p><p>特殊的几个地址 : ****</p><p>127.0.0.1 本地回环地址</p><p>169.254.0.0 无法自动分配地址时,分配这个网段</p><p>RFC1918指明的专用地址(private address):</p><ul><li>10.0.0.0 - 10.255.255.255</li><li>172.16.0.0 - 172.31.255.255</li><li>192.168.0.0 - 192.168.255.255</li></ul><p><strong>子网掩码</strong></p><p>子网掩码的作用是确定IP地址的网络号的位数.</p><h3 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h3><p><strong>划分子网</strong></p><p>划分子网可以让一个网络号继续拆分出多个子网, 使得使用更加地充分.</p><p>比如, 一个C类地址的网络号是24位, 可以容纳254台主机, 可以进一步使用第25位主机号用于子网络号, 拆分126台和126台主机的两个子网.同时, 子网掩码也要往后移动一位.</p><p>划分四个子网时, 取2位作为子网络号, 因此可以用的主机号范围是 :</p><p>A: (0网络) 1 - 62 (63广播)</p><p>B: 65 - 126</p><p>C: 129 - 190</p><p>D: 192 - 254</p><p>网关是主机号为1的IP地址, 是路由器的出口IP地址.</p><p>广播是主机号为最大的IP地址.</p><p>最小划分到, 网络号为24位,子网络号为6位,主机号为2位: 00网络,01网关,02主机,03广播.</p><p><strong>构造超网</strong></p><p>将网络号左移若干位, 可以构造超网.</p><h3 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h3><p>使用IP地址通信, 而不是直接使用MAC地址通信, 是因为, IP地址可以确定源地址和目标地址, 而MAC地址在每一次转发的时候都需要改变. 除非没有网络层设备, 所有主机全部使用超大的交换机相连, 每一次广播都可以得知目标MAC地址的主机进行转发.</p><p><strong>ARP协议</strong></p><p>IP地址 → ARP → MAC地址</p><p>ARP欺骗: 在同一个网段里的计算机在需要知道一个IP地址的MAC地址时,会进行广播, 这个时候本应只有网关会回复你, 但是有其他主机告诉你MAC地址的话, 你就会受到ARP欺骗, 他把他自己作为”网关”, 可以控制每一个主机的带宽.</p><p><strong>RARP协议</strong></p><p>MAC地址 → RARP → IP地址(地址请求的过程)</p><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p>首部{20} | 数据部分</p><p>首部{20} :</p><p>| 版本{4b} | 首部长度{4b} | 区分服务{1} | 总长度{2} |</p><p>| 标识{2} | 标志{3b} | 片偏移{29b} |</p><p>| 生存时间{1} | 协议{1} | 首部检验和{2} |</p><p>| 源地址{4} |</p><p>| 目的地址{4} |</p><p>可变部分 : | 可选字段 | 填充至4字节的整数倍 |</p><p>| 数据部分 |</p><p>版本 : 4位,指定IP协议版本(IPv4, IPv6)</p><p>首部长度 : 4位,除数据部分以外的首部有多长(4位能够表示0-15,一个数代表4个字节,因此最大值为60字节)</p><p>区分服务 : 8位,只有使用区分服务,该字段才起作用.</p><p>总长度 : 16位,首部和数据之和的长度.(因此最大值为65535字节,不能超过最大传送单元MTU)</p><p>标识 : 16位,计数器,用来产生数据报的标识,不是序号,每产生一个数据包+1</p><p>标志 : 3位,目前只有前两位有意义,标志字段的最低位是MF.MF=1标识后面还有分片,MF=0标识后面没有分片.标识字段中间位是DF,只有DF=0才允许分片.</p><p>片偏移 : 13位,较长的分组在分片后,某片在原分组中的相对位置,片偏移以8个字节为偏移单位.比如1400/8 = 175</p><p>生存时间 : 8位,记为TTL,经过路由器的C++最大跳数</p><p>协议 : 8位,标记数据报携带的数据使用的协议</p><p>首部校验和 : 16位,用于检错,反码算术运算求和</p><p>可变部分 : 支持排错,测量以及安全等措施,1字节-40字节,很少被用到.</p><h3 id="IP转发分组的流程"><a href="#IP转发分组的流程" class="headerlink" title="IP转发分组的流程"></a>IP转发分组的流程</h3><p>数据路由: 路由器在不同网段转发数据报</p><p>网络畅通的条件: 能去能回,沿途的路由器都必须知道到源地址和目标地址网络下一跳给哪个接口</p><h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><h3 id="ICMP简介"><a href="#ICMP简介" class="headerlink" title="ICMP简介"></a>ICMP简介</h3><p>为了提高IP数据报交付成功的机会,在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol)</p><p>ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告</p><p>ICMP不是高层协议,而是IP层协议</p><p>ICMP报文作为IP层数据报的数据,加上数据报的首部,组成IP数据报发送出去.</p><h3 id="ICMP种类"><a href="#ICMP种类" class="headerlink" title="ICMP种类"></a>ICMP种类</h3><p>ICMP报文的种类有两种,即ICMP差错报告报文和ICMP询问报文.</p><p>ICMP的前4个字节是统一的格式,共有三个字段: 即类型,代码和检验和.接着的4个字节的内容与ICMP的类型有关.</p><p><strong>差错报告报文(ping指令收到的是差错报告)</strong></p><p>有五种: 终点不可达,源点抑制,时间超过,参数问题,改变路由(重定向)</p><p><strong>询问报文(ping指令发送的是询问)</strong></p><p>有两种: 回送请求和回答报文,时间戳请求和回答报文</p><h3 id="ping的过程"><a href="#ping的过程" class="headerlink" title="ping的过程"></a>ping的过程</h3><p>A —ping—&gt; B</p><p>A 创建一个数据报, 格式如: | IP数据报首部 | 8字节 | IP数据报的数据字段(前面的8字节也属于IP数据报数据) |</p><p>B 收到ICMP询问报文后, 丢弃8字节以外的IP数据报的数据字段,组装ICMP的前8字节, 格式如: | 首部 | ICMP前8字节 | IP数据报首部 | 8字节 | 再发送给 A</p><h2 id="因特网的路由选择协议"><a href="#因特网的路由选择协议" class="headerlink" title="因特网的路由选择协议"></a>因特网的路由选择协议</h2><h3 id="RIP动态路由协议"><a href="#RIP动态路由协议" class="headerlink" title="RIP动态路由协议"></a>RIP动态路由协议</h3><p>RIP协议最早, 每30秒周期性地广播, 每一个目的地告诉相邻路由器0跳能到自己,路由器告诉相邻路由器1跳能到,然后不断地告诉其他路由器,如果某一条路径断开,30秒之后又能重新选择到一条通路.(依据跳数不一定是最佳路径,有一些跳数大的路径带宽大)</p><h3 id="OSPF内部网关协议"><a href="#OSPF内部网关协议" class="headerlink" title="OSPF内部网关协议"></a>OSPF内部网关协议</h3><p>向本自治系统中所有路由器发送信息,这里使用的方法是洪泛法. 发送的信息就是与本路由器相邻的所有路由器的链路状态, 但这是路由器所知道的部分信息. 只有当链路状态发生变化时,路由器才用洪泛法向所有路由器发送此信息.</p><p>相比RIP协议,OSPF是触发式更新路由表.</p><p>OSPF维护三个表:</p><ol><li>邻居表 hello包(局域网2s一次)</li><li>链路状态表 互相交换邻居表,构造网络拓扑图</li><li>计算路由表 迪杰斯特拉算法来计算最短路径,路径值是带宽</li></ol><h3 id="BGP外部网关协议"><a href="#BGP外部网关协议" class="headerlink" title="BGP外部网关协议"></a>BGP外部网关协议</h3><p>BGP是不同自治系统的路由器之间交换路由信息的协议.边界网关协议BGP只能是力求寻找一条能够到达目的网络且较好的路由(不能成环),而非寻找一条最佳的路径.每一个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人.</p><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>VPN: 在互联网上传输私网数据, 因为私网数据不能在广域网上传输,所以在数据报前面再增加一个目标网络网关的目标地址和自己的网关源地址. 目标网关获得数据报之后解析得到一个数据报,目标地址是私网中的某个主机.</p><p>例如:</p><p>局域网数据报: | 10.0.0.2 | 10.0.0.8 | 数据 |</p><p>广域网数据报: | 23.23.2.2 | 23.23.2.20 | 10.0.0.2 | 10.0.0.8 | 数据 |</p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>1994年提出.</p><p>需要在专用网连接到因特网的路由器上安装NAT软件. 装有NAT软件的路由器叫做NAT路由器.它至少有一个有效的外部全球地址IPg.  所有使用本地地址的主机和外界通信时都要在NAT路由器上将其本地地址转换成IPg才能和因特网连接.</p><p>私网里的IP和端口号都被NAT路由器进行了转换,端口使用的是NAT的端口,存储一张IP与端口映射表即可.</p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;Website&quot; src=&quot;https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&amp;logo=Blogger&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://www.github.com/OXygenPanda&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&amp;logo=GitHub&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&amp;logo=WeChat&quot;&gt;&lt;/a&gt;
&lt;/p&gt; 




&lt;h1 id=&quot;计算机网络学习&quot;&gt;&lt;a href=&quot;#计算机网络学习&quot; class=&quot;headerlink&quot; title=&quot;计算机网络学习&quot;&gt;&lt;/a&gt;计算机网络学习&lt;/h1&gt;&lt;p&gt;本文章记录着小劳的计算机网络学习, 从2020.11.22开始学习, 目标能够掌握概念, 对网络编程有一个偏底层的理解. 学习自韩立刚老师的b站课程.&lt;/p&gt;
&lt;p&gt;传送门 : &lt;a class=&quot;btn&quot; href=&quot;https://www.bilibili.com/video/BV17p411f7ZZ?p=1&quot; title=&quot;传送门&quot;&gt;b站 韩立刚 计算机网络&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 13. 机器人的运动范围</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/20/leetcode/offer/%E5%89%91%E6%8C%87Offer%2013/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/20/leetcode/offer/%E5%89%91%E6%8C%87Offer%2013/</id>
    <published>2020-11-20T13:30:00.000Z</published>
    <updated>2020-11-24T13:49:51.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a>剑指 Offer 13. 机器人的运动范围</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" title="leetcode链接">剑指 Offer 13. 机器人的运动范围</a></p><p><strong>难度:</strong><font color="orange">中等</font></p><p><strong>描述</strong></p><p>地上有一个m行n列的方格，从坐标<code> [0,0]</code> 到坐标<code> [m-1,n-1]</code> 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><a id="more"></a><p><strong>示例</strong></p><pre><code class="hljs cpp">输入：m = <span class="hljs-number">2</span>, n = <span class="hljs-number">3</span>, k = <span class="hljs-number">1</span>输出：<span class="hljs-number">3</span>输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>输出：<span class="hljs-number">1</span>限制:<span class="hljs-number">1</span> &lt;= n,m &lt;= <span class="hljs-number">100</span><span class="hljs-number">0</span> &lt;= k &lt;= <span class="hljs-number">20</span></code></pre><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>机器人的运动范围虽然是在一个左上顶点为<code>[0,0]</code>, 右下顶点为<code>[m-1,n-1]</code>的矩形中运动, 但是机器人必须从<code>[0,0]</code>出发, 也就是说虽然有一些点是符合各数位之和小于 k 的, 但是机器人不可达就不应该计算在内.</p><p>这里, 我直接把所有符合要求的点全部记录在一个二维数组中, 然后通过 dfs 来求出 “岛屿” 的大小.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">bool</span> _legalArea(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)&#123;        <span class="hljs-comment">//true : i 和 j 的各个位之后小于k</span>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i)&#123;            sum += i % <span class="hljs-number">10</span>;            i /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">while</span>(j)&#123;            sum += j % <span class="hljs-number">10</span>;            j /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> (sum &lt;= k);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp; <span class="hljs-built_in">map</span>)</span></span>&#123;        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || i&gt;=<span class="hljs-built_in">map</span>.size() || j&lt;<span class="hljs-number">0</span> || j&gt;= <span class="hljs-built_in">map</span>[<span class="hljs-number">0</span>].size() || <span class="hljs-built_in">map</span>[i][j] == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span>;        count++;        <span class="hljs-built_in">map</span>[i][j] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>]&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span> ; k &lt; <span class="hljs-number">4</span>; ++ k)&#123;            dfs(i+dx[k],j+dy[k],<span class="hljs-built_in">map</span>);        &#125;        <span class="hljs-keyword">return</span>;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">map</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; ++ i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; ++ j)&#123;                <span class="hljs-keyword">if</span>(_legalArea(i,j,k) == <span class="hljs-literal">true</span>)&#123;                    <span class="hljs-built_in">map</span>[i][j] = <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">map</span>);        <span class="hljs-keyword">return</span> count;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-13-机器人的运动范围&quot;&gt;&lt;a href=&quot;#剑指-Offer-13-机器人的运动范围&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 13. 机器人的运动范围&quot;&gt;&lt;/a&gt;剑指 Offer 13. 机器人的运动范围&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/&quot; title=&quot;leetcode链接&quot;&gt;剑指 Offer 13. 机器人的运动范围&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;orange&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地上有一个m行n列的方格，从坐标&lt;code&gt; [0,0]&lt;/code&gt; 到坐标&lt;code&gt; [m-1,n-1]&lt;/code&gt; 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="剑指 Offer 专题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
    <category term="DFS" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/DFS/"/>
    
  </entry>
  
</feed>
