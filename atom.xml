<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>劳振煜的知識倉儲</title>
  
  <subtitle>Study &amp; Share</subtitle>
  <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/atom.xml" rel="self"/>
  
  <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/"/>
  <updated>2021-02-02T06:08:48.619Z</updated>
  <id>https://oxygenpanda.github.io/OXygenPanda.github.io/</id>
  
  <author>
    <name>劳振煜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IO多路复用</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/20/HugeFour/OperatingSystem/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/20/HugeFour/OperatingSystem/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2021-01-20T06:07:00.000Z</published>
    <updated>2021-02-02T06:08:48.619Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a><blockquote><p>  学习自 : <a href="https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=6979152329662416408">https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=6979152329662416408</a></p></blockquote></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>服务器应对并发时, 如果使用多线程程序, 每一个连接创建一个线程, 由于上下文切换,  处理句柄会导致代价很高. 所以很多时候, 使用的是单线程程序, 其中 DMA 保证了不同时候到来的 IO数据 不会丢失.</p><a id="more"></a><p>最简单的一个由程序来接收IO数据的程序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(Fdx in (FdA ~ FdE) &#123;</span><br><span class="line"><span class="keyword">if</span>(Fdx 有数据) &#123;</span><br><span class="line">读Fdx;</span><br><span class="line">处理;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是, 每一次由用户来询问内核, 开销较大, 因此有了 <code>select()</code>.</p><h2 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">FD_SET(fds[i], &amp;rset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;round again&quot;</span>);</span><br><span class="line">select(max + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//阻塞函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">para 0:文件描述符最大的范围(因为第一位是fd=0,所以要加1)</span></span><br><span class="line"><span class="comment">para 1:读文件描述符(比较关注)</span></span><br><span class="line"><span class="comment">para 2:写文件描述符</span></span><br><span class="line"><span class="comment">para 3:异常文件描述符</span></span><br><span class="line"><span class="comment">para 4:超时时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(fds[i], &amp;rset)) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, MAXBUF);</span><br><span class="line">read(fds[i], buffer, MAXBUF);</span><br><span class="line"><span class="built_in">puts</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>使用 rset(bitmap) 来标记注册的 Fds ;</li><li>将 rset 拷贝至内核态 ;</li><li>select() 阻塞 ;</li><li>有数据到来后, 内核对有数据的 rset位 置位, 并且 select() 返回 ;</li><li>遍历 Fds 判断是否被置位, 如果置位就说明对应的 IO 有数据 ;</li><li>由于破坏了 rset位图, 需要重新遍历 Fds 标记 rest位图 ;</li><li>循环 2 - 6.</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>rset 的数据结构以及存储的数据的表示</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rset的数据类型是 bitmap</span><br><span class="line"></span><br><span class="line">假设 fds 分别是 <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span></span><br><span class="line">那么rest 的值就是 bitmap&lt;<span class="number">1024</span>&gt;<span class="number">0110&#x27;0101&#x27;01000.</span>..</span><br><span class="line"></span><br><span class="line"><span class="comment">//左边第一个代表的是 fds 值为0的不存在</span></span><br><span class="line"><span class="comment">//1024 因为 Linux 默认支持最大线程数是1024</span></span><br></pre></td></tr></table></figure><ol start="2"><li>工作状态</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无数据 : select() 阻塞</span><br><span class="line">有数据 : 内核 <span class="number">1.</span> 对有数据来的FD置位 <span class="number">2.</span> select() 返回</span><br></pre></td></tr></table></figure><ol start="3"><li>返回值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">成功 : 大于 <span class="number">0</span> </span><br><span class="line">出错 : <span class="number">-1</span></span><br><span class="line">超时 : <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="select-的优点"><a href="#select-的优点" class="headerlink" title="select() 的优点"></a>select() 的优点</h3><ol><li>将 rset 交给内核监听, 节约了一定的开销;</li><li><strong>select() 的核心是内核等待队列唤醒机制.</strong></li></ol><h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select() 的缺点"></a>select() 的缺点</h3><ol><li>rset : 1024 bitmap</li><li>FDset 不可重用</li><li>用户态拷贝的时候切换到内核态, 仍然有开销</li><li>O(n) 时间复杂度去遍历得到哪一个 IO 有数据</li></ol><h2 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;        <span class="comment">//fds</span></span><br><span class="line"><span class="keyword">short</span> events;  <span class="comment">//关注的事件</span></span><br><span class="line"><span class="keyword">short</span> revents; <span class="comment">//反馈(初始值为0)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span>(client));</span><br><span class="line">addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">pollfds[i].fd = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">pollfds[i].events = POLLIN;</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;round again&quot;</span>);</span><br><span class="line">poll(pollfds, <span class="number">5</span>, <span class="number">50000</span>);   <span class="comment">//阻塞</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">para 0 : 结构体数组名</span></span><br><span class="line"><span class="comment">para 1 : fds的个数</span></span><br><span class="line"><span class="comment">para 2 : 超时时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(pollfds[i].revents &amp; POLLIN) &#123; <span class="comment">//判 revents 和 关注的事件</span></span><br><span class="line">pollfds[i].revents = <span class="number">0</span>;         <span class="comment">//置位达到可重用效果</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, MAXBUF);</span><br><span class="line">read(pollfds[i], fd, buffer, MAXBUF);</span><br><span class="line"><span class="built_in">puts</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>用户态拷贝 fds 至内核态, 由内核监听(和 select() 一样)</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>struct pollfd 的细节</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">pollfd</span> 的一个节点相当于是 <span class="title">rset</span> 中的一位</span></span><br><span class="line"><span class="class"><span class="title">events</span>  用于标记关注的事件, 如果同时关注多个事件, 事件1 &amp; 事件2</span></span><br><span class="line"><span class="class"><span class="title">revents</span> 初始为0, 内核置数, 处理时清零, 可重用</span></span><br></pre></td></tr></table></figure><ol><li>工作状态</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无数据 : poll() 阻塞</span><br><span class="line">有数据 : 内核 <span class="number">1.</span> pollfds.revents 置位 <span class="number">2.</span> poll 返回</span><br></pre></td></tr></table></figure><h3 id="poll-的优点"><a href="#poll-的优点" class="headerlink" title="poll() 的优点"></a>poll() 的优点</h3><ol><li>数组可以超过 1024 长(最大65535长)</li><li>重置 revents 后可重用</li></ol><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll()"></a>epoll()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[5];</span></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">10</span>);                        <span class="comment">// 1</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span>(client));</span><br><span class="line">addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">ev.data.fd = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;round again&quot;</span>);</span><br><span class="line">nfds = epoll_waits(epfd, events, <span class="number">5</span>, <span class="number">10000</span>);       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nfds; i ++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, MAXBUF);</span><br><span class="line">read(events[i].data.fd, buffer, MAXBUF);</span><br><span class="line"><span class="built_in">puts</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>1 : 创建白板 epfd</p><p>2 : 在白板上写字 : fd - events, 得到了一些列 fd - events 的 epfd</p><p>3 : epfd 由用户态和内核态共享内存 ( 实际上还是要拷贝到内核态, 在 <code>epoll_ctl()</code> 就拷贝 )</p><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>函数细节</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epoll_ctl()  向内核注册新的描述符或者改变某个文件描述符的状态, 已注册的描述符在内核中被维护成红黑树</span><br><span class="line">epoll_wait() 回调函数, 内核将有数据的描述符加入到一个链表中, 进程获得描述符数</span><br></pre></td></tr></table></figure><ol><li>工作状态</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没数据 : epoll() 阻塞(水平触发下, 边缘触发?)</span><br><span class="line">有数据 : <span class="number">1.</span> <span class="string">&quot;置位&quot;</span>(重排,将有数据的fd-events放在最前面) <span class="number">2.</span> 返回值是有数据的IO数</span><br></pre></td></tr></table></figure><ol><li>两种触发模式</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LT:水平触发</span><br><span class="line">当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking</span><br><span class="line"></span><br><span class="line">ET:边缘触发</span><br><span class="line">和 LT 模式不同的是，通知之后进程必须立即处理事件。下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</span><br></pre></td></tr></table></figure><h3 id="epoll-的优点"><a href="#epoll-的优点" class="headerlink" title="epoll() 的优点"></a>epoll() 的优点</h3><ol><li>时间复杂度 O(1)</li></ol>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;Website&quot; src=&quot;https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&amp;logo=Blogger&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://www.github.com/OXygenPanda&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&amp;logo=GitHub&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&amp;logo=WeChat&quot;&gt;&lt;/a&gt;


&lt;blockquote&gt;
&lt;p&gt;  学习自 : &lt;a href=&quot;https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;amp;seid=6979152329662416408&quot;&gt;https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;amp;seid=6979152329662416408&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;服务器应对并发时, 如果使用多线程程序, 每一个连接创建一个线程, 由于上下文切换,  处理句柄会导致代价很高. 所以很多时候, 使用的是单线程程序, 其中 DMA 保证了不同时候到来的 IO数据 不会丢失.&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/15/HugeFour/DataStructrues/tree/RBTree/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/15/HugeFour/DataStructrues/tree/RBTree/</id>
    <published>2021-01-15T14:48:00.000Z</published>
    <updated>2021-01-15T14:51:33.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><strong>名称 :</strong> 红黑树</p><p><strong>优点 :</strong></p><p>相较AVL树来说, 平衡条件宽松, 减少了很多因插入删除节点导致的调整. 适合于插入删除频繁的情况.</p><p>AVL树适合于插入删除较少, 搜索较多的情况.</p><p><strong>平衡条件 :</strong> </p><ol><li>每个节点非黑即红</li><li>根节点是黑色</li><li>叶节点(NIL)是黑色  NIL : 虚拟空节点</li><li>如果一个节点是红色, 则它的两个子节点都是黑色的</li><li>从根节点触发到所有叶节点路径上, 黑色节点数量相同 (最长是最短路径的2倍 : 长边红黑相间, 短边黑色)</li></ol><p><strong>认识 :</strong> </p><p>平衡条件 4 和 5 限制了红黑树最长边和最短边的2倍长度关系. 本质上, 红黑树也是通过控制树高来保证平衡. 红黑树相比AVL树控制条件更弱, 因此插入删除调整的频次也会低. AVL树更适用于插入删除较少但是访问较多的情况.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;红黑树&quot;&gt;&lt;a href=&quot;#红黑树&quot; class=&quot;headerlink&quot; title=&quot;红黑树&quot;&gt;&lt;/a&gt;红黑树&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;名称 :&lt;/strong&gt; 红黑树&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点 :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相较AV</summary>
      
    
    
    
    <category term="tree" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/tree/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/15/HugeFour/DataStructrues/sort/quick/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/15/HugeFour/DataStructrues/sort/quick/</id>
    <published>2021-01-15T10:00:00.000Z</published>
    <updated>2021-01-15T14:51:52.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>名称 :</strong> 快速排序</p><p><strong>性质 :</strong> 不稳定的排序算法</p><p><strong>用途 :</strong> 分治思路的排序</p><p><strong>复杂度 :</strong> 时间 O(nlogn) 空间 O(1)</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: quick_sort2.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: Lao Zhenyu</span></span><br><span class="line"><span class="comment">    &gt; Mail: LaoZhenyu_961112@163.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 五  1/15 17:48:29 2021</span></span><br><span class="line"><span class="comment">************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)   <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j,base;</span><br><span class="line">    base = arr[left];</span><br><span class="line">    i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[j] &gt;= base &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span>(arr[i] &lt;= base &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">            swap(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = arr[i];</span><br><span class="line">    arr[i] = base;</span><br><span class="line">    quickSort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>,&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : arr)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="排序算法" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/14/HugeFour/DataStructrues/sort/merge/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/14/HugeFour/DataStructrues/sort/merge/</id>
    <published>2021-01-14T12:00:00.000Z</published>
    <updated>2021-01-15T14:52:09.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>名称 :</strong> 归并排序</p><p><strong>性质 :</strong> 稳定的排序算法</p><p><strong>作者 :</strong> 冯诺依曼</p><p><strong>用途 :</strong> 分治思路的排序</p><p><strong>复杂度 :</strong> 时间 O(nlogn) 空间 O(n)</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: merge_sort.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: Lao Zhenyu</span></span><br><span class="line"><span class="comment">    &gt; Mail: LaoZhenyu_961112@163.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 四  1/14 20:38:22 2021</span></span><br><span class="line"><span class="comment">************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">L</span><span class="params">(mid - left + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">R</span><span class="params">(right - mid)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L.size(); ++ i)&#123;</span><br><span class="line">        L[i] = arr[left + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; R.size(); ++ j)&#123;</span><br><span class="line">        R[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    k = left;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; L.size() &amp;&amp; j &lt; R.size())&#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &gt;= R[j])&#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; L.size())&#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        k++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; R.size())&#123;</span><br><span class="line">        arr[k] = R[j];</span><br><span class="line">        k++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    mergeSort(arr,<span class="number">0</span>, arr.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : arr)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="排序算法" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/07/HugeFour/DataStructrues/tree/AVLTree/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/07/HugeFour/DataStructrues/tree/AVLTree/</id>
    <published>2021-01-07T13:00:00.000Z</published>
    <updated>2021-01-15T14:51:32.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>名称 :</strong> AVL树</p><p><strong>发明者 :</strong> </p><p>G. M. Adelson-Velsky</p><p>E.M. Landis</p><p><strong>年代 :</strong> 1962年(58岁)</p><p><strong>优点 :</strong></p><p>由于对每个节点的左右子树的树高做了限制, 所以整棵树不会退化成一个链表</p><p>**学习重点 : **</p><ol><li>平衡二叉排序树,本质上也是二叉排序树, 所以拥有二叉排序树的所有性质</li><li>平衡二叉排序树的学习重点, 在于平衡条件以及平衡调整的相关学习</li></ol><p><strong>性质 :</strong></p><ol><li>平衡条件 : | H(left) - H(right) | ≤ 1</li></ol><p><strong>思考 :</strong> </p><p>​    高度为 H 的树, 所包含节点的范围是?</p><p>​    BinarySearchTree : H ≤ size ≤ 2^H - 1</p><p>​    AVLTree : low(H-2) + low(H-1) + 1 ≤ size ≤ 2^H - 1 (low(H) 是 H 高度的二叉树的最少节点数) 左边等于 1.5^H</p><p><strong>操作</strong>SSS</p><p>AVL树 - 左旋</p><img src="https://i.loli.net/2021/01/08/3XlUQLIxHNKTCt5.png" style="zoom:33%;">左旋前<img src="https://i.loli.net/2021/01/08/IxZvkmGhcprAE42.png" style="zoom:33%;">左旋后AVL树 - 右旋<img src="https://i.loli.net/2021/01/08/oNYgrvHhOSkb9BK.png" style="zoom:33%;">右旋前<img src="https://i.loli.net/2021/01/08/oNYgrvHhOSkb9BK.png" style="zoom:33%;">右旋后<h3 id="失衡类型"><a href="#失衡类型" class="headerlink" title="失衡类型"></a>失衡类型</h3><p>h(1,2,3,4) 分别代表左孩子的左子树个高,左孩子的右子树高,右孩子的左子树高和右孩子的右子树高</p><p>LL类型:左子树的左孩子更高</p><p>满足条件 : h1 = max(h3, h4) + 2 = h2 + 1</p><p>调整方案 : K1 右旋</p><p>LR类型:左子树的右孩子更高</p><p>满足条件 : max(h2, h3) = h4 = h1</p><p>调整方案 : 小左旋, 大右旋(左孩子左旋, 根节点右旋)</p><p>RL类型:右子树的左孩子更高</p><p>调整方案 : 小右旋, 大左旋</p><p>RR类型:右子树的右孩子更高</p><p>调整方案 : K1 左旋</p><h3 id="平衡调整策略"><a href="#平衡调整策略" class="headerlink" title="平衡调整策略"></a>平衡调整策略</h3><ol><li>发生在回溯阶段的, 第一个失衡节点处</li><li>理解平衡调整策略的关键在于 : 分析清楚四种情况下, ABCD四棵子树树高的关系</li><li>LL, 大右旋</li><li>LR, 先小左旋, 再大右旋</li><li>RL, 先小右旋, 再大左旋</li><li>RR, 大左旋</li></ol><h3 id="代码关键点"><a href="#代码关键点" class="headerlink" title="代码关键点"></a>代码关键点</h3><ol><li>插入和删除以后, 注意调整树高字段, 先调低的root, 再调高的tmp</li><li>引入了NIL节点, 代替了 NULL和nullptr, NULL不可访问资源, NIL是一个实际节点, 可以访问资源(h,lchild,rchild)</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(n) (n-&gt;lchild)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(n) (n-&gt;rchild)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> H(n) (n-&gt;h)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> key,h;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚拟空节点, 为红黑树做准备的节点</span></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span></span>&#123;</span><br><span class="line">NIL-&gt;key = <span class="number">0</span>, NIL-&gt;h = <span class="number">0</span>;</span><br><span class="line">NIL-&gt;lchild = NIL-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优先初始化上面这一段代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AVL树的若干操作:</span></span><br><span class="line"><span class="comment"> * 1. 创建节点</span></span><br><span class="line"><span class="comment"> * 2. 销毁节点</span></span><br><span class="line"><span class="comment"> * 3. 插入</span></span><br><span class="line"><span class="comment"> * 4. 删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">Node * tmp = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">tmp-&gt;key = key;</span><br><span class="line">tmp-&gt;h = <span class="number">1</span>;</span><br><span class="line">tmp-&gt;lchild = NIL, tmp-&gt;rchild = NIL;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == NIL)<span class="keyword">return</span>;</span><br><span class="line">clear(root-&gt;lchild);</span><br><span class="line">clear(root-&gt;rchild);</span><br><span class="line"><span class="built_in">free</span>(root);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_height</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line">root-&gt;h = (H(L(root)) &gt; H(R(root)) ? H(L(root)) : H(R(root))) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="function">Node * <span class="title">left_rotate</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line">Node * tmp = root-&gt;rchild; <span class="comment">//新根节点</span></span><br><span class="line">root-&gt;rchild = tmp-&gt;lchild; <span class="comment">//新左挂旧右</span></span><br><span class="line">tmp-&gt;lchild = root; <span class="comment">//旧根挂新左</span></span><br><span class="line">update_height(root);</span><br><span class="line">update_height(tmp);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function">Node * <span class="title">right_rotate</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line">Node * tmp = root-&gt;lchild; <span class="comment">//新根</span></span><br><span class="line">root-&gt;lchild = tmp-&gt;rchild; <span class="comment">//新右成旧左</span></span><br><span class="line">tmp-&gt;rchild = root; <span class="comment">//旧根成新左</span></span><br><span class="line">update_height(root);</span><br><span class="line">update_height(tmp);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整</span></span><br><span class="line"><span class="function">Node * <span class="title">maintain</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line"><span class="comment">//平衡调整代码</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(H(L(root)) - H(R(root))) &lt;= <span class="number">1</span>)<span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;lchild-&gt;h &gt; root-&gt;rchild-&gt;h) &#123;</span><br><span class="line"><span class="comment">//LR先小左旋</span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;lchild-&gt;lchild-&gt;h &lt; root-&gt;lchild-&gt;rchild-&gt;h)</span><br><span class="line">root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line"><span class="comment">//LL大右旋</span></span><br><span class="line">root = right_rotate(root);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//RL先小右旋</span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;rchild-&gt;rchild-&gt;h &lt; root-&gt;rchild-&gt;lchild-&gt;h)</span><br><span class="line">root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line"><span class="comment">//RR大左旋</span></span><br><span class="line">root = left_rotate(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node * <span class="title">insert</span><span class="params">(Node * root, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == NIL)<span class="keyword">return</span> getNewNode(key);</span><br><span class="line"><span class="keyword">if</span>(root-&gt;key == key)<span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">if</span>(key &lt; root-&gt;key)root-&gt;lchild = insert(root-&gt;lchild, key);</span><br><span class="line"><span class="keyword">if</span>(key &gt; root-&gt;key)root-&gt;rchild = insert(root-&gt;rchild, key);</span><br><span class="line">update_height(root);</span><br><span class="line"><span class="keyword">return</span> maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找前驱节点,默认传入度为2的节点,前父节点有左子树</span></span><br><span class="line"><span class="function">Node * <span class="title">predeccessor</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line">Node * tmp = root-&gt;lchild;</span><br><span class="line"><span class="keyword">while</span>(tmp-&gt;rchild)tmp = tmp-&gt;rchild;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node * <span class="title">erase</span><span class="params">(Node * root, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == NIL)<span class="keyword">return</span> NIL;</span><br><span class="line"><span class="keyword">if</span>(key &lt; root-&gt;key) &#123;</span><br><span class="line">root-&gt;lchild = erase(root-&gt;lchild, key);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; root-&gt;key) &#123;</span><br><span class="line">root-&gt;rchild = erase(root-&gt;rchild, key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//删除当前节点</span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;rchild == NIL || root-&gt;lchild == NIL)&#123;</span><br><span class="line">Node * tmp = root-&gt;rchild != NIL ? root-&gt;rchild : root-&gt;lchild;</span><br><span class="line"><span class="built_in">free</span>(root);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除度为2的节点</span></span><br><span class="line">Node * tmp = predeccessor(root);</span><br><span class="line">root-&gt;key = tmp-&gt;key;</span><br><span class="line">root-&gt;lchild = erase(root-&gt;lchild, root-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">update_height(root);</span><br><span class="line"><span class="keyword">return</span> maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%d[%d], %d, %d)\n&quot;</span>,</span><br><span class="line">root-&gt;key, root-&gt;h,</span><br><span class="line">root-&gt;lchild-&gt;key,</span><br><span class="line">root-&gt;rchild-&gt;key</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == NIL)<span class="keyword">return</span>;</span><br><span class="line">print(root);</span><br><span class="line">output(root-&gt;lchild);</span><br><span class="line">output(root-&gt;rchild);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> op, val;</span><br><span class="line">Node* root = NIL;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val))&#123;</span><br><span class="line"><span class="keyword">switch</span>(op)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">output(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="tree" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/tree/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/06/HugeFour/DataStructrues/tree/BinarySearchTree/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2021/01/06/HugeFour/DataStructrues/tree/BinarySearchTree/</id>
    <published>2021-01-06T12:00:00.000Z</published>
    <updated>2021-01-08T15:24:23.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>名称 :</strong> 二叉排序树, 二叉搜索树</p><p><strong>性质 :</strong> </p><ol><li>左子树 &lt; 根节点</li><li>右子树 &gt; 根节点</li></ol><p><strong>用途 :</strong> 解决与排名有关的检索需求</p><p><strong>插入过程 :</strong> 根据插入节点值和根节点比较, 选择左子树或右子树继续比较, 最终放在叶子节点上</p><p><strong>删除过程 :</strong></p><ol><li><p>删除叶子节点</p><p> 直接删除</p></li><li><p>删除度为1的节点</p><p> 把孩子交给祖父节点</p></li><li><p>删除度为2的节点</p><p> 中序遍历 : 10 17 20 28 29 30 32</p><p> 性质 : 待删除节点的前驱无右子树, 后继无左子树, 因此前驱后继一定不是度为2的节点</p><p> 将前驱或后继直接覆盖待删除节点后, 问题转换为删除叶子节点或者是度为1的节点</p></li></ol><p><strong>优化 :</strong></p><ol><li>删除掉处理度为0的代码逻辑，不影响代码整体功能</li><li>解决排名相关的检索需求，修改二叉搜索树的定义，增加size字段，记录每棵树的节点数目<ol><li><code>K == LS - 1</code> : 根节点就是排名第k的元素</li><li><code>k &lt;= LS</code> : 排名第k位的元素在左子树中</li><li><code>k &gt; LS</code> : $search_k(root-&gt;rchild, k - LS - 1)$</li></ol></li><li>解决 top-k 问题，输出前k位的元素(找到小于第k位的所有元素)<ol><li>根节点就是第k位元素, 输出左子树所有节点和根节点值</li><li>第k位元素在左子树中, 前k位元素全部在左子树中</li><li>第k位元素在右子树中, 说明左子树中的所有节点和根节点都是前k位元素 </li></ol></li><li>二叉排序树和快速排序的关系<ol><li>二叉排序树是快速排序的逻辑结构</li><li>思考1: 快速排序算法的时间复杂度和二叉排序树建树时间复杂度之间的关系</li><li>思考2：快速选择算法和二叉排序树的关系</li></ol></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n)    (n ? n-&gt;key : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n)   (n ? n-&gt;size : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(n)      (n ? n-&gt;lchild : 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> key, size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 二叉搜索树的若干操作:</span></span><br><span class="line"><span class="comment"> * 1. 创建节点</span></span><br><span class="line"><span class="comment"> * 2. 销毁节点</span></span><br><span class="line"><span class="comment"> * 3. 查找</span></span><br><span class="line"><span class="comment"> * 4. 插入</span></span><br><span class="line"><span class="comment"> * 5. 删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 优化1: 将删除度为0和度为1的节点的代码合并</span></span><br><span class="line"><span class="comment"> * 优化2: 实现查找第k位的元素</span></span><br><span class="line"><span class="comment"> * 优化3: 实现输出前k位的元素(TOP-K)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新树高</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_size</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line">root-&gt;size = SIZE(root-&gt;lchild) + SIZE(root-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="function">Node * <span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">p-&gt;key = key;</span><br><span class="line">p-&gt;size = <span class="number">1</span>;</span><br><span class="line">p-&gt;lchild = <span class="literal">nullptr</span>, p-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">clear(root-&gt;lchild);</span><br><span class="line">clear(root-&gt;rchild);</span><br><span class="line"><span class="built_in">free</span>(root);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node* root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;key == val)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;key &gt; val)<span class="keyword">return</span> search(root-&gt;lchild, val);</span><br><span class="line"><span class="keyword">if</span>(root-&gt;key &lt; val)    <span class="keyword">return</span> search(root-&gt;rchild, val);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找第k大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_k</span><span class="params">(Node * root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(SIZE(L(root)) == k - <span class="number">1</span>)<span class="keyword">return</span> root-&gt;key;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= SIZE(L(root)))&#123;</span><br><span class="line"><span class="keyword">return</span> search_k(root-&gt;lchild, k);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> search_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function">Node * <span class="title">insert</span><span class="params">(Node * root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)    <span class="keyword">return</span> getNewNode(val);</span><br><span class="line"><span class="keyword">if</span>(root-&gt;key == val)<span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">if</span>(val &lt; root-&gt;key)     root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line"><span class="keyword">if</span>(val &gt; root-&gt;key)     root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">update_size(root);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找前驱(默认父节点有左孩子)</span></span><br><span class="line"><span class="function">Node * <span class="title">predecessor</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line">Node * tmp = root-&gt;lchild;</span><br><span class="line"><span class="keyword">while</span>(tmp-&gt;rchild != <span class="literal">nullptr</span>)tmp = tmp-&gt;rchild;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function">Node * <span class="title">erase</span><span class="params">(Node * root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;key &gt; val)</span><br><span class="line">root-&gt;lchild = erase(root-&gt;lchild, val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;key &lt; val)</span><br><span class="line">root-&gt;rchild = erase(root-&gt;rchild, val);</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//删除节点本身</span></span><br><span class="line">   <span class="comment">//删除度为0的节点和度为1的节点操作相同 </span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;lchild == <span class="literal">nullptr</span> || root-&gt;rchild == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">Node * tmp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line"><span class="built_in">free</span>(root);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//删除度为2的节点</span></span><br><span class="line">Node * tmp = predecessor(root);</span><br><span class="line">root-&gt;key = tmp-&gt;key;</span><br><span class="line">root-&gt;lchild = erase(root-&gt;lchild, tmp-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">update_size(root);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出整棵树的所有节点 - 中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">output(root-&gt;lchild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d, %d, %d, size : %d]\n&quot;</span>,KEY(root),KEY(root-&gt;lchild),KEY(root-&gt;rchild),SIZE(root));</span><br><span class="line">output(root-&gt;rchild);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出前k个节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">0</span> || root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= SIZE(L(root)))&#123;</span><br><span class="line">output_k(root-&gt;lchild, k);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">output(root-&gt;lchild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d, %d, %d, size : %d]\n&quot;</span>,KEY(root),KEY(root-&gt;lchild),KEY(root-&gt;rchild),SIZE(root));</span><br><span class="line">output_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> op, val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* op :</span></span><br><span class="line"><span class="comment"> * 0 查找</span></span><br><span class="line"><span class="comment"> * 1 插入</span></span><br><span class="line"><span class="comment"> * 2 删除</span></span><br><span class="line"><span class="comment"> * 3 查找第k位的元素</span></span><br><span class="line"><span class="comment"> * 4 输出前k位的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Node * root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val))&#123;</span><br><span class="line"><span class="keyword">switch</span>(op)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d\n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;search k %d, result : %d\n&quot;</span>,val, search_k(root, val)); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;output top-%d elements\n&quot;</span>,val);</span><br><span class="line">output_k(root, val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----------------\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(op != <span class="number">0</span> &amp;&amp; op != <span class="number">4</span>)&#123;</span><br><span class="line">output(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉排序树&quot;&gt;&lt;a href=&quot;#二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;二叉排序树&quot;&gt;&lt;/a&gt;二叉排序树&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;</summary>
      
    
    
    
    <category term="tree" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/tree/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 45. 把数组排成最小的数</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/18/leetcode/offer/%E5%89%91%E6%8C%87Offer%2045/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/18/leetcode/offer/%E5%89%91%E6%8C%87Offer%2045/</id>
    <published>2020-12-18T13:06:00.000Z</published>
    <updated>2020-12-18T13:11:01.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a>剑指 Offer 45. 把数组排成最小的数</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" title="leetcode链接">剑指 Offer 45. 把数组排成最小的数</a></p><p><strong>难度:</strong><font color="orange">中等</font></p><p><strong>描述</strong></p><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><a id="more"></a><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">10</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="string">&quot;102&quot;</span></span><br><span class="line">    </span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="string">&quot;3033459&quot;</span></span><br><span class="line"></span><br><span class="line">限制:</span><br><span class="line"><span class="number">0</span> &lt; nums.length &lt;= <span class="number">100</span></span><br><span class="line">输出结果可能非常大，所以你需要返回一个字符串而不是整数</span><br><span class="line">拼接起来的数字可能会有前导 <span class="number">0</span>，最后结果不需要去掉前导 <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>思路是, 因为每一个数字内的相对关系是不能改变的, 因此不能把数字拆分成各个数位做排序. 因此, 可以寻找数字排列先后的规律, 比如, <code>10</code> 和 <code>2</code> 两个数字可以组成 <code>102</code> 和 <code>210</code> , 但是 <code>102 &lt; 210</code> 因此, <code>10</code> 在前. 这就是一种排序规则. 可以写一个 lambda 表达式指导 <code>sort()</code> 按照刚刚模拟的方式来排序所有数字. 最后拼接到目标串中.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : nums)</span><br><span class="line">            strs.push_back(to_string(n));</span><br><span class="line">        sort(strs.begin(),strs.end(),[](<span class="keyword">const</span> <span class="built_in">string</span> &amp; a, <span class="keyword">const</span> <span class="built_in">string</span> &amp; b)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b &lt; b+a; <span class="comment">// 102 &lt; 210</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : strs)</span><br><span class="line">            res += str;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-45-把数组排成最小的数&quot;&gt;&lt;a href=&quot;#剑指-Offer-45-把数组排成最小的数&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 45. 把数组排成最小的数&quot;&gt;&lt;/a&gt;剑指 Offer 45. 把数组排成最小的数&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/&quot; title=&quot;leetcode链接&quot;&gt;剑指 Offer 45. 把数组排成最小的数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;orange&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="剑指 Offer 专题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 29. 顺时针打印矩阵</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/15/leetcode/offer/%E5%89%91%E6%8C%87Offer%2029/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/15/leetcode/offer/%E5%89%91%E6%8C%87Offer%2029/</id>
    <published>2020-12-15T13:40:00.000Z</published>
    <updated>2020-12-18T13:06:04.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a>剑指 Offer 29. 顺时针打印矩阵</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" title="leetcode链接">剑指 Offer 29. 顺时针打印矩阵</a></p><p><strong>难度:</strong><font color="green">简单</font></p><p><strong>描述</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><a id="more"></a><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    </span><br><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">限制:</span><br><span class="line"><span class="number">0</span> &lt;= matrix.length &lt;= <span class="number">100</span></span><br><span class="line"><span class="number">0</span> &lt;= matrix[i].length &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>第一种思路是模拟法, 模拟我们正常地顺时针行走, 提供一个方向数组, 提前判断下一步会不会超出边界, 如果超出, 那么就转向, 也就是改变 <code>directionIndex</code> 的值, 因为可能会从北回到东, 所以需要 <code>mod 4</code> .</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">// 方向数组,东-南-西-北</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size(), col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visit</span><span class="params">(row, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> total = row * col;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(total)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = <span class="number">0</span>, cols = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; total ; ++ i)&#123;</span><br><span class="line">            res[i] = matrix[rows][cols];</span><br><span class="line">            visit[rows][cols] = <span class="literal">true</span>; <span class="comment">// 已经访问过</span></span><br><span class="line">            <span class="keyword">int</span> nextrow = rows + direction[directionIndex][<span class="number">0</span>]; <span class="comment">// 下一个横坐标</span></span><br><span class="line">            <span class="keyword">int</span> nextcol = cols + direction[directionIndex][<span class="number">1</span>]; <span class="comment">// 下一个纵坐标</span></span><br><span class="line">            <span class="comment">//判断下一个坐标是否合法或者是否访问过, 访问过就改变方向</span></span><br><span class="line">            <span class="keyword">if</span>(nextrow &lt; <span class="number">0</span> || nextrow &gt;= row || nextcol &lt; <span class="number">0</span> || nextcol &gt;= col || visit[nextrow][nextcol])</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            rows += direction[directionIndex][<span class="number">0</span>];</span><br><span class="line">            cols += direction[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>第二种思路是缩小边界法, 它一共是四个边界 <code>l</code> <code>r</code> <code>u</code> <code>d</code> 来表示, 当前 <code>left</code> <code>right</code> <code>up</code> <code>down</code> 四个边界.因为每一次都是沿着四条边移动, 而且每一次访问完一条边, 一定会有一条边界向内缩. 循环体里的 4 个 <code>if</code> 用于最终退出.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> d = matrix.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)  res.push_back(matrix[u][i]);</span><br><span class="line">            <span class="keyword">if</span>(++ u &gt; d)    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = u ; j &lt;= d ; ++ j)  res.push_back(matrix[j][r]);</span><br><span class="line">            <span class="keyword">if</span>(-- r &lt; l)    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r ; i &gt;= l ; -- i)  res.push_back(matrix[d][i]);</span><br><span class="line">            <span class="keyword">if</span>(-- d &lt; u)    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = d ; j &gt;= u ; -- j)  res.push_back(matrix[j][l]);</span><br><span class="line">            <span class="keyword">if</span>(++ l &gt; r)    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-29-顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#剑指-Offer-29-顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 29. 顺时针打印矩阵&quot;&gt;&lt;/a&gt;剑指 Offer 29. 顺时针打印矩阵&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/&quot; title=&quot;leetcode链接&quot;&gt;剑指 Offer 29. 顺时针打印矩阵&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="剑指 Offer 专题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/11/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/11/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-12-11T11:13:00.000Z</published>
    <updated>2020-12-11T11:18:25.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a><blockquote><p>  内存管理是一个很深刻的话题, 对于初学者来说, 内存管理看不到摸不着, 我们常使用 new / delete 来管理我们的堆内存. 仅此而已.</p></blockquote></p><p>本文记录了侯捷老师内存管理课程的学习笔记以及部分自己写的代码.</p><p>目的是了解C++如何进行内存管理, 剖析源码, 能够设计自己的内存池.</p><h2 id="C-中内存管理工具"><a href="#C-中内存管理工具" class="headerlink" title="C++中内存管理工具"></a>C++中内存管理工具</h2><table><thead><tr><th>分配</th><th>释放</th><th>类型</th><th>是否可以重载</th></tr></thead><tbody><tr><td>malloc()</td><td>free()</td><td>C函数</td><td>不可以</td></tr><tr><td>new</td><td>delete</td><td>C++表达式</td><td>不可以</td></tr><tr><td>::operator new()</td><td>::operator delete()</td><td>C++函数</td><td>可以</td></tr><tr><td>allocator&lt;T&gt;::allocate()</td><td>allocator&lt;T&gt;::deallocate()</td><td>C++标准库</td><td>可自由设计并搭配容器</td></tr></tbody></table><p>用法示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>); <span class="comment">//512 bytes</span></span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt;* p2 = <span class="keyword">new</span> <span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt;; <span class="comment">//one object</span></span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p3 = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">512</span>); <span class="comment">//512 bytes</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GUNC__ <span class="comment">//GNUC 2.9</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p4 = alloc::allocate(<span class="number">512</span>);</span><br><span class="line">alloc::deallocate(p4,<span class="number">512</span>); <span class="comment">//得记得当初申请了多少的内存,比较适用于容器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__ <span class="comment">//GNUC 4.9</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate() 和 deallocate() 是 non-static 必须由 object 调用</span></span><br><span class="line"><span class="keyword">void</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">7</span>); <span class="comment">//分配7个int的内存大小</span></span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate((<span class="keyword">int</span>*)p4, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate() 和 deallocate() 是 non-static 必须由 object 调用</span></span><br><span class="line"><span class="keyword">void</span>* p5 = __gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">9</span>); <span class="comment">//分配9个int的内存大小</span></span><br><span class="line">__gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt;().deallocate((<span class="keyword">int</span>*)p5, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">编译器转换→</span><br><span class="line"></span><br><span class="line">Complex *pc;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex)); <span class="comment">//allocate</span></span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);           <span class="comment">//cast</span></span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>,<span class="number">2</span>);                 <span class="comment">//construct</span></span><br><span class="line"><span class="comment">//只有编译器才能够像上式直接调用 ctor</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::bad_alloc) &#123;</span><br><span class="line"><span class="comment">//allocate 失败, 不执行 ctor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="operator-new-vc98默认版本"><a href="#operator-new-vc98默认版本" class="headerlink" title="operator new() vc98默认版本"></a>operator new() vc98默认版本</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::nothrow t&amp;)</span> _<span class="title">THROW0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//try to allocate size bytes</span></span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"><span class="keyword">while</span>((p == <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//buy more memory or return null pointer</span></span><br><span class="line">_TRY_BEGIN</span><br><span class="line"><span class="keyword">if</span>(_callnewh(size) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">_CATCH(<span class="built_in">std</span>::bad_alloc)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">_CATCH_END</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delete-运算符"><a href="#delete-运算符" class="headerlink" title="delete 运算符"></a>delete 运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pc;</span><br><span class="line"></span><br><span class="line">编译器转换-&gt;</span><br><span class="line"></span><br><span class="line">pc-&gt;~Complex();        <span class="comment">//先析构</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;   <span class="comment">//然后释放内存</span></span><br></pre></td></tr></table></figure><h2 id="operator-delete-vc98默认版本"><a href="#operator-delete-vc98默认版本" class="headerlink" title="operator delete() vc98默认版本"></a>operator delete() vc98默认版本</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> * p)</span> _<span class="title">THROW0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//free an allocated object</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array-new-array-delete"><a href="#array-new-array-delete" class="headerlink" title="array new / array delete"></a>array new / array delete</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Complex * pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//触发三次ctor</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> [] pca; <span class="comment">//触发三次dtor</span></span><br></pre></td></tr></table></figure><p>内存分配的时候, 头部会有 cookie 方便回收.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> pi;</span><br><span class="line"></span><br><span class="line">vc6 : cookie</span><br><span class="line"><span class="number">61</span>h(记录大小是<span class="number">60</span>字节,<span class="number">1</span>表示使用了这一块)</span><br><span class="line"><span class="function">Debugger <span class="title">Header</span><span class="params">(<span class="number">32</span> Bytes)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">no man land</span><br><span class="line">Pad(<span class="number">12</span> Bytes)</span><br><span class="line"><span class="number">61</span>h</span><br></pre></td></tr></table></figure><h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (p)</span><br></pre></td></tr></table></figure><p>允许我们在已经申请的堆内存上, 构建一个对象.</p><p>placement new 没有对应的 placement delete, 因为 placement new操作并没有分配内存.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">sizeof</span>(Complex)*<span class="number">3</span>];</span><br><span class="line">Complex * pc = <span class="keyword">new</span> (buf) Complex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> [] buf;</span><br><span class="line"></span><br><span class="line">编译器-&gt;</span><br><span class="line"></span><br><span class="line">Complex * pc;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">void</span> * mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex), buf); <span class="comment">//实际上不操作</span></span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);                 <span class="comment">//cast</span></span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>,<span class="number">2</span>);                       <span class="comment">//construct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-应用程序分配内存的途径"><a href="#C-应用程序分配内存的途径" class="headerlink" title="C++应用程序分配内存的途径"></a>C++应用程序分配内存的途径</h2><p><strong>应用程序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = <span class="keyword">new</span> Foo(x);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">编译器-&gt;不可以改变不可以重载</span><br><span class="line"></span><br><span class="line">Foo *p = (Foo*)<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Foo));</span><br><span class="line"><span class="keyword">new</span> (p) Foo(x);</span><br><span class="line"></span><br><span class="line">p-&gt;~Foo();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(x)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>operator new / operator delete</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = (Foo*)<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Foo));</span><br><span class="line">调用 -&gt; ::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">调用 -&gt; <span class="built_in">malloc</span>(<span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(x)</span></span>;</span><br><span class="line">调用 -&gt; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line">调用 -&gt; <span class="built_in">free</span>(<span class="keyword">void</span>*);</span><br></pre></td></tr></table></figure><p><strong>在类中重载 <code>operator new</code> 和 <code>operator delete</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = (Foo*)<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Foo));</span><br><span class="line">重载 <span class="function">Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>; -&gt; 调用 ::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(x)</span></span>;</span><br><span class="line">重载 <span class="function">Foo::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span></span>; -&gt; 调用 ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="C-容器分配内存的途径"><a href="#C-容器分配内存的途径" class="headerlink" title="C++容器分配内存的途径"></a>C++容器分配内存的途径</h2><p><strong>容器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T *p = allocate();</span><br><span class="line">construct();</span><br><span class="line"></span><br><span class="line">destroy();</span><br><span class="line">deallocate(p);</span><br></pre></td></tr></table></figure><p><strong>分配器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allocate();</span><br><span class="line">deallocate();</span><br><span class="line">调用 -&gt; ::<span class="keyword">operator</span> <span class="keyword">new</span> <span class="keyword">or</span> ::<span class="keyword">operator</span> <span class="keyword">delete</span></span><br></pre></td></tr></table></figure><h2 id="重载-operator-new-operator-delete"><a href="#重载-operator-new-operator-delete" class="headerlink" title="重载 ::operator new / ::operator delete"></a>重载 ::operator new / ::operator delete</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">myAlloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFree</span><span class="params">(<span class="keyword">void</span> * ptr)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global new()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> myAlloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global new[]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> myAlloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> * ptr)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global delete()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">myFree(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> * ptr)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global delete[]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">myFree(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载-operator-new-operator-delete-1"><a href="#重载-operator-new-operator-delete-1" class="headerlink" title="重载 operator new / operator delete"></a>重载 operator new / operator delete</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*重载这两个函数应该是 static, 编译器默认*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>; <span class="comment">//第二参数 optional</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo *p = <span class="keyword">new</span> Foo;</span><br><span class="line">编译器-&gt;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">void</span> * mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Foo)); <span class="comment">//此处调用类中重载的 operator new</span></span><br><span class="line">p = <span class="keyword">static_cast</span>&lt;Foo*&gt;(mem);</span><br><span class="line">p-&gt;Foo::Foo(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//使用 ::delete p; 可以绕过重载的 operator delete</span></span><br><span class="line">编译器-&gt;</span><br><span class="line">p-&gt;~Foo();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>; <span class="comment">//此处调用类中重载的 operator delete</span></span><br></pre></td></tr></table></figure><h2 id="重载-placement-new-placement-delete"><a href="#重载-placement-new-placement-delete" class="headerlink" title="重载 placement new / placement delete"></a>重载 placement new / placement delete</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1,2默认版本; 3,4重载版本;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123; <span class="comment">// 调用 new Foo</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">void</span> * start)</span></span>&#123; <span class="comment">// 调用 new (&amp;) Foo</span></span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">long</span> extra)</span></span>&#123; <span class="comment">// 调用 new (100) Foo</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size + extra);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">long</span> extra, <span class="keyword">char</span> init)</span></span>&#123; <span class="comment">//调用 new(100,&#x27;a&#x27;) Foo</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size + extra);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** placement new 重载时, 第一参数必须为 size_t</span></span><br><span class="line"><span class="comment">** 否则, [Error] &#x27;operator new&#x27; takes type &#x27;size_t&#x27;(unsigned int) </span></span><br><span class="line"><span class="comment">** as first parameter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** placement delete 重载时, 不会被 delete 调用</span></span><br><span class="line"><span class="comment">** 除非 new 的时候抛出异常, 才会去调用对应的重载的 operator delete()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; targe</summary>
      
    
    
    
    <category term="C++" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C/"/>
    
    <category term="内存管理" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 - 数组</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/10/HugeFour/DataStructrues/01%E6%95%B0%E7%BB%84%20vector/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/10/HugeFour/DataStructrues/01%E6%95%B0%E7%BB%84%20vector/</id>
    <published>2020-12-10T11:42:00.000Z</published>
    <updated>2020-12-10T11:48:45.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-数组"><a href="#数据结构-数组" class="headerlink" title="数据结构 - 数组"></a>数据结构 - 数组</h1><p>该篇是数据结构的开篇. 数据结构学习拟定计划是学习 &lt;&lt;数据结构与算法 C++描述&gt;&gt; by Sartaj Sahni 的同时, 阅读 &lt;&lt;STL源码剖析&gt;&gt; by 侯捷, 完成对应数据结构在STL中的实现.</p><p>这一篇主要是 vector 的实现.</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的特性较为简单, 在内存空间中连续, 存储同一类型元素, 查询时间复杂度为<code>O(1)</code>, 插入删除时间复杂度为<code>O(n)</code>. 数据与数据的关系只有先后关系.</p><h2 id="vector-未完成"><a href="#vector-未完成" class="headerlink" title="vector(未完成)"></a>vector(未完成)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linear.c</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by OXygen on 2020/12/9.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linear.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myvector</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">typedef</span> _Tp           value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type*    pointer;</span><br><span class="line"><span class="keyword">typedef</span> pointer        iterator;</span><br><span class="line"><span class="keyword">typedef</span> _Tp&amp;           reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">iterator start;</span><br><span class="line">iterator finish;</span><br><span class="line">iterator end_of_storage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Construction &amp; Deconstruction</span></span><br><span class="line">myvector() &#123; start = finish = end_of_storage = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">myvector(<span class="keyword">int</span> capacity, value_type initElem = <span class="number">0</span>) &#123; <span class="keyword">if</span>(capacity &gt; <span class="number">0</span>) initalloc(capacity,initElem); &#125;</span><br><span class="line">myvector(<span class="keyword">const</span> myvector&amp; LeftVector) &#123;</span><br><span class="line"><span class="keyword">int</span> size = LeftVector.size();</span><br><span class="line"><span class="keyword">this</span>-&gt;resize(size);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size ; ++ i)&#123;</span><br><span class="line"><span class="keyword">this</span>[i] = LeftVector[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//myvector(myvector &amp;&amp; RightVector) noexcept &#123;&#125;</span></span><br><span class="line">~myvector() &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;clear();</span><br><span class="line">start = finish = end_of_storage = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Operations</span></span><br><span class="line">myvector &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> myvector &amp; LeftVector) &#123;</span><br><span class="line"><span class="keyword">if</span>(&amp;LeftVector == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span>(start != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size = LeftVector.size();</span><br><span class="line"><span class="keyword">this</span>-&gt;resize(size);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size ; ++ i)&#123;</span><br><span class="line"><span class="keyword">this</span>[i] = LeftVector[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//myvector &amp; operator=(myvector &amp;&amp; RightVector) noexcept &#123;&#125;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> myvector &amp; LeftVector) &#123;</span><br><span class="line"><span class="keyword">if</span>(&amp;LeftVector == <span class="keyword">this</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;size() != LeftVector.size())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="keyword">this</span>-&gt;size() ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>[i] != LeftVector[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> myvector &amp; LeftVector) &#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">operator</span>==(LeftVector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capacity</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (finish - start);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (end_of_storage - start);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>-&gt;size() == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visit</span></span><br><span class="line"><span class="function">value_type <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//empty应该抛出异常</span></span><br><span class="line"><span class="keyword">return</span> *begin();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">value_type <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//empty应该抛出异常</span></span><br><span class="line"><span class="keyword">return</span> *(end() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modifiers</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator location, value_type InsertElem)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator location)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator _begin, iterator _end)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(value_type PushElem)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(value_type PushElem)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initalloc</span><span class="params">(<span class="keyword">int</span> capacity, value_type Elem)</span></span>&#123;</span><br><span class="line">start = <span class="keyword">new</span> value_type[capacity];</span><br><span class="line">iterator it = start;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; capacity ; ++ i, ++ it) &#123;</span><br><span class="line">*it = Elem;</span><br><span class="line">&#125;</span><br><span class="line">end_of_storage = it + <span class="number">1</span>;</span><br><span class="line">finish = it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">growalloc</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构-数组&quot;&gt;&lt;a href=&quot;#数据结构-数组&quot; class=&quot;headerlink&quot; title=&quot;数据结构 - 数组&quot;&gt;&lt;/a&gt;数据结构 - 数组&lt;/h1&gt;&lt;p&gt;该篇是数据结构的开篇. 数据结构学习拟定计划是学习 &amp;lt;&amp;lt;数据结构与算法 C++描</summary>
      
    
    
    
    <category term="vector" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/vector/"/>
    
    
    <category term="数据结构" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 14- I. 剪绳子</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/07/leetcode/offer/%E5%89%91%E6%8C%87Offer%2014%20I/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/07/leetcode/offer/%E5%89%91%E6%8C%87Offer%2014%20I/</id>
    <published>2020-12-07T13:40:00.000Z</published>
    <updated>2020-12-07T13:46:11.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a>剑指 Offer 14- I. 剪绳子</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" title="leetcode链接">剑指 Offer 14- I. 剪绳子</a></p><p><strong>难度:</strong><font color="orange">中等</font></p><p><strong>描述</strong></p><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]*k[1]*…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><a id="more"></a><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> = <span class="number">1</span> + <span class="number">1</span>, <span class="number">1</span> × <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="number">36</span></span><br><span class="line">解释: <span class="number">10</span> = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">3</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">36</span></span><br></pre></td></tr></table></figure><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这样的题目, 适合先枚举多个例子找规律.</p><p>我们枚举到6,7,8的时候, 应该可以感受到, 每个数需要尽量地拆分多的数字<code>3</code>, 但是最终拆分剩下<code>4</code>的时候, 需要转换成<code>2+2</code>.</p><p>我们不需要循环地去重复 : <code>n -= 3</code> 和 <code>res *= 3 </code> , 因为, 这样的循环可以计算出运算的次数.</p><p>使用<code>count  = n / 3</code> 得知以上的循环会进行多少次, <code>count % 3</code> 得知以上的循环会剩下什么数.</p><p>如果剩下的数字是 <code>1</code>  说明我们把<code>4</code>拆分成了<code>3+1</code>, 所以回退一步, 结果为<code>pow(3, count - 1) * 4</code></p><p>如果剩下的数字是 <code>0</code>  说明这个数字<code>n</code>可以全部拆分成<code>3</code>, 所以结果为<code>pow(3, count)</code></p><p>如果剩下的数字是 <code>2</code>  说明结果为<code>pow(3, count) * 2</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2 : 1 + 1 -&gt; 1</span></span><br><span class="line"><span class="comment">        3 : 2 + 1</span></span><br><span class="line"><span class="comment">        4 : 2 + 2</span></span><br><span class="line"><span class="comment">        5 : 3 + 2</span></span><br><span class="line"><span class="comment">        6 : 3 + 3</span></span><br><span class="line"><span class="comment">        7 : 3 + 2 + 2</span></span><br><span class="line"><span class="comment">        8 : 3 + 3 + 2</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( n == <span class="number">2</span> || n == <span class="number">3</span>)   <span class="keyword">return</span> (n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> rest = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> (rest == <span class="number">1</span>) ? <span class="built_in">pow</span>(<span class="number">3</span>, count - <span class="number">1</span>) * <span class="number">4</span> : (rest == <span class="number">0</span>) ? <span class="built_in">pow</span>(<span class="number">3</span>, count) : rest * <span class="built_in">pow</span>(<span class="number">3</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-14-I-剪绳子&quot;&gt;&lt;a href=&quot;#剑指-Offer-14-I-剪绳子&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 14- I. 剪绳子&quot;&gt;&lt;/a&gt;剑指 Offer 14- I. 剪绳子&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/jian-sheng-zi-lcof/&quot; title=&quot;leetcode链接&quot;&gt;剑指 Offer 14- I. 剪绳子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;orange&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]*k[1]*…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="剑指 Offer 专题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2020.12.07 861. 翻转矩阵后的得分</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/07/leetcode/daily/861.%20%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/12/07/leetcode/daily/861.%20%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/</id>
    <published>2020-12-07T13:00:00.000Z</published>
    <updated>2020-12-07T13:21:15.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="861-翻转矩阵后的得分"><a href="#861-翻转矩阵后的得分" class="headerlink" title="861. 翻转矩阵后的得分"></a>861. 翻转矩阵后的得分</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/score-after-flipping-matrix/" title="leetcode链接">861. 翻转矩阵后的得分</a></p><p><strong>难度:</strong><font color="orange">中等</font></p><p><strong>描述</strong></p><p>有一个二维矩阵 A 其中每个元素的值为 0 或 1 。</p><p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p><p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p><p>返回尽可能高的分数。</p><a id="more"></a><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入 : [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出 : <span class="number">39</span></span><br><span class="line">解释 :</span><br><span class="line">转换为 [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="number">0b1111</span> + <span class="number">0b1001</span> + <span class="number">0b1111</span> = <span class="number">15</span> + <span class="number">9</span> + <span class="number">15</span> = <span class="number">39</span></span><br><span class="line"></span><br><span class="line">提示 :</span><br><span class="line"><span class="number">1</span> &lt;= A.length &lt;= <span class="number">20</span></span><br><span class="line"><span class="number">1</span> &lt;= A[<span class="number">0</span>].length &lt;= <span class="number">20</span></span><br><span class="line">A[i][j] 是 <span class="number">0</span> 或 <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>首先, <code>16</code>一定比<code>8</code>大. 也就是说, 最高位的<code>b1</code>一定比低位的<code>b1</code>表示的数字要大. 因此, 可以通过反转行, 来使得最高位是<code>b1</code>. 其次, 行已经达到最优的情况, 该反转列了, 列的反转结果会导致<code>b0</code>和<code>b1</code>的数量交换, 因此, 如果一列上<code>b1</code>的数量大于<code>b0</code>时, 不需要反转, 否则反转.</p><p>经过行列反转后, 达到最优解. 计算结果.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = A[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][<span class="number">0</span>] == <span class="number">0</span>)&#123; <span class="comment">//首位是0才需要行反转</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)&#123;</span><br><span class="line">                    A[i][j] = A[i][j] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转列</span></span><br><span class="line">        <span class="keyword">int</span> mid = (m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)&#123;</span><br><span class="line">                count += A[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &lt; mid)&#123; <span class="comment">//1的数量小于一半时才需要列反转</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)</span><br><span class="line">                    A[i][j] = A[i][j] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)&#123;</span><br><span class="line">                res += A[i][j] * <span class="built_in">pow</span>(<span class="number">2</span>, n - <span class="number">1</span> - j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;861-翻转矩阵后的得分&quot;&gt;&lt;a href=&quot;#861-翻转矩阵后的得分&quot; class=&quot;headerlink&quot; title=&quot;861. 翻转矩阵后的得分&quot;&gt;&lt;/a&gt;861. 翻转矩阵后的得分&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/score-after-flipping-matrix/&quot; title=&quot;leetcode链接&quot;&gt;861. 翻转矩阵后的得分&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;orange&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一个二维矩阵 A 其中每个元素的值为 0 或 1 。&lt;/p&gt;
&lt;p&gt;移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。&lt;/p&gt;
&lt;p&gt;在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。&lt;/p&gt;
&lt;p&gt;返回尽可能高的分数。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="每日一题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>仓库介绍</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/24/github/%E4%BB%93%E5%BA%93%E4%BB%8B%E7%BB%8D/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/24/github/%E4%BB%93%E5%BA%93%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-11-24T06:56:00.000Z</published>
    <updated>2020-11-24T14:06:41.085Z</updated>
    
    <content type="html"><![CDATA[<center><bold>深入理解操作系统课程学习 - 清华大学</bold>    <br><font size="1.5">    记录清华大学深入理解操作系统课程学习的笔记    </font></center><left><a href="https://github.com/OXygenPanda/Deep_into_OperatingSystem" target="_blank"><img src="https://img.shields.io/badge/Github-@Deep_into_OperatingSystem-f3e1e1.svg?style=flat-square&logo=GitHub"></a></left>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;bold&gt;
深入理解操作系统课程学习 - 清华大学
&lt;/bold&gt;
    &lt;br&gt;
&lt;font size=&quot;1.5&quot;&gt;
    记录清华大学深入理解操作系统课程学习的笔记
    &lt;/font&gt;
&lt;/center&gt;

&lt;left&gt;
&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="github" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/github/"/>
    
    
    <category term="github" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机网络</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/23/HugeFour/Network/Deep_into_Network/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/23/HugeFour/Network/Deep_into_Network/</id>
    <published>2020-11-23T11:20:00.000Z</published>
    <updated>2020-12-06T13:31:13.039Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a></p> <h1 id="计算机网络学习"><a href="#计算机网络学习" class="headerlink" title="计算机网络学习"></a>计算机网络学习</h1><p>本文章记录着小劳的计算机网络学习, 从2020.11.22开始学习, 目标能够掌握概念, 对网络编程有一个偏底层的理解. 学习自韩立刚老师的b站课程.</p><p>传送门 : <a class="btn" href="https://www.bilibili.com/video/BV17p411f7ZZ?p=1" title="传送门">b站 韩立刚 计算机网络</a></p><a id="more"></a><p><code>custom</code></p><h1 id="计算机网络-第一章"><a href="#计算机网络-第一章" class="headerlink" title="计算机网络 第一章"></a>计算机网络 第一章</h1><blockquote><p>  计算机网络第一章的主要内容是 : 概述</p></blockquote><h2 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h2><p>第一章 : 概述</p><p>第二章 : 物理层</p><p>第三章 : 数据链路层</p><p>第四章 : 网络层</p><p>第五章 : 运输层</p><p>第六章 : 应用层</p><p>第七章 : 网络安全</p><p>第八章 : 因特网上的音频,视频服务</p><p>第九章 : 无线网络</p><p>第十章 : 下一代因特网</p><h2 id="计算机网络在信息时代的作用"><a href="#计算机网络在信息时代的作用" class="headerlink" title="计算机网络在信息时代的作用"></a>计算机网络在信息时代的作用</h2><p>21世纪的特征 : 数字化, 网络化, 信息化</p><p>网络化 : 三网(电信网络, 计算机网络, 有线电视网络)</p><p>计算机网络 : 因特网, 其他网络(政府网络, 军用网络)</p><h3 id="计算机网络的重要功能"><a href="#计算机网络的重要功能" class="headerlink" title="计算机网络的重要功能"></a>计算机网络的重要功能</h3><p>连通性 : 彼此联通, 交换信息</p><p>共享 : 信息共享, 软硬件共享(软 : ssh ; 硬 : 打印机等设备)</p><h2 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2><p>终端到网络(路由器)的距离大约是100米, 路由器与路由器的连接扩展了网络的距离和接入网设备的数量.</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>网络 : 许多计算机连接在一起</p><p>互联网 : 许多网络连接在一起 (internet)</p><p>因特网 : 全球最大的一个互联网 (Internet, 使用 TCP/IP 协议)</p><h3 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h3><p>1st : ARPANET向互联网发展 (上世纪60年代 - 80 年代中期)</p><ul><li>1969年 分组交换网</li><li>1975年 互联网</li><li>1983年 TCP/IP (因特网起源)</li></ul><p>2nd : 三级结构的因特网 (上世纪80年代中期 - 90 年代初期)</p><ul><li>分层次, 比如 : 学校网 - 区域网 - 主干网(带宽 : 45 M)</li></ul><p>3rd : 多层次ISP结构的因特网</p><ul><li>ISP : Internet Service Provider 因特网服务提供商</li><li>第一层ISP - 第二层ISP - 第三层ISP(提供接入) - 校园网等</li><li>如果服务器需要提供的客户范围较小, 应该接入越低层的ISP</li></ul><h3 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h3><p>因特网协会 : ISOC</p><p>因特网体系结构委员会 IAB :</p><ul><li>因特网研究部 IRTF :<ul><li>因特网研究指导小组 IRSG</li></ul></li><li>因特网工程部 IETF :<ul><li>因特网工程指导小组 IESG</li></ul></li></ul><h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><p><strong>因特网的核心部分</strong></p><p><strong>因特网的边缘部分</strong></p><p>主机之间的通信方式 :</p><ul><li>客户端服务器方式 (Client / Server 方式)</li><li>对等方式 (Peer-to-Peer 方式)</li></ul><p>数据交换方式 :</p><ul><li>电路交换 (Circuit Switching)<ul><li>交换机同时只能提供网络中的两个终端通信</li><li>过程 : 申请占用通信资源, 一直占用通信资源, 释放通信资源</li><li>适用于 : 实时性通信, 核心路由器之间可以使用电路交换</li></ul></li><li>报文交换 (Message Switching)<ul><li>报文一般比分组长的多</li><li>报文交换的时延较长</li></ul></li><li>分组交换 (Packet Switching)<ul><li>完整的一个数据包称为报文, 需要分为多个组进行发送</li><li>每一个分组带上一个首部</li><li>分组的优势在于, 通信时路径可以复用</li><li>接收端去电首部后, 拼接分组成报文</li><li>路由器有存储转发功能</li><li>优点 : 高效, 灵活, 迅速, 可靠</li><li>问题 : 时延, 开销</li></ul></li></ul><h2 id="计算机在我国的发展"><a href="#计算机在我国的发展" class="headerlink" title="计算机在我国的发展"></a>计算机在我国的发展</h2><p>中国在1994年4月20日正式接入互联网.</p><h2 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h2><p>计算机网络最简单的定义 : 一些互相连接的, 自治的计算机的集合</p><p>作用范围(使用的技术) :</p><p>广域网 : WAN (花钱买服务, 花钱买带宽</p><p>城域网 : MAN</p><p>局域网 : LAN (自己购买设备, 带宽固定, 自己维护, 距离100米之内)</p><p>使用者 : 公用网, 专用网</p><p>拓扑结构 : 总线型, 环型, 星型, 树型, 网状</p><p>交换方式 : 电路交换, 报文交换, 分组交换</p><p>工作方式 : 资源子网, 通信子网, 接入网</p><h2 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h2><p>以下5点是性能指标 :</p><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>速率是指连接在计算机网络上的主机在<strong>数字信道</strong>上传送数据位数的速率, 也称为 data rate 或者 bit rate. 单位是 b/s kb/s Mb/s Gb/s</p><p>一般来说, 运营商告诉的100M是指100Mbps, 转换成下行速率是 100 / 8 = 12.5 Mbit / s</p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>带宽是指数据通信领域中, <strong>数字信道</strong>所能传送的最高速率</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>吞吐量是指在单位时间内通过<strong>某个网络</strong>的数据量</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p><p>发送时延 = 数据块长度(比特) / 信道带宽(比特/秒)</p><p>传播时延 = 信道长度(米) / 信号在信道上的传播速率(米/秒)</p><p>处理时延 = 网络节点存储转发处理时间</p><p>排队时延 = 网络节点缓存队列排队时间</p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>信道利用率 = 有数据通过时间 / (有 + 无) 数据通过时间</p><p>网络利用率 = 信道利用率加权平均值</p><p>D = D0 / (1 - U) [D0 : 网络空闲时延 D : 网络当前时延 U : 信道利用率]</p><p>以下7点是非性能指标 : 费用, 质量, 标准化, 可靠性, 可扩展性, 可升级性, 管理与维护</p><h2 id="计算机网络的体系机构"><a href="#计算机网络的体系机构" class="headerlink" title="计算机网络的体系机构"></a>计算机网络的体系机构</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>ISO : 国际标准化组织</p><p>OSI/RM : 互联网法律上的国际标准</p><p>TCP/IP Suite : 因特网事实上的国际标准</p><p>Network Protocols : 数据交换遵守的规则, 标准或约定</p><p>网络体系结构 : 计算机网络各层及协议的集合</p><h3 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h3><p><strong>OSI 是七层模型 :</strong></p><p>​    应用层 - 能够产生网络流量, 能够和用户交互的应用程序</p><p>​    表示层 - 加密, 压缩, 编解码 (开发人员考虑)</p><p>​    会话层 - 服务和客户端建立的会话 查木马 netstat -nb | more</p><p>​    传输层 - 可靠传输建立会话, 不可靠传输不建立会话(QQ发消息, DNS解析), 流量控制</p><p>​    网络层 - IP地址编址 选择最佳路径 动态路由</p><p>​    链路层 - 数据如何封装 为数据包添加物理层地址(MAC地址)</p><p>​    物理层 - 电压 接口标准</p><p><strong>分层的作用 :</strong> 1.标准化 ; 2.降低耦合度</p><p>开发者考虑应用层到会话层, 网络工程师考虑传输层到链路层</p><p><strong>网络排错 :</strong> 从底层往上检查(比如 : 先看网线, IP, 浏览器检查)</p><p><strong>网络安全和OSI参考模型 :</strong></p><p>​    物理层安全 - 给别人提供了接入网络的机会</p><p>​    链路层安全 - ADSL密码, 无线网卡密码</p><p>​    网络层安全 - 网关设置内网中某些网段可以访问外网, 某一些不可以</p><p>​    应用层安全 - SQL注入漏洞, 上传漏洞(文件类型检查)</p><h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p><strong>TCP/IP 是五层模型 :</strong></p><p>​    应用层</p><p>​    传输层</p><p>​    网络层</p><p>​    链路层</p><p>​    物理层</p><p><strong>开放系统信息交换涉及的概念 :</strong></p><p>实体 : 交换信息的硬件和软件的进程</p><p>协议 : 控制两个对等实体通信的规则</p><p>服务 : 下层向上层提供服务, 上层需要使用下层提供的服务来实现本层的功能</p><p>服务访问点 : 相邻两层实体间交换信息的地方</p><p><strong>TCP/IP 模型的数据单元 :</strong></p><p>​    应用层 - 传输数据单元 PDU</p><p>​    运输层 - 运输层报文</p><p>​    网络层 - IP数据报(IP分组)</p><p>​    数据链路层 - 数据帧</p><p>​    物理层 - bits</p><h1 id="计算机网络-第二章"><a href="#计算机网络-第二章" class="headerlink" title="计算机网络 第二章"></a>计算机网络 第二章</h1><p>由于是物理层, 暂时先跳过学习</p><h1 id="计算机网络-第三章"><a href="#计算机网络-第三章" class="headerlink" title="计算机网络 第三章"></a>计算机网络 第三章</h1><blockquote><p>  第三章的主要内容是 : 数据链路层</p></blockquote><h2 id="数据链路层基本概念及基本问题"><a href="#数据链路层基本概念及基本问题" class="headerlink" title="数据链路层基本概念及基本问题"></a>数据链路层基本概念及基本问题</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>数据发送模型 :</p><ul><li>主机1 - 电话网 - 路由器1 - 局域网 - 路由器2 - 广域网 - 路由器3 - 局域网 - 主机2.</li><li>在路由器上数据上升到网络层, 再进行转发.</li></ul><p>数据链路层的信道类型 :</p><ul><li>点对点信道</li><li>广播信道</li></ul><p>链路与数据链路 :</p><ul><li>链路 (link) 是一条点对点的物理线路段</li><li>数据链路 (data link) 除了物理线路外, 还必须有通信协议来控制这些数据的传输</li></ul><p>帧 :</p><ul><li>链路层传输的数据单元</li><li>获得网络层的数据报增加帧头和帧尾, 传递给物理层</li></ul><h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><ol><li><p>封装成帧(一定要知道哪里开始哪里结束)</p><p>封装成帧就是在一段数据的前后分别添加首部和尾部, 然后就构成一个帧, 确定帧的边界.</p><p>首部和尾部的一个重要作用就是进行帧定界.</p><p>帧的数据部分长度最大为1500字节.</p><p>帧首部和帧尾部定界的作用 : 确保数据的完整性</p></li><li><p>透明传输(数据中存在开始和结束的标识, 进行转变)</p><p>在帧数据部分出现了SOH帧首部或EOT帧尾部内容, 会出现提前结束.</p><p>解决方法 :</p><ul><li>发送端的数据链路层在数据中出现控制字符”SOH”或者”EOT”的前面插入转义字符”ESC”(十六进制编码为1B).</li><li>字节填充或字符填充——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符.</li><li>如果转义字符也出现在数据中, 那么应该在转义字符前插入一个转义字符. 当接收端收到连续的两个转义字符时, 就删除前面一个.</li></ul></li><li><p>差错控制(检查帧的正确性)</p><p>传输过程中可能会产生比特差错 : 1 可能会变成 0 , 0 可能会变成 1.</p><p>在一段时间内, 传输错误的比特占所传输比特总数的比率称为误码率 BER (bit error rate).</p><p>误码率与信噪比有很大的关系.</p><p>为了保证数据传输的可靠性, 在计算机网络传输数据时, 必须采用各种差错检测措施.</p><p>循环冗余检验 CRC :</p><ul><li>在数据链路层传送的帧中, 广泛使用了 CRC 的技术.</li><li>在发送端, 先把数据划分为组. 假定每组为 k 个比特</li><li>假设待传送的一组数据 M = 101001 (k = 6), 我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送.</li><li>101001 - 000 (增加3位0, 要求除数是4位) / 1101 = 001 (FCS) , 把001加在101001后面, 组成 101001001 , 接收方除以相同的四位数 1101, 如果最终结果是 0 , 说明没有出错. 这个四位数 1101 或者更多位的数, 是链路层保证双方相同的.</li><li>链路层的差错控制, 是无差错接收, 只接受没有比特差错的情况, 不需要重传.(重传是传输层的要求)</li></ul><p>帧检验序列 FCS :</p><ul><li>在数据后面添加上的冗余码称为帧检验序列 FCS.</li><li>循环冗余检验 CRC 和帧检验序列 FCS 并不等同. (CRC 不是获得 FCS 的唯一途径)</li></ul></li></ol><h2 id="两种情况下的数据链路层"><a href="#两种情况下的数据链路层" class="headerlink" title="两种情况下的数据链路层"></a>两种情况下的数据链路层</h2><h3 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h3><p><strong>PPP协议( Pointer-to-Pointer Protocol)</strong></p><p>用户使用拨号电话线接入因特网的时候, 一般都是使用PPP协议. 具有拨号, 身份验证, 可以记账的特性.</p><p><strong>PPP协议应该满足的要求 :</strong> 简单, 封装成帧, 透明性, 多层网络层协议, 多种类型链路, 差错检测, 检测连接状态, 最大传送单元, 网络层地址协商, 数据压缩协商.</p><p><strong>PPP协议不需要满足的要求 :</strong> 纠错, 流量控制, 序号, 多点线路, 半双工或单工链路.</p><p><strong>PPP协议的组成 :</strong></p><ul><li>数据链路层协议可以用于异步串行或同步串行介质.</li><li>它使用LCP(链路控制协议)建立并维护数据链路连接.</li><li>网络控制协议(NCP)允许在点到点连接上使用多种网络层协议.</li></ul><p>|3. 上层协议 : IP IPX AppleTalk |</p><p>|2. 网络控制协议 NCP 针对每一个网络层协议 |</p><p>|2. 链路控制协议 LCP |</p><p>|2. 高级数据链路控制协议 HDLC |</p><p>|1. 物理层 |</p><p><strong>PPP协议帧格式 :</strong></p><p>首部 : | F{1} | A{1} | C{1} | 协议{2} | . 其中, A,C = FF,03 是固定的. 一般 首部和尾部的 : F(=7E)</p><ul><li>协议{2} :<ul><li>0x0021 - PPP帧的信息字段就是IP数据报</li><li>0xC021 - 信息字段是PPP链路控制数据</li><li>0x8021 - 网络控制数据</li><li>0xC023 - 安全性认证PAP</li><li>0xC025 - LQR</li><li>0xC223 - 安全性认证CHAP</li></ul></li></ul><p>数据部分 : IP数据报不超过1500字节.</p><p>尾部 : | FCS{2} | F{1} | . PPP协议的头尾的 F(=7E) 字段相同.</p><p>使用PPP协议以字节为单位还是以比特为单位发送数据时, 填充方案不相同, 具体如下 :</p><p><strong>字节填充 :</strong></p><ul><li>信息字段出现标志字段的值的问题 : 信息字段的 0x7E 被拆分称为0x7D 0x5E, 信息字段的 0x7D 被拆分成0x7D 0x5D, ASCII 控制符(数值小于0x20)前加一个 0x7D 字节.(因此实际传输的信息可能是达不到1500字节)</li></ul><p><strong>零比特填充方法 :</strong></p><ul><li>避免出现和 0x7E 一样的比特序列, 0111,1110, 因此连续5个1补一个0</li><li>PPP协议用在SONET/SDH链路时, 是使用同步传输一连串的比特连续传送). 这时, PPP协议采用零比特填充方法来实现透明传输.</li><li>在发送端, 只要连续发现5个连续的1, 就立即填充一个0. 接收端扫描时, 5个连续的1后删除1个0.(可以用于避免0x7E的出现)</li></ul><p><strong>PPP协议的工作状态 :</strong></p><ul><li>当用户拨号接入ISP时, 路由器的调制解调器对拨号做出确认, 并建立一条物理连接.</li><li>PC机向路由器发送一系列的LCP分组(封装成多个PPP帧).</li><li>这些分组及其响应选择一些PPP参数, 和进行网络层配置, NCP给新接入的PC机分配一个临时的IP地址, 使PC机称为因特网上的一个主机.</li><li>通信完毕时, NCP释放网络层连接, 收回原来分配出去的IP地址. 接着, LCP释放数据链路层连接. 最后释放的是物理层连接.</li></ul><h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><p><strong>补充知识 : 局域网的特定与优点</strong></p><p>局域网最主要的特点是 : 网络为一个单位所拥有, 且地理范围和结点数目均有限.</p><p>局域网具有如下的一些主要优点 :</p><ul><li>具有广播功能, 从一个站点可以很方便地访问全网. 局域网上的主机可以共享连接在局域网上的各种硬件和软件资源.</li><li>便于系统的扩展和逐渐地演变, 各设备的位置可灵活调整和改变.</li><li>提高了系统的可靠性, 可用性和生存性.</li></ul><p><strong>共享通信媒体</strong></p><p>静态划分信道 : 频分复用, 时分复用, 波分复用, 码分复用.</p><p>动态媒体接入控制(多点接入) : 随机接入(被以太网采用), 受控接入(已不被采用)</p><p><strong>认识以太网</strong></p><p>最初的以太网是将许多计算机都连接在一根总线上. 当初认为这样的链接方式既简单又可靠, 因为总线上没有有源器件. 问题是, 同时只有一个设备发送数据, 而且所有的设备都可以接收到数据包, 不够安全.</p><p><strong>以太网协议 :</strong></p><p>以太网使用的是CSMA/CD协议 (带冲突检测的多点接入技术)</p><p>多点接入 : 表示许多计算机以多点接入的方式连接在一根总线上</p><p>载波监听 : 是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据, 如果有, 则暂时不要发送数据, 以免碰撞.</p><p><em>(P35 以太网的冲突检测暂时跳过)</em></p><h2 id="以太局域网"><a href="#以太局域网" class="headerlink" title="以太局域网"></a>以太局域网</h2><p><strong>以太网的两个标准 :</strong></p><ol><li>DIX Ethernet V2 是世界上第一个局域网产品(以太网)的规约.</li><li>IEEE 的 802.3 标准.</li></ol><p><strong>以太网与数据链路层的两个子层 :</strong></p><p>为了使数据链路层能更好地适应多种局域网标准, 802 委员会就将局域网的数据链路层拆成两个子层 :</p><ol><li>逻辑链路控制 LLC 子层</li><li>媒体接入控制 MAC 子层</li></ol><p><strong>以太网提供的服务 :</strong></p><p>以太网提供的服务是不可靠的交付, 即尽最大努力的交付.</p><p>当接收站收到有差错的数据帧时就丢弃此帧, 其他什么都不做. 差错的纠正由高层来决定.</p><p>如果高层发现丢弃一些数据而进行重传, 但以太网并不知道这是一个重传的帧, 而是当做一个新的数据帧来发送.</p><p><em>(集线器部分暂时跳过)</em></p><p>以太网的<strong>信道利用率 :</strong></p><p>以太网的信道被占用的情况 :</p><p>争用期长度为 2tao , 即端到端传播时延的两倍. 检测到碰撞后不发送干扰信号.</p><p>帧长为 L (bit) , 数据发送速率为 C (b/s) , 因而帧的发送时间为 L/C = T0 (s)</p><p>信道利用率的最大值 : 各站发送数据都不发生碰撞的话, Smax = T0 / (T0 + tao)</p><p><strong>MAC层 :</strong></p><p>在局域网中, 硬件地址又称为物理地址, 或 MAC 地址.</p><p>MAC地址一共是48位二进制位, 其中高24位为厂家地址段, 低24位由厂家自行指派.</p><p>适配器检查MAC地址 :</p><p>适配器从网络上每收到一个MAC帧就首先用硬件检查MAC帧中的MAC地址 :</p><ul><li>如果是发送往本站的帧则手下, 然后再进行其他的处理.</li><li>否则就将此帧丢弃, 不再进行其他的处理.</li></ul><p>“发往本站的帧” 包括以下三种类型的帧 :</p><ol><li>单播帧 (一对一)</li><li>广播帧 (一对全体) (MAC地址全1)</li><li>多播帧 (一对多)</li></ol><p><strong>以太网帧格式 :</strong></p><p>MAC帧 : | 目的地址{6} | 源地址{6} | 类型{2} | IP数据报{46 - 1500} | FCS{4} |  最短是64字节</p><p>物理层 : | 前同步码{7} | 帧开始定界符{1} | MAC帧 |</p><p><strong>无效的MAC帧 :</strong></p><ul><li>帧的长度不是整数个字节;</li><li>用收到的帧检验序列 FCS 查出有差错;</li><li>数据字段的长度不在 46 ~ 1500 字节之间;</li><li>有效的MAC帧长度为 64 ~ 1518 字节之间;</li><li>对于检查出的无效的MAC帧就简单地丢弃. 以太网不负责重传丢弃的帧.</li></ul><p><strong>帧间最小间隔 :</strong></p><p>帧间最小间隔为 9.6 us , 相当于 96 bit 的发送时间.</p><p>一个站在检测到总线开始空闲时, 还要等待 9.6 us 才能再次发送数据.</p><p>这样做是为了使刚刚收到的数据帧的站的接收缓存来得及清理, 做好接收下一帧的准备.</p><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><p>集线器<strong>扩展 :</strong> 主机使用光纤和一对光纤调制解调器连接到集线器. 使用集线器连接最好低于30台机器, 冲突域变少, 冲突增大.</p><p><strong>网桥扩展 :</strong> 在一个较小的冲突域里收发数据, 网桥不会转发到其他冲突域中, 可以减少冲突. 网桥有自学习算法并且建立转发表.</p><p>透明网桥使用了生成树算法 : 为了避免产生转发的帧在网络中不断地兜圈子.</p><p><strong>交换机(多接口的高速网桥)扩展 :</strong> 安全, 效率高, 10M的交换机指的是每一个端口都是10M, 每一个端口都是全双工</p><p>交换机学习到的转发表格式 : | Vlan | Mac Address | Type | Ports |</p><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p><strong>LAN和VLAN :</strong></p><p>交换机的使用使得VLAN的创建成为可能.</p><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组.</p><ul><li>这些网段具有某些共同的需求.</li><li>每一个 VLAN 的帧都有一个明确的标识符, 指明发送这个帧的工作站是属于哪一个 VLAN.</li></ul><p>虚拟局域网其实只是局域网给用户提供的一种服务, 而不是一种新型局域网.</p><p>一个 VLAN = 一个广播域 = 逻辑网段(子网)</p><p><strong>ISL 标记(思科方式) :</strong></p><p>ISL 干道使 VLAN 能够跨骨干</p><ul><li>通过特定集成电路来实现</li><li>不需要再客户计算机上采取配置, 客户机不能够看到ISL头</li><li>在交换机之间, 路由器和交换机, 交换机和支持ISL网卡的服务器之间配置</li></ul><p>ISL 封装 : | DA | Type | User | SA | LEN | AAAA03 | HSA | VLAN | BPDU | INDEX | RES | 以太网帧 | CRC |</p><p><strong>虚拟局域网帧格式 :</strong></p><p>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符, 称为 VLAN 标记 (tag) , 用来指明发送该帧的工作站属于哪一个虚拟局域网.</p><p>格式 : | 目的地址{6} | 源地址{6} | VLAN标记{4} | 类型{2} | 数据{46 ~ 1500} | FCS{4} |</p><h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><p>速率达到或超过 100 Mb/s 的以太网称为高速以太网.</p><p><strong>100BASE-T 以太网 :</strong> 可以全双工方式下工作而无冲突发生. 因此, 不使用 CSMA/CD 协议. MAC帧格式仍然是 802.3 标准规定的. 帧间时间间隔从 9.6 us 变成了 0.96 us.</p><p><strong>吉比特以太网 :</strong> 允许在1 Gb/s 下全双工和半双工两种方式工作. 使用 802.3 协议规定的帧格式. 在半双工方式下使用 CSMA/CD 协议, 全双工不需要. 与 10BASE-T 和 100BASE-T 技术向后兼容.</p><p><strong>10吉比特以太网 :</strong> 以太网的工作范围已经从局域网(校园网, 企业网)扩大到城域网和广域网, 从而实现了端到端的以太网传输. 这种工作方式的好处是 : 成熟的技术, 互操作性好, 在广域网中使用以太网时价格便宜, 统一的帧格式简化了操作和管理.</p><h3 id="Cisco建网3层模型"><a href="#Cisco建网3层模型" class="headerlink" title="Cisco建网3层模型"></a>Cisco建网3层模型</h3><p>普通的交换机 : 连接计算机, 需要接口数量多</p><p>汇聚层交换机 : 连接普通的交换机, 一般单位是整栋楼</p><p>核心层交换机 : 连接汇聚层交换机, 一般单位是一个一个区域</p><h3 id="交换机安全"><a href="#交换机安全" class="headerlink" title="交换机安全"></a>交换机安全</h3><p>交换机可以设置某一个端口只能和指定的MAC地址的主机交换数据, 保证链路层安全. 也可以设置某个端口只能连接一台计算机. 否则, 关闭端口.</p><h1 id="计算机网络-第四章"><a href="#计算机网络-第四章" class="headerlink" title="计算机网络 第四章"></a>计算机网络 第四章</h1><blockquote><p>  第四章的主要内容是 : 网络层</p></blockquote><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><p>网络层关注的是如何将分组从源端沿着网络路径送达目的端.</p><p>两种服务 :</p><ol><li>虚电路服务</li><li>数据报服务</li></ol><h3 id="虚电路-专线-固定-不需要写IP地址"><a href="#虚电路-专线-固定-不需要写IP地址" class="headerlink" title="虚电路(专线,固定. 不需要写IP地址)"></a>虚电路(专线,固定. 不需要写IP地址)</h3><p>虚电路表示这是一条逻辑上的连接, 分组都沿着这条逻辑连接按照存储转发方式传送, 而并不是真正建立了一条物理连接. 电路交换的电话通信是先建立一条真正的连接. 因此分组交换的虚连接和电路交换的连接只是类似, 并不完全一样.</p><h3 id="数据报-灵活-低耦合-需要写IP地址"><a href="#数据报-灵活-低耦合-需要写IP地址" class="headerlink" title="数据报(灵活,低耦合. 需要写IP地址)"></a>数据报(灵活,低耦合. 需要写IP地址)</h3><p>网络层向上只提供简单灵活的, 无连接的, 尽最大努力交付的数据报服务. 网络在发送分组时不需要先建立连接. 每一个分组(IP数据报)独立发送, 与其前后的分组无关. 网络层不提供服务质量的承诺. 即所传送的分组可能出错, 丢失, 重复和失序, 当然也不保证分组传送的时限.</p><p>尽最大努力交付的好处 :</p><ul><li>由于传输网络不提供端到端的可靠传输服务, 这就使网络中的路由器可以做的比较简单, 而且价格低廉.</li><li>如果主机中的进程通信需要是可靠的, 那么就由网络的主机中的运输层负责(包括差错处理, 流量控制等).</li><li>采用这种设计思路的好处是 : 网络的造价大大降低, 运行方式灵活, 能够适应多种应用.</li><li>因特网能够发展到今日的规模, 充分证明了当初采用这种设计思路的正确性.</li></ul><h3 id="虚电路服务和数据报服务的比较"><a href="#虚电路服务和数据报服务的比较" class="headerlink" title="虚电路服务和数据报服务的比较"></a>虚电路服务和数据报服务的比较</h3><p><strong>虚电路</strong></p><p>思路 : 可靠通信应当由网络来保证</p><p>连接的建立 : 必须有</p><p>终点地址 : 仅在连接建立阶段使用, 每个分组使用短的虚电路号</p><p>分组的转发 : 属于同一条虚电路的分组均按照同一路由进行转发</p><p>当结点出故障时 : 所有通过出故障的结点的虚电路均不能工作</p><p>分组的顺序 : 总是按发送顺序到达终点</p><p>端到端的差错处理和流量控制 : 可以由网络负责, 也可以由用户主机负责</p><p><strong>数据报</strong></p><p>思路 : 可靠通信应当由用户主机来保证</p><p>连接的建立 : 不需要</p><p>终点地址 : 每个分组都有终点的完整地址</p><p>分组的转发 : 每个分组独立选择路由进行转发</p><p>当结点出故障时 : 由故障的结点可能会丢失分组, 一些路由可能会发生变化</p><p>分组的顺序 : 到达终点时不一定按发送顺序</p><p>端到端的差错处理和流量控制 : 由用户主机负责</p><h2 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h2><h3 id="虚拟互联网"><a href="#虚拟互联网" class="headerlink" title="虚拟互联网"></a>虚拟互联网</h3><p><strong>网络互连的设备</strong></p><p>中间设备又称为中间系统或者中继系统.</p><ul><li>物理层中继系统 : 转发器 或者 集线器</li><li>数据链路层中继系统 : 网桥 或者 交换机</li><li>网络层中继系统 : 路由器</li><li>网络层以上的中继系统 : 网关</li></ul><p>当中继系统是集线器或网桥时, 一般不称为网络互连, 因为这仅仅是把一个网络扩大了, 而这仍然是一个网络.</p><p>网关由于比较复杂, 目前使用的较少.</p><p>互联网都是指用路由器进行互连的网络.</p><p>由于历史原因, 许多有关 TCP/IP 的文献将网络层使用的路由器称为网关.</p><p><strong>网络互联的问题</strong></p><p>互联在一起的网络要进行通信, 会遇到许多问题需要解决, 如 : 不同的寻址方案, 不同的最大分组长度, 不同的网络接入机制, 不同的超时控制, 不同的差错恢复方法, 不同的状态报告方法, 不同的路由选择技术, 不同的用户接入控制, 不同的服务, 不同的管理与控制方式.</p><p><strong>IP协议简介</strong></p><p>网际协议IP 是 TCP/IP 体系中两个最主要的协议之一. 与 IP协议配合使用的还有四个协议 :</p><ol><li>地址解析协议 ARP <em>(Address Resolution Protocol)</em></li><li>逆地址解析协议 RARP <em>(Reserve Address Resolution Protocol)</em></li><li>网际控制报文协议 ICMP <em>(Internet Control Message Protocol)</em></li><li>网际组管理协议 IGMP <em>(Internet Group Management Protocol)</em></li></ol><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p><strong>IP层次结构</strong></p><p>层次化IP地址 : 层次化IP地址将32位的IP地址分为网络ID和主机ID</p><p><strong>网络地址</strong></p><p>网络地址唯一指定了每一个网络. 同一网络中的每台计算机都共享相同的网络地址, 并用它作为自己IP地址的一部分.</p><p>A类地址 : 8位网络号 (net-id : 0…….)</p><ul><li>最大网络数 126 第一个可用的网络号 1 最后一个可用的网络号 127 每个网络的最大主机数 16777214</li></ul><p>B类地址 : 16位网络号(net-id : 10…… ……..)</p><ul><li>最大网络数 16383 第一个可用的网络号 128.1 最后一个可用的网络号 191.255 每个网络的最大主机数 65534</li></ul><p>C类地址 : 24位网络号(net-id : 110….. …….. ………)</p><ul><li>最大网络数 2097151 第一个可用的网络号 192.0.1 最后一个可用的网络号 223.255.255 每个网络的最大主机数 254</li></ul><p>D类地址 : 组播 (1110 28.)</p><p>E类地址 : 研究 (1111 28.)</p><p>特殊的几个地址 : ****</p><p>127.0.0.1 本地回环地址</p><p>169.254.0.0 无法自动分配地址时,分配这个网段</p><p>RFC1918指明的专用地址(private address):</p><ul><li>10.0.0.0 - 10.255.255.255</li><li>172.16.0.0 - 172.31.255.255</li><li>192.168.0.0 - 192.168.255.255</li></ul><p><strong>子网掩码</strong></p><p>子网掩码的作用是确定IP地址的网络号的位数.</p><h3 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h3><p><strong>划分子网</strong></p><p>划分子网可以让一个网络号继续拆分出多个子网, 使得使用更加地充分.</p><p>比如, 一个C类地址的网络号是24位, 可以容纳254台主机, 可以进一步使用第25位主机号用于子网络号, 拆分126台和126台主机的两个子网.同时, 子网掩码也要往后移动一位.</p><p>划分四个子网时, 取2位作为子网络号, 因此可以用的主机号范围是 :</p><p>A: (0网络) 1 - 62 (63广播)</p><p>B: 65 - 126</p><p>C: 129 - 190</p><p>D: 192 - 254</p><p>网关是主机号为1的IP地址, 是路由器的出口IP地址.</p><p>广播是主机号为最大的IP地址.</p><p>最小划分到, 网络号为24位,子网络号为6位,主机号为2位: 00网络,01网关,02主机,03广播.</p><p><strong>构造超网</strong></p><p>将网络号左移若干位, 可以构造超网.</p><h3 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h3><p>使用IP地址通信, 而不是直接使用MAC地址通信, 是因为, IP地址可以确定源地址和目标地址, 而MAC地址在每一次转发的时候都需要改变. 除非没有网络层设备, 所有主机全部使用超大的交换机相连, 每一次广播都可以得知目标MAC地址的主机进行转发.</p><p><strong>ARP协议</strong></p><p>IP地址 → ARP → MAC地址</p><p>ARP欺骗: 在同一个网段里的计算机在需要知道一个IP地址的MAC地址时,会进行广播, 这个时候本应只有网关会回复你, 但是有其他主机告诉你MAC地址的话, 你就会受到ARP欺骗, 他把他自己作为”网关”, 可以控制每一个主机的带宽.</p><p><strong>RARP协议</strong></p><p>MAC地址 → RARP → IP地址(地址请求的过程)</p><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p>首部{20} | 数据部分</p><p>首部{20} :</p><p>| 版本{4b} | 首部长度{4b} | 区分服务{1} | 总长度{2} |</p><p>| 标识{2} | 标志{3b} | 片偏移{29b} |</p><p>| 生存时间{1} | 协议{1} | 首部检验和{2} |</p><p>| 源地址{4} |</p><p>| 目的地址{4} |</p><p>可变部分 : | 可选字段 | 填充至4字节的整数倍 |</p><p>| 数据部分 |</p><p>版本 : 4位,指定IP协议版本(IPv4, IPv6)</p><p>首部长度 : 4位,除数据部分以外的首部有多长(4位能够表示0-15,一个数代表4个字节,因此最大值为60字节)</p><p>区分服务 : 8位,只有使用区分服务,该字段才起作用.</p><p>总长度 : 16位,首部和数据之和的长度.(因此最大值为65535字节,不能超过最大传送单元MTU)</p><p>标识 : 16位,计数器,用来产生数据报的标识,不是序号,每产生一个数据包+1</p><p>标志 : 3位,目前只有前两位有意义,标志字段的最低位是MF.MF=1标识后面还有分片,MF=0标识后面没有分片.标识字段中间位是DF,只有DF=0才允许分片.</p><p>片偏移 : 13位,较长的分组在分片后,某片在原分组中的相对位置,片偏移以8个字节为偏移单位.比如1400/8 = 175</p><p>生存时间 : 8位,记为TTL,经过路由器的C++最大跳数</p><p>协议 : 8位,标记数据报携带的数据使用的协议</p><p>首部校验和 : 16位,用于检错,反码算术运算求和</p><p>可变部分 : 支持排错,测量以及安全等措施,1字节-40字节,很少被用到.</p><h3 id="IP转发分组的流程"><a href="#IP转发分组的流程" class="headerlink" title="IP转发分组的流程"></a>IP转发分组的流程</h3><p>数据路由: 路由器在不同网段转发数据报</p><p>网络畅通的条件: 能去能回,沿途的路由器都必须知道到源地址和目标地址网络下一跳给哪个接口</p><h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><h3 id="ICMP简介"><a href="#ICMP简介" class="headerlink" title="ICMP简介"></a>ICMP简介</h3><p>为了提高IP数据报交付成功的机会,在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol)</p><p>ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告</p><p>ICMP不是高层协议,而是IP层协议</p><p>ICMP报文作为IP层数据报的数据,加上数据报的首部,组成IP数据报发送出去.</p><h3 id="ICMP种类"><a href="#ICMP种类" class="headerlink" title="ICMP种类"></a>ICMP种类</h3><p>ICMP报文的种类有两种,即ICMP差错报告报文和ICMP询问报文.</p><p>ICMP的前4个字节是统一的格式,共有三个字段: 即类型,代码和检验和.接着的4个字节的内容与ICMP的类型有关.</p><p><strong>差错报告报文(ping指令收到的是差错报告)</strong></p><p>有五种: 终点不可达,源点抑制,时间超过,参数问题,改变路由(重定向)</p><p><strong>询问报文(ping指令发送的是询问)</strong></p><p>有两种: 回送请求和回答报文,时间戳请求和回答报文</p><h3 id="ping的过程"><a href="#ping的过程" class="headerlink" title="ping的过程"></a>ping的过程</h3><p>A —ping—&gt; B</p><p>A 创建一个数据报, 格式如: | IP数据报首部 | 8字节 | IP数据报的数据字段(前面的8字节也属于IP数据报数据) |</p><p>B 收到ICMP询问报文后, 丢弃8字节以外的IP数据报的数据字段,组装ICMP的前8字节, 格式如: | 首部 | ICMP前8字节 | IP数据报首部 | 8字节 | 再发送给 A</p><h2 id="因特网的路由选择协议"><a href="#因特网的路由选择协议" class="headerlink" title="因特网的路由选择协议"></a>因特网的路由选择协议</h2><h3 id="RIP动态路由协议"><a href="#RIP动态路由协议" class="headerlink" title="RIP动态路由协议"></a>RIP动态路由协议</h3><p>RIP协议最早, 每30秒周期性地广播, 每一个目的地告诉相邻路由器0跳能到自己,路由器告诉相邻路由器1跳能到,然后不断地告诉其他路由器,如果某一条路径断开,30秒之后又能重新选择到一条通路.(依据跳数不一定是最佳路径,有一些跳数大的路径带宽大)</p><h3 id="OSPF内部网关协议"><a href="#OSPF内部网关协议" class="headerlink" title="OSPF内部网关协议"></a>OSPF内部网关协议</h3><p>向本自治系统中所有路由器发送信息,这里使用的方法是洪泛法. 发送的信息就是与本路由器相邻的所有路由器的链路状态, 但这是路由器所知道的部分信息. 只有当链路状态发生变化时,路由器才用洪泛法向所有路由器发送此信息.</p><p>相比RIP协议,OSPF是触发式更新路由表.</p><p>OSPF维护三个表:</p><ol><li>邻居表 hello包(局域网2s一次)</li><li>链路状态表 互相交换邻居表,构造网络拓扑图</li><li>计算路由表 迪杰斯特拉算法来计算最短路径,路径值是带宽</li></ol><h3 id="BGP外部网关协议"><a href="#BGP外部网关协议" class="headerlink" title="BGP外部网关协议"></a>BGP外部网关协议</h3><p>BGP是不同自治系统的路由器之间交换路由信息的协议.边界网关协议BGP只能是力求寻找一条能够到达目的网络且较好的路由(不能成环),而非寻找一条最佳的路径.每一个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人.</p><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>VPN: 在互联网上传输私网数据, 因为私网数据不能在广域网上传输,所以在数据报前面再增加一个目标网络网关的目标地址和自己的网关源地址. 目标网关获得数据报之后解析得到一个数据报,目标地址是私网中的某个主机.</p><p>例如:</p><p>局域网数据报: | 10.0.0.2 | 10.0.0.8 | 数据 |</p><p>广域网数据报: | 23.23.2.2 | 23.23.2.20 | 10.0.0.2 | 10.0.0.8 | 数据 |</p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>1994年提出.</p><p>需要在专用网连接到因特网的路由器上安装NAT软件. 装有NAT软件的路由器叫做NAT路由器.它至少有一个有效的外部全球地址IPg.  所有使用本地地址的主机和外界通信时都要在NAT路由器上将其本地地址转换成IPg才能和因特网连接.</p><p>私网里的IP和端口号都被NAT路由器进行了转换,端口使用的是NAT的端口,存储一张IP与端口映射表即可.</p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;Website&quot; src=&quot;https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&amp;logo=Blogger&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://www.github.com/OXygenPanda&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&amp;logo=GitHub&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&amp;logo=WeChat&quot;&gt;&lt;/a&gt;
&lt;/p&gt; 




&lt;h1 id=&quot;计算机网络学习&quot;&gt;&lt;a href=&quot;#计算机网络学习&quot; class=&quot;headerlink&quot; title=&quot;计算机网络学习&quot;&gt;&lt;/a&gt;计算机网络学习&lt;/h1&gt;&lt;p&gt;本文章记录着小劳的计算机网络学习, 从2020.11.22开始学习, 目标能够掌握概念, 对网络编程有一个偏底层的理解. 学习自韩立刚老师的b站课程.&lt;/p&gt;
&lt;p&gt;传送门 : &lt;a class=&quot;btn&quot; href=&quot;https://www.bilibili.com/video/BV17p411f7ZZ?p=1&quot; title=&quot;传送门&quot;&gt;b站 韩立刚 计算机网络&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 13. 机器人的运动范围</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/20/leetcode/offer/%E5%89%91%E6%8C%87Offer%2013/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/20/leetcode/offer/%E5%89%91%E6%8C%87Offer%2013/</id>
    <published>2020-11-20T13:30:00.000Z</published>
    <updated>2020-11-24T13:49:51.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a>剑指 Offer 13. 机器人的运动范围</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" title="leetcode链接">剑指 Offer 13. 机器人的运动范围</a></p><p><strong>难度:</strong><font color="orange">中等</font></p><p><strong>描述</strong></p><p>地上有一个m行n列的方格，从坐标<code> [0,0]</code> 到坐标<code> [m-1,n-1]</code> 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><a id="more"></a><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">2</span>, n = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">1</span>, k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">限制:</span><br><span class="line"><span class="number">1</span> &lt;= n,m &lt;= <span class="number">100</span></span><br><span class="line"><span class="number">0</span> &lt;= k &lt;= <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>机器人的运动范围虽然是在一个左上顶点为<code>[0,0]</code>, 右下顶点为<code>[m-1,n-1]</code>的矩形中运动, 但是机器人必须从<code>[0,0]</code>出发, 也就是说虽然有一些点是符合各数位之和小于 k 的, 但是机器人不可达就不应该计算在内.</p><p>这里, 我直接把所有符合要求的点全部记录在一个二维数组中, 然后通过 dfs 来求出 “岛屿” 的大小.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> _legalArea(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="comment">//true : i 和 j 的各个位之后小于k</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i)&#123;</span><br><span class="line">            sum += i % <span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j)&#123;</span><br><span class="line">            sum += j % <span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum &lt;= k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; <span class="built_in">map</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=<span class="built_in">map</span>.size() || j&lt;<span class="number">0</span> || j&gt;= <span class="built_in">map</span>[<span class="number">0</span>].size() || <span class="built_in">map</span>[i][j] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">map</span>[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">4</span>]&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span>; ++ k)&#123;</span><br><span class="line">            dfs(i+dx[k],j+dy[k],<span class="built_in">map</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">map</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(_legalArea(i,j,k) == <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="built_in">map</span>[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-13-机器人的运动范围&quot;&gt;&lt;a href=&quot;#剑指-Offer-13-机器人的运动范围&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 13. 机器人的运动范围&quot;&gt;&lt;/a&gt;剑指 Offer 13. 机器人的运动范围&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/&quot; title=&quot;leetcode链接&quot;&gt;剑指 Offer 13. 机器人的运动范围&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;orange&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地上有一个m行n列的方格，从坐标&lt;code&gt; [0,0]&lt;/code&gt; 到坐标&lt;code&gt; [m-1,n-1]&lt;/code&gt; 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="剑指 Offer 专题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
    <category term="DFS" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>博客文章以及Github仓库引导</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/20/top/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/20/top/</id>
    <published>2020-11-20T06:56:00.000Z</published>
    <updated>2020-12-06T14:42:57.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客文章引导"><a href="#博客文章引导" class="headerlink" title="博客文章引导"></a>博客文章引导</h1><p align="left"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a></p><p>我的博客, 即劳振煜的知識倉儲, 也就是您当前访问的博客. </p><p>博客是基于 Hexo 的静态博客, 部署于我的 Github 上.</p><p>该博客主要用来记录我在学习以及未来工作中的所感所悟. 留作记录以便自己在未来温故或帮助到正在看博客的你.</p><p>博客的内容区别于 Github 的内容, 主要是博客将会记录完整的有体系的内容, 而 Github 上的各个仓库主要是用于记录学习笔记与实验, 自己造轮子, 学习他人的开源项目.</p><hr><p>C++</p><p>STL</p><p>数据结构</p><p>计算机网络</p><left><a href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/23/HugeFour/Network/Deep_into_Network/" target="_blank"><img src="https://img.shields.io/badge/文章-计算机网络_韩立刚老师-faf2f2.svg?style=flat-square&logo=Instapaper"></a></left><left><a href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/10/26/HugeFour/Network/TCP/" target="_blank"><img src="https://img.shields.io/badge/文章-计算机网络 TCP-faf2f2.svg?style=flat-square&logo=Instapaper"></a></left><p>操作系统</p><left><a href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/08/HugeFour/OperatingSystem/QingHua/Deep_into_OperatingSystem_all/" target="_blank"><img src="https://img.shields.io/badge/文章-深入理解操作系统-faf2f2.svg?style=flat-square&logo=Instapaper"></a></left><p>设计模式</p><p>Leetcode</p><h1 id="Github仓库引导"><a href="#Github仓库引导" class="headerlink" title="Github仓库引导"></a>Github仓库引导</h1><left><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a></left><p>我的Github, 也就是上方链接. 你可以搜索 OXygenPanda 访问.</p><p>虽然没有很多 star, 但是仍然坚持学习, 坚持记录, 坚持分享.</p><hr><p>计算机网络课程学习 - 韩立刚老师    </p><blockquote><p>  记录计算机网络课程学习的笔记</p></blockquote><left><a href="https://github.com/OXygenPanda/Deep_into_Network" target="_blank"><img src="https://img.shields.io/badge/Github-@Deep_into_Network-f3e1e1.svg?style=flat-square&logo=GitHub"></a></left>深入理解操作系统课程学习 - 清华大学<blockquote><p>  记录清华大学深入理解操作系统课程学习的笔记</p></blockquote><left><a href="https://github.com/OXygenPanda/Deep_into_OperatingSystem" target="_blank"><img src="https://img.shields.io/badge/Github-@Deep_into_OperatingSystem-f3e1e1.svg?style=flat-square&logo=GitHub"></a></left>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;博客文章引导&quot;&gt;&lt;a href=&quot;#博客文章引导&quot; class=&quot;headerlink&quot; title=&quot;博客文章引导&quot;&gt;&lt;/a&gt;博客文章引导&lt;/h1&gt;&lt;p align=&quot;left&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/18/leetcode/offer/%E5%89%91%E6%8C%87Offer%2012/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/18/leetcode/offer/%E5%89%91%E6%8C%87Offer%2012/</id>
    <published>2020-11-18T02:30:00.000Z</published>
    <updated>2020-11-24T13:49:56.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a>剑指 Offer 12. 矩阵中的路径</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" title="leetcode链接">剑指 Offer 12. 矩阵中的路径</a></p><p><strong>难度:</strong><font color="orange">中等</font></p><p><strong>描述</strong></p><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,<strong>“b”</strong>,”c”,”e”],<br> [“s”,<strong>“f”</strong>,<strong>“c”</strong>,”s”],<br> [“a”,”d”,<strong>“e”</strong>,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><a id="more"></a><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: board = [[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;E&quot;</span>],[<span class="string">&quot;S&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;S&quot;</span>],[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;E&quot;</span>]], word = <span class="string">&quot;ABCCED&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">输入: board = [[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>],[<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>]], word = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">限制:</span><br><span class="line"><span class="number">1</span> &lt;= board.length &lt;= <span class="number">200</span></span><br><span class="line"><span class="number">1</span> &lt;= board[i].length &lt;= <span class="number">200</span></span><br></pre></td></tr></table></figure><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这是一道很经典的走迷宫题目了, 而且学习过DFS的话, 一定也看到过或者做过这道题目.</p><p>DFS: 深度优先搜索的意图是通过迭代的方式穷极一条路径, 如果最终无法匹配则舍弃(可以提前剪枝), 然后再选择其他路径再一往无前走到底.</p><p>在这个题目里的意思是, 我先从每一个位置 <code>(i,j)</code> 递归出<code>N</code>条长度和字符串长度相同的路径, 如果路径正好能够和字符串匹配则返回 <code>true</code> , 如果不匹配则再去寻找其他路径.</p><p>但是有几个优化的地方 : </p><ul><li>提前剪枝 : 判断边界不在 <code>board</code> 范围内, 或者当前位置的字符和我期待的字符串的某个字符不同就提前结束</li><li>board[i][j] = ‘#’ : 可以不使用 visit 数组来标记是否访问过该节点, 通过先把当前字符修改后还原节约空间</li><li>或运算的短路 : 像注释里那么写的话, 每一层递归都会做四次运算, 递归深度过大的话, 会超时; 而像 <code>13:16</code> 这么写, 可以有效利用”短路”, 当某一个<code>dfs</code>返回<code>true</code>时, 不需要去执行后续的递归操作, 大大节约了时间.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp; board, <span class="built_in">string</span> word, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=n || j&lt;<span class="number">0</span> || j&gt;=m || board[i][j] != word[start])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(word.length() == start + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> ret = dfs(i+dx[<span class="number">0</span>], j+dy[<span class="number">0</span>], board, word, start + <span class="number">1</span>) ||</span><br><span class="line">                   dfs(i+dx[<span class="number">1</span>], j+dy[<span class="number">1</span>], board, word, start + <span class="number">1</span>) ||</span><br><span class="line">                   dfs(i+dx[<span class="number">2</span>], j+dy[<span class="number">2</span>], board, word, start + <span class="number">1</span>) ||</span><br><span class="line">                   dfs(i+dx[<span class="number">3</span>], j+dy[<span class="number">3</span>], board, word, start + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//        for(int index = 0; index &lt; 4; ++index)&#123;</span></span><br><span class="line">        <span class="comment">//            ret |= dfs(i+dx[index], j+dy[index], board, word, start + 1);</span></span><br><span class="line">        board[i][j] = tmp;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        n = board.size(), m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(dfs(i, j, board, word, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-12-矩阵中的路径&quot;&gt;&lt;a href=&quot;#剑指-Offer-12-矩阵中的路径&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 12. 矩阵中的路径&quot;&gt;&lt;/a&gt;剑指 Offer 12. 矩阵中的路径&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/&quot; title=&quot;leetcode链接&quot;&gt;剑指 Offer 12. 矩阵中的路径&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;orange&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。&lt;/p&gt;
&lt;p&gt;[[“a”,&lt;strong&gt;“b”&lt;/strong&gt;,”c”,”e”],&lt;br&gt; [“s”,&lt;strong&gt;“f”&lt;/strong&gt;,&lt;strong&gt;“c”&lt;/strong&gt;,”s”],&lt;br&gt; [“a”,”d”,&lt;strong&gt;“e”&lt;/strong&gt;,”e”]]&lt;/p&gt;
&lt;p&gt;但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="剑指 Offer 专题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
    <category term="DFS" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/17/leetcode/offer/%E5%89%91%E6%8C%87Offer%2011/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/17/leetcode/offer/%E5%89%91%E6%8C%87Offer%2011/</id>
    <published>2020-11-17T10:45:00.000Z</published>
    <updated>2020-11-24T14:19:31.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" title="leetcode链接">剑指 Offer 11. 旋转数组的最小数字</a></p><p><strong>难度:</strong><font color="green">简单</font></p><p><strong>描述</strong></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组<code> [3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。  </p><a id="more"></a><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">输入：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>遥记得很久以前写斐波那契数列的问题时, 不考虑时间空间复杂度. 一股脑把所有的斐波那契数存下来, 现在针对这一题来说, 它没有必要存下每一个斐波那契数, 只需要返回第<code>n</code>个,所以就把DP问题优化了一下,减少了空间复杂度.<code>mod</code>的位置比较重要, 因为中途计算的时候可能会使得dp_2超出整形范围,所以在运算时就得<code>mod</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)    <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_0 = <span class="number">0</span>, dp_1 = <span class="number">1</span>, dp_2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp_2 = (dp_0 + dp_1) % mod;</span><br><span class="line">            dp_0 = dp_1;</span><br><span class="line">            dp_1 = dp_2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-11-旋转数组的最小数字&quot;&gt;&lt;a href=&quot;#剑指-Offer-11-旋转数组的最小数字&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 11. 旋转数组的最小数字&quot;&gt;&lt;/a&gt;剑指 Offer 11. 旋转数组的最小数字&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a class=&quot;btn&quot; href=&quot;https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/&quot; title=&quot;leetcode链接&quot;&gt;剑指 Offer 11. 旋转数组的最小数字&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度:&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组&lt;code&gt; [3,4,5,1,2]&lt;/code&gt; 为 &lt;code&gt;[1,2,3,4,5]&lt;/code&gt; 的一个旋转，该数组的最小值为1。  &lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="剑指 Offer 专题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
    <category term="动态规划" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 10- I. 斐波那契数列</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/17/leetcode/offer/%E5%89%91%E6%8C%87Offer%2010/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/17/leetcode/offer/%E5%89%91%E6%8C%87Offer%2010/</id>
    <published>2020-11-17T10:25:00.000Z</published>
    <updated>2020-11-24T14:19:27.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a class="btn" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" title="leetcode链接">剑指 Offer 10. 斐波那契数列</a></p><p><strong>难度:</strong><font color="green">简单</font></p><p><strong>描述</strong></p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项。斐波那契数列的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>,   F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(N) = F(N - <span class="number">1</span>) + F(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1.</span></span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">   </span><br><span class="line">限制：</span><br><span class="line"><span class="number">0</span> &lt;= n &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>遥记得很久以前写斐波那契数列的问题时, 不考虑时间空间复杂度. 一股脑把所有的斐波那契数存下来, 现在针对这一题来说, 它没有必要存下每一个斐波那契数, 只需要返回第<code>n</code>个,所以就把DP问题优化了一下,减少了空间复杂度.<code>mod</code>的位置比较重要, 因为中途计算的时候可能会使得dp_2超出整形范围,所以在运算时就得<code>mod</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)    <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_0 = <span class="number">0</span>, dp_1 = <span class="number">1</span>, dp_2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp_2 = (dp_0 + dp_1) % mod;</span><br><span class="line">            dp_0 = dp_1;</span><br><span class="line">            dp_1 = dp_2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-10-I-斐波那契数列&quot;&gt;&lt;a href=&quot;#剑指-Offer-10-I-斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 10- I. 斐波那契数列&quot;&gt;&lt;/a&gt;剑指 Offer 10- I. 斐波那契数列&lt;/</summary>
      
    
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/"/>
    
    <category term="剑指 Offer 专题" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/Leetcode/%E5%89%91%E6%8C%87-Offer-%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Leetcode" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/Leetcode/"/>
    
    <category term="动态规划" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>shared_ptr的简单实现</title>
    <link href="https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/12/C++/smart_ptr/"/>
    <id>https://oxygenpanda.github.io/OXygenPanda.github.io/2020/11/12/C++/smart_ptr/</id>
    <published>2020-11-12T11:23:00.000Z</published>
    <updated>2020-11-24T14:13:10.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h1><p align="center"><a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a><a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a><a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a></p><p>程序运行时需要分配内存释放内存, 在C++中我们使用关键词 <code>new</code> 和 <code>delete</code> . </p><p><code>new</code> 是一个运算符, 负责申请堆内存, 分为两个步骤 : 1.malloc 2.operator new, 即先申请内存, 再构造对象. 最后返回该堆内存的指针. </p><p><code>delete</code>也是一个运算符, 负责释放堆内存, 分为两个步骤 :1.operator delete 2.free, 即先调用对象的析构函数, 再释放内存.</p><p>堆内存需要程序员手动释放, 因此如果程序抛出异常, 来不及释放内存或者忘记释放内存都会导致内存泄漏. </p><a id="more"></a><p>因此, C++11以后有了三种更加安全, 更加智能的”指针”. 说是指针, 其实是用起来像指针的类. 这一种思想和STL的仿函数, 迭代器中类似.</p><p>标准库提供的三种智能指针的区别在于管理底层指针的方法不同, <code>shared_ptr</code> 允许多个指针指向同一个对象, <code>unique_ptr</code> 则”独占”所指向的对象. 标准库还定义了一种名为<code>weak_ptr</code>的伴随类, 它是一种弱引用, 指向<code>shared_ptr</code>所管理的对象, 这三种智能指针都定义在<code>memory</code>头文件中.</p><p>这一篇文章主要是手动实现了一下 <code>shared_ptr</code> 和 <code>unique_ptr</code> 类. </p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myshared_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T * _ptr;</span><br><span class="line"><span class="keyword">int</span> * _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">myshared_ptr():_ptr(<span class="literal">nullptr</span>),_count(<span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;default ctor&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">myshared_ptr(T * ptr):_ptr(ptr),_count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;raw pointer ctor : &quot;</span> &lt;&lt; *ptr  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">myshared_ptr(myshared_ptr &amp; ref):_ptr(ref._ptr),_count(&amp;(++*(ref._count)))&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;shared_ptr ctor : &quot;</span> &lt;&lt; *ref._ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">~myshared_ptr()&#123;</span><br><span class="line"><span class="keyword">if</span>(--*(<span class="keyword">this</span>-&gt;_count) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *_ptr &lt;&lt; <span class="string">&quot; dector!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line"><span class="keyword">delete</span> _count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝赋值</span></span><br><span class="line">myshared_ptr &amp; <span class="keyword">operator</span>=(myshared_ptr &amp; ref)&#123;</span><br><span class="line"><span class="keyword">if</span>(&amp;ref == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">++*ref._count;</span><br><span class="line"><span class="keyword">if</span>(--*(<span class="keyword">this</span>-&gt;_count) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *_ptr &lt;&lt; <span class="string">&quot; dector!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;_ptr = ref._ptr;</span><br><span class="line"><span class="keyword">this</span>-&gt;_count = ref._count;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;operator = success&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 引用</span></span><br><span class="line">    T <span class="keyword">operator</span>*()&#123;</span><br><span class="line"><span class="keyword">if</span>(_count == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (T)<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头</span></span><br><span class="line">    T * <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line"><span class="keyword">if</span>(_count == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="function">myshared_ptr&lt;<span class="built_in">string</span>&gt; <span class="title">pstr1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">myshared_ptr&lt;<span class="built_in">string</span>&gt; <span class="title">pstr2</span><span class="params">(pstr1)</span></span>;</span><br><span class="line">    <span class="function">myshared_ptr&lt;<span class="built_in">string</span>&gt; <span class="title">pstr3</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>))</span></span>;</span><br><span class="line">    pstr3 = pstr1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">--------------------</span><br><span class="line">raw pointer ctor : hello</span><br><span class="line"><span class="built_in">shared_ptr</span> ctor : hello</span><br><span class="line">raw pointer ctor : world</span><br><span class="line">world dector!</span><br><span class="line"><span class="keyword">operator</span> = success</span><br><span class="line">hello dector!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Deleter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = Deleter&gt;</span><br><span class="line">class myunique_ptr&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 一个对象只能有一个 unique_ptr 指向, 当指针销毁,对象也销毁</span></span><br><span class="line"><span class="comment"> * 2. 初始化 unique_ptr 只能采用直接初始化的方式(explicit 修饰构造函数)</span></span><br><span class="line"><span class="comment"> * 3. 不支持拷贝构造和拷贝赋值</span></span><br><span class="line"><span class="comment"> * 4. 支持搬移构造和搬移赋值获得函数返回值或者函数局部变量</span></span><br><span class="line"><span class="comment"> * 5. 必须提供删除器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T * _ptr;</span><br><span class="line">D del;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">myunique_ptr</span><span class="params">(T *pointer = <span class="literal">nullptr</span>, <span class="keyword">const</span> D &amp;dd = D())</span></span></span><br><span class="line">:_ptr(pointer),del(dd)&#123;&#125;</span><br><span class="line">~myunique_ptr()&#123;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">myunique_ptr(<span class="keyword">const</span> myunique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">myunique_ptr &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> myunique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">myunique_ptr(myunique_ptr &amp;&amp; right_value)</span><br><span class="line">:_ptr(right_value._ptr),del(<span class="built_in">std</span>::move(right_value.del))&#123;</span><br><span class="line">right_value._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">myunique_ptr &amp; <span class="keyword">operator</span>=(myunique_ptr &amp;&amp; right_value) <span class="keyword">noexcept</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> != &amp;right_value)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;operator &amp;&amp; right_value&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">del(*<span class="keyword">this</span>);</span><br><span class="line">_ptr = right_value._ptr;</span><br><span class="line">del = <span class="built_in">std</span>::move(right_value.del);</span><br><span class="line">right_value._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// release() 返回资源,释放管理</span></span><br><span class="line"><span class="function">T * <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">T * tmp = _ptr;</span><br><span class="line">_ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reset()</span></span><br><span class="line"><span class="comment">// reset(T * ptr)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">del(_ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T * ptr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">del(_ptr);</span><br><span class="line">_ptr = ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// swap()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(myunique_ptr &amp; other)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">swap(_ptr, other._ptr);</span><br><span class="line">swap(del, other.del);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"><span class="function">D&amp; <span class="title">get_deleter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> del;   &#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>*()   &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()  &#123; <span class="keyword">return</span> _ptr;  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">base()&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ctor&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~base()&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dector&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">base(<span class="keyword">const</span> base&amp;)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;left_value ctor&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">base(base&amp;&amp;)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;right_value ctor&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">base_deleter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(base* p)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deleter function call&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// myunique_ptr&lt;string&gt; uptr1;</span></span><br><span class="line"><span class="comment">// myunique_ptr&lt;string&gt; uptr2(new string(&quot;abc&quot;));</span></span><br><span class="line"><span class="comment">// myunique_ptr&lt;string&gt; uptr3(nullptr);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">base_deleter d;</span><br><span class="line">myunique_ptr&lt;base,base_deleter&gt; uptr1;</span><br><span class="line">myunique_ptr&lt;base,base_deleter&gt; uptr2(nullptr);</span><br><span class="line">myunique_ptr&lt;base,base_deleter&gt; uptr3(new base);</span><br><span class="line">myunique_ptr&lt;base,base_deleter&gt; uptr4(new base, d);</span><br><span class="line">base* fp = uptr4.release();</span><br><span class="line">assert(uptr4.get() == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">delete</span> fp;</span><br><span class="line">uptr3.reset(<span class="keyword">new</span> base());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line">--------------------</span><br><span class="line">ctor</span><br><span class="line">ctor</span><br><span class="line">dector</span><br><span class="line">ctor</span><br><span class="line">deleter function call</span><br><span class="line">dector</span><br><span class="line">dector</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;智能指针的实现&quot;&gt;&lt;a href=&quot;#智能指针的实现&quot; class=&quot;headerlink&quot; title=&quot;智能指针的实现&quot;&gt;&lt;/a&gt;智能指针的实现&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://oxygenpanda.github.io/&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;Website&quot; src=&quot;https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&amp;logo=Blogger&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://www.github.com/OXygenPanda&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&amp;logo=GitHub&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&amp;logo=WeChat&quot;&gt;&lt;/a&gt;

&lt;/p&gt;&lt;p&gt;程序运行时需要分配内存释放内存, 在C++中我们使用关键词 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; . &lt;/p&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 是一个运算符, 负责申请堆内存, 分为两个步骤 : 1.malloc 2.operator new, 即先申请内存, 再构造对象. 最后返回该堆内存的指针. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;delete&lt;/code&gt;也是一个运算符, 负责释放堆内存, 分为两个步骤 :1.operator delete 2.free, 即先调用对象的析构函数, 再释放内存.&lt;/p&gt;
&lt;p&gt;堆内存需要程序员手动释放, 因此如果程序抛出异常, 来不及释放内存或者忘记释放内存都会导致内存泄漏. &lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/categories/C/"/>
    
    
    <category term="C++11" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/C-11/"/>
    
    <category term="智能指针" scheme="https://oxygenpanda.github.io/OXygenPanda.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
